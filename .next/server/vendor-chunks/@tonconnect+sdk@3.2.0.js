"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tonconnect+sdk@3.2.0";
exports.ids = ["vendor-chunks/@tonconnect+sdk@3.2.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@tonconnect+sdk@3.2.0/node_modules/@tonconnect/sdk/lib/esm/index.mjs":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tonconnect+sdk@3.2.0/node_modules/@tonconnect/sdk/lib/esm/index.mjs ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BadRequestError: () => (/* binding */ BadRequestError),\n/* harmony export */   BrowserEventDispatcher: () => (/* binding */ BrowserEventDispatcher),\n/* harmony export */   CHAIN: () => (/* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CHAIN),\n/* harmony export */   CONNECT_EVENT_ERROR_CODES: () => (/* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES),\n/* harmony export */   CONNECT_ITEM_ERROR_CODES: () => (/* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_ITEM_ERROR_CODES),\n/* harmony export */   FetchWalletsError: () => (/* binding */ FetchWalletsError),\n/* harmony export */   LocalstorageNotFoundError: () => (/* binding */ LocalstorageNotFoundError),\n/* harmony export */   ParseHexError: () => (/* binding */ ParseHexError),\n/* harmony export */   SEND_TRANSACTION_ERROR_CODES: () => (/* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES),\n/* harmony export */   SIGN_DATA_ERROR_CODES: () => (/* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SIGN_DATA_ERROR_CODES),\n/* harmony export */   TonConnect: () => (/* binding */ TonConnect),\n/* harmony export */   TonConnectError: () => (/* binding */ TonConnectError),\n/* harmony export */   UnknownAppError: () => (/* binding */ UnknownAppError),\n/* harmony export */   UnknownError: () => (/* binding */ UnknownError),\n/* harmony export */   UserRejectsError: () => (/* binding */ UserRejectsError),\n/* harmony export */   WalletAlreadyConnectedError: () => (/* binding */ WalletAlreadyConnectedError),\n/* harmony export */   WalletMissingRequiredFeaturesError: () => (/* binding */ WalletMissingRequiredFeaturesError),\n/* harmony export */   WalletNotConnectedError: () => (/* binding */ WalletNotConnectedError),\n/* harmony export */   WalletNotInjectedError: () => (/* binding */ WalletNotInjectedError),\n/* harmony export */   WalletNotSupportFeatureError: () => (/* binding */ WalletNotSupportFeatureError),\n/* harmony export */   WalletsListManager: () => (/* binding */ WalletsListManager),\n/* harmony export */   WrongAddressError: () => (/* binding */ WrongAddressError),\n/* harmony export */   checkRequiredWalletFeatures: () => (/* binding */ checkRequiredWalletFeatures),\n/* harmony export */   createConnectionCompletedEvent: () => (/* binding */ createConnectionCompletedEvent),\n/* harmony export */   createConnectionErrorEvent: () => (/* binding */ createConnectionErrorEvent),\n/* harmony export */   createConnectionRestoringCompletedEvent: () => (/* binding */ createConnectionRestoringCompletedEvent),\n/* harmony export */   createConnectionRestoringErrorEvent: () => (/* binding */ createConnectionRestoringErrorEvent),\n/* harmony export */   createConnectionRestoringStartedEvent: () => (/* binding */ createConnectionRestoringStartedEvent),\n/* harmony export */   createConnectionStartedEvent: () => (/* binding */ createConnectionStartedEvent),\n/* harmony export */   createDataSentForSignatureEvent: () => (/* binding */ createDataSentForSignatureEvent),\n/* harmony export */   createDataSignedEvent: () => (/* binding */ createDataSignedEvent),\n/* harmony export */   createDataSigningFailedEvent: () => (/* binding */ createDataSigningFailedEvent),\n/* harmony export */   createDisconnectionEvent: () => (/* binding */ createDisconnectionEvent),\n/* harmony export */   createRequestVersionEvent: () => (/* binding */ createRequestVersionEvent),\n/* harmony export */   createResponseVersionEvent: () => (/* binding */ createResponseVersionEvent),\n/* harmony export */   createTransactionSentForSignatureEvent: () => (/* binding */ createTransactionSentForSignatureEvent),\n/* harmony export */   createTransactionSignedEvent: () => (/* binding */ createTransactionSignedEvent),\n/* harmony export */   createTransactionSigningFailedEvent: () => (/* binding */ createTransactionSigningFailedEvent),\n/* harmony export */   createVersionInfo: () => (/* binding */ createVersionInfo),\n/* harmony export */   \"default\": () => (/* binding */ TonConnect),\n/* harmony export */   encodeTelegramUrlParameters: () => (/* binding */ encodeTelegramUrlParameters),\n/* harmony export */   isTelegramUrl: () => (/* binding */ isTelegramUrl),\n/* harmony export */   isWalletInfoCurrentlyEmbedded: () => (/* binding */ isWalletInfoCurrentlyEmbedded),\n/* harmony export */   isWalletInfoCurrentlyInjected: () => (/* binding */ isWalletInfoCurrentlyInjected),\n/* harmony export */   isWalletInfoInjectable: () => (/* binding */ isWalletInfoInjectable),\n/* harmony export */   isWalletInfoInjected: () => (/* binding */ isWalletInfoInjected),\n/* harmony export */   isWalletInfoRemote: () => (/* binding */ isWalletInfoRemote),\n/* harmony export */   toUserFriendlyAddress: () => (/* binding */ toUserFriendlyAddress)\n/* harmony export */ });\n/* harmony import */ var _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tonconnect/protocol */ \"(ssr)/./node_modules/.pnpm/@tonconnect+protocol@2.3.0/node_modules/@tonconnect/protocol/lib/esm/index.mjs\");\n/* harmony import */ var _tonconnect_isomorphic_eventsource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tonconnect/isomorphic-eventsource */ \"(ssr)/./node_modules/.pnpm/@tonconnect+isomorphic-eventsource@0.0.2/node_modules/@tonconnect/isomorphic-eventsource/index.mjs\");\n/* harmony import */ var _tonconnect_isomorphic_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tonconnect/isomorphic-fetch */ \"(ssr)/./node_modules/.pnpm/@tonconnect+isomorphic-fetch@0.0.3/node_modules/@tonconnect/isomorphic-fetch/index.mjs\");\n\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\n/**\n * Base class for TonConnect errors. You can check if the error was triggered by the @tonconnect/sdk using `err instanceof TonConnectError`.\n */\nclass TonConnectError extends Error {\n    constructor(message, options) {\n        super(message, options);\n        this.message = `${TonConnectError.prefix} ${this.constructor.name}${this.info ? ': ' + this.info : ''}${message ? '\\n' + message : ''}`;\n        Object.setPrototypeOf(this, TonConnectError.prototype);\n    }\n    get info() {\n        return '';\n    }\n}\nTonConnectError.prefix = '[TON_CONNECT_SDK_ERROR]';\n\n/**\n * Thrown when passed DappMetadata is in incorrect format.\n */\nclass DappMetadataError extends TonConnectError {\n    get info() {\n        return 'Passed DappMetadata is in incorrect format.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, DappMetadataError.prototype);\n    }\n}\n\n/**\n * Thrown when passed manifest contains errors.\n */\nclass ManifestContentErrorError extends TonConnectError {\n    get info() {\n        return 'Passed `tonconnect-manifest.json` contains errors. Check format of your manifest. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, ManifestContentErrorError.prototype);\n    }\n}\n\n/**\n * Thrown when wallet can't get manifest by passed manifestUrl.\n */\nclass ManifestNotFoundError extends TonConnectError {\n    get info() {\n        return 'Manifest not found. Make sure you added `tonconnect-manifest.json` to the root of your app or passed correct manifestUrl. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, ManifestNotFoundError.prototype);\n    }\n}\n\n/**\n * Thrown when wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection.\n */\nclass WalletAlreadyConnectedError extends TonConnectError {\n    get info() {\n        return 'Wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, WalletAlreadyConnectedError.prototype);\n    }\n}\n\n/**\n * Thrown when send transaction or other protocol methods called while wallet is not connected.\n */\nclass WalletNotConnectedError extends TonConnectError {\n    get info() {\n        return 'Send transaction or other protocol methods called while wallet is not connected.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, WalletNotConnectedError.prototype);\n    }\n}\n\n/**\n * Thrown when there is an attempt to connect to the injected wallet while it is not exists in the webpage.\n */\nclass WalletNotInjectedError extends TonConnectError {\n    get info() {\n        return 'There is an attempt to connect to the injected wallet while it is not exists in the webpage.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, WalletNotInjectedError.prototype);\n    }\n}\n\n/**\n * Thrown when wallet doesn't support requested feature method.\n */\nclass WalletNotSupportFeatureError extends TonConnectError {\n    get info() {\n        return \"Wallet doesn't support requested feature method.\";\n    }\n    constructor(message, options) {\n        super(message, options);\n        Object.setPrototypeOf(this, WalletNotSupportFeatureError.prototype);\n    }\n}\n\n/**\n * Thrown when wallet can't get manifest by passed manifestUrl.\n */\nclass WalletMissingRequiredFeaturesError extends TonConnectError {\n    get info() {\n        return 'Missing required features. You need to update your wallet.';\n    }\n    constructor(message, options) {\n        super(message, options);\n        Object.setPrototypeOf(this, WalletMissingRequiredFeaturesError.prototype);\n    }\n}\n\nfunction isWalletConnectionSourceJS(value) {\n    return 'jsBridgeKey' in value;\n}\n\n/**\n * Thrown when user rejects the action in the wallet.\n */\nclass UserRejectsError extends TonConnectError {\n    get info() {\n        return 'User rejects the action in the wallet.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, UserRejectsError.prototype);\n    }\n}\n\n/**\n * Thrown when request to the wallet contains errors.\n */\nclass BadRequestError extends TonConnectError {\n    get info() {\n        return 'Request to the wallet contains errors.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, BadRequestError.prototype);\n    }\n}\n\n/**\n * Thrown when app tries to send rpc request to the injected wallet while not connected.\n */\nclass UnknownAppError extends TonConnectError {\n    get info() {\n        return 'App tries to send rpc request to the injected wallet while not connected.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, UnknownAppError.prototype);\n    }\n}\n\n/**\n * Thrown when `Storage` was not specified in the `DappMetadata` and default `localStorage` was not detected in the Node.js environment.\n */\nclass LocalstorageNotFoundError extends TonConnectError {\n    get info() {\n        return 'Storage was not specified in the `DappMetadata` and default `localStorage` was not detected in the environment.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, LocalstorageNotFoundError.prototype);\n    }\n}\n\n/**\n * Thrown when an error occurred while fetching the wallets list.\n */\nclass FetchWalletsError extends TonConnectError {\n    get info() {\n        return 'An error occurred while fetching the wallets list.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, FetchWalletsError.prototype);\n    }\n}\n\n/**\n * Thrown when passed address is in incorrect format.\n */\nclass WrongAddressError extends TonConnectError {\n    get info() {\n        return 'Passed address is in incorrect format.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, WrongAddressError.prototype);\n    }\n}\n\n/**\n * Thrown when passed hex is in incorrect format.\n */\nclass ParseHexError extends TonConnectError {\n    get info() {\n        return 'Passed hex is in incorrect format.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, ParseHexError.prototype);\n    }\n}\n\n/**\n * Unhanded unknown error.\n */\nclass UnknownError extends TonConnectError {\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, UnknownError.prototype);\n    }\n}\n\nconst connectEventErrorsCodes = {\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.MANIFEST_NOT_FOUND_ERROR]: ManifestNotFoundError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR]: ManifestContentErrorError\n};\nclass ConnectErrorsParser {\n    parseError(error) {\n        let ErrorConstructor = UnknownError;\n        if (error.code in connectEventErrorsCodes) {\n            ErrorConstructor = connectEventErrorsCodes[error.code] || UnknownError;\n        }\n        return new ErrorConstructor(error.message);\n    }\n}\nconst connectErrorsParser = new ConnectErrorsParser();\n\nclass RpcParser {\n    isError(response) {\n        return 'error' in response;\n    }\n}\n\nconst sendTransactionErrors = {\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError\n};\nclass SendTransactionParser extends RpcParser {\n    convertToRpcRequest(request) {\n        return {\n            method: 'sendTransaction',\n            params: [JSON.stringify(request)]\n        };\n    }\n    parseAndThrowError(response) {\n        let ErrorConstructor = UnknownError;\n        if (response.error.code in sendTransactionErrors) {\n            ErrorConstructor = sendTransactionErrors[response.error.code] || UnknownError;\n        }\n        throw new ErrorConstructor(response.error.message);\n    }\n    convertFromRpcResponse(rpcResponse) {\n        return {\n            boc: rpcResponse.result\n        };\n    }\n}\nconst sendTransactionParser = new SendTransactionParser();\n\nconst signDataErrors = {\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SIGN_DATA_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SIGN_DATA_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SIGN_DATA_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SIGN_DATA_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError\n};\nclass SignDataParser extends RpcParser {\n    convertToRpcRequest(payload) {\n        return {\n            method: 'signData',\n            params: [JSON.stringify(payload)]\n        };\n    }\n    parseAndThrowError(response) {\n        let ErrorConstructor = UnknownError;\n        if (response.error.code in signDataErrors) {\n            ErrorConstructor = signDataErrors[response.error.code] || UnknownError;\n        }\n        throw new ErrorConstructor(response.error.message);\n    }\n    convertFromRpcResponse(rpcResponse) {\n        return rpcResponse.result;\n    }\n}\nconst signDataParser = new SignDataParser();\n\nclass HttpBridgeGatewayStorage {\n    constructor(storage, bridgeUrl) {\n        this.storage = storage;\n        this.storeKey = 'ton-connect-storage_http-bridge-gateway::' + bridgeUrl;\n    }\n    storeLastEventId(lastEventId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.storage.setItem(this.storeKey, lastEventId);\n        });\n    }\n    removeLastEventId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.storage.removeItem(this.storeKey);\n        });\n    }\n    getLastEventId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const stored = yield this.storage.getItem(this.storeKey);\n            if (!stored) {\n                return null;\n            }\n            return stored;\n        });\n    }\n}\n\nfunction removeUrlLastSlash(url) {\n    if (url.slice(-1) === '/') {\n        return url.slice(0, -1);\n    }\n    return url;\n}\nfunction addPathToUrl(url, path) {\n    return removeUrlLastSlash(url) + '/' + path;\n}\nfunction isTelegramUrl(link) {\n    if (!link) {\n        return false;\n    }\n    const url = new URL(link);\n    return url.protocol === 'tg:' || url.hostname === 't.me';\n}\nfunction encodeTelegramUrlParameters(parameters) {\n    return parameters\n        .replaceAll('.', '%2E')\n        .replaceAll('-', '%2D')\n        .replaceAll('_', '%5F')\n        .replaceAll('&', '-')\n        .replaceAll('=', '__')\n        .replaceAll('%', '--');\n}\n\n/**\n * Delays the execution of code for a specified number of milliseconds.\n * @param {number} timeout - The number of milliseconds to delay the execution.\n * @param {DelayOptions} [options] - Optional configuration options for the delay.\n * @return {Promise<void>} - A promise that resolves after the specified delay, or rejects if the delay is aborted.\n */\nfunction delay(timeout, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            var _a, _b;\n            if ((_a = options === null || options === void 0 ? void 0 : options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                reject(new TonConnectError('Delay aborted'));\n                return;\n            }\n            const timeoutId = setTimeout(() => resolve(), timeout);\n            (_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 ? void 0 : _b.addEventListener('abort', () => {\n                clearTimeout(timeoutId);\n                reject(new TonConnectError('Delay aborted'));\n            });\n        });\n    });\n}\n\n/**\n * Creates an AbortController instance with an optional AbortSignal.\n *\n * @param {AbortSignal} [signal] - An optional AbortSignal to use for aborting the controller.\n * @returns {AbortController} - An instance of AbortController.\n */\nfunction createAbortController(signal) {\n    const abortController = new AbortController();\n    if (signal === null || signal === void 0 ? void 0 : signal.aborted) {\n        abortController.abort();\n    }\n    else {\n        signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', () => abortController.abort(), { once: true });\n    }\n    return abortController;\n}\n\n/**\n * Function to call ton api until we get response.\n * Because ton network is pretty unstable we need to make sure response is final.\n * @param {T} fn - function to call\n * @param {CallForSuccessOptions} [options] - optional configuration options\n */\nfunction callForSuccess(fn, options) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n        const attempts = (_a = options === null || options === void 0 ? void 0 : options.attempts) !== null && _a !== void 0 ? _a : 10;\n        const delayMs = (_b = options === null || options === void 0 ? void 0 : options.delayMs) !== null && _b !== void 0 ? _b : 200;\n        const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n        if (typeof fn !== 'function') {\n            throw new TonConnectError(`Expected a function, got ${typeof fn}`);\n        }\n        let i = 0;\n        let lastError;\n        while (i < attempts) {\n            if (abortController.signal.aborted) {\n                throw new TonConnectError(`Aborted after attempts ${i}`);\n            }\n            try {\n                return yield fn({ signal: abortController.signal });\n            }\n            catch (err) {\n                lastError = err;\n                i++;\n                if (i < attempts) {\n                    yield delay(delayMs);\n                }\n            }\n        }\n        throw lastError;\n    });\n}\n\nfunction logDebug(...args) {\n    {\n        try {\n            console.debug('[TON_CONNECT_SDK]', ...args);\n        }\n        catch (_a) { }\n    }\n}\nfunction logError(...args) {\n    {\n        try {\n            console.error('[TON_CONNECT_SDK]', ...args);\n        }\n        catch (_a) { }\n    }\n}\nfunction logWarning(...args) {\n    {\n        try {\n            console.warn('[TON_CONNECT_SDK]', ...args);\n        }\n        catch (_a) { }\n    }\n}\n\n/**\n * Create a resource.\n *\n * @template T - The type of the resource.\n * @template Args - The type of the arguments for creating the resource.\n *\n * @param {(...args: Args) => Promise<T>} createFn - A function that creates the resource.\n * @param {(resource: T) => Promise<void>} [disposeFn] - An optional function that disposes the resource.\n */\nfunction createResource(createFn, disposeFn) {\n    let currentResource = null;\n    let currentArgs = null;\n    let currentPromise = null;\n    let currentSignal = null;\n    let abortController = null;\n    // create a new resource\n    const create = (signal, ...args) => __awaiter(this, void 0, void 0, function* () {\n        currentSignal = signal !== null && signal !== void 0 ? signal : null;\n        abortController === null || abortController === void 0 ? void 0 : abortController.abort();\n        abortController = createAbortController(signal);\n        if (abortController.signal.aborted) {\n            throw new TonConnectError('Resource creation was aborted');\n        }\n        currentArgs = args !== null && args !== void 0 ? args : null;\n        const promise = createFn(abortController.signal, ...args);\n        currentPromise = promise;\n        const resource = yield promise;\n        if (currentPromise !== promise && resource !== currentResource) {\n            yield disposeFn(resource);\n            throw new TonConnectError('Resource creation was aborted by a new resource creation');\n        }\n        currentResource = resource;\n        return currentResource;\n    });\n    // get the current resource\n    const current = () => {\n        return currentResource !== null && currentResource !== void 0 ? currentResource : null;\n    };\n    // dispose the current resource\n    const dispose = () => __awaiter(this, void 0, void 0, function* () {\n        try {\n            const resource = currentResource;\n            currentResource = null;\n            const promise = currentPromise;\n            currentPromise = null;\n            try {\n                abortController === null || abortController === void 0 ? void 0 : abortController.abort();\n            }\n            catch (e) { }\n            yield Promise.allSettled([\n                resource ? disposeFn(resource) : Promise.resolve(),\n                promise ? disposeFn(yield promise) : Promise.resolve()\n            ]);\n        }\n        catch (e) { }\n    });\n    // recreate the current resource\n    const recreate = (delayMs) => __awaiter(this, void 0, void 0, function* () {\n        const resource = currentResource;\n        const promise = currentPromise;\n        const args = currentArgs;\n        const signal = currentSignal;\n        yield delay(delayMs);\n        if (resource === currentResource &&\n            promise === currentPromise &&\n            args === currentArgs &&\n            signal === currentSignal) {\n            return yield create(currentSignal, ...(args !== null && args !== void 0 ? args : []));\n        }\n        throw new TonConnectError('Resource recreation was aborted by a new resource creation');\n    });\n    return {\n        create,\n        current,\n        dispose,\n        recreate\n    };\n}\n\n/**\n * Executes a function and provides deferred behavior, allowing for a timeout and abort functionality.\n *\n * @param {Deferrable<T>} fn - The function to execute. It should return a promise that resolves with the desired result.\n * @param {DeferOptions} options - Optional configuration options for the defer behavior.\n * @returns {Promise<T>} - A promise that resolves with the result of the executed function, or rejects with an error if it times out or is aborted.\n */\nfunction timeout(fn, options) {\n    const timeout = options === null || options === void 0 ? void 0 : options.timeout;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    const abortController = createAbortController(signal);\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        if (abortController.signal.aborted) {\n            reject(new TonConnectError('Operation aborted'));\n            return;\n        }\n        let timeoutId;\n        if (typeof timeout !== 'undefined') {\n            timeoutId = setTimeout(() => {\n                abortController.abort();\n                reject(new TonConnectError(`Timeout after ${timeout}ms`));\n            }, timeout);\n        }\n        abortController.signal.addEventListener('abort', () => {\n            clearTimeout(timeoutId);\n            reject(new TonConnectError('Operation aborted'));\n        }, { once: true });\n        const deferOptions = { timeout, abort: abortController.signal };\n        yield fn((...args) => {\n            clearTimeout(timeoutId);\n            resolve(...args);\n        }, () => {\n            clearTimeout(timeoutId);\n            reject();\n        }, deferOptions);\n    }));\n}\n\nclass BridgeGateway {\n    constructor(storage, bridgeUrl, sessionId, listener, errorsListener) {\n        this.bridgeUrl = bridgeUrl;\n        this.sessionId = sessionId;\n        this.listener = listener;\n        this.errorsListener = errorsListener;\n        this.ssePath = 'events';\n        this.postPath = 'message';\n        this.heartbeatMessage = 'heartbeat';\n        this.defaultTtl = 300;\n        this.defaultReconnectDelay = 2000;\n        this.defaultResendDelay = 5000;\n        this.eventSource = createResource((signal, openingDeadlineMS) => __awaiter(this, void 0, void 0, function* () {\n            const eventSourceConfig = {\n                bridgeUrl: this.bridgeUrl,\n                ssePath: this.ssePath,\n                sessionId: this.sessionId,\n                bridgeGatewayStorage: this.bridgeGatewayStorage,\n                errorHandler: this.errorsHandler.bind(this),\n                messageHandler: this.messagesHandler.bind(this),\n                signal: signal,\n                openingDeadlineMS: openingDeadlineMS\n            };\n            return yield createEventSource(eventSourceConfig);\n        }), (resource) => __awaiter(this, void 0, void 0, function* () {\n            resource.close();\n        }));\n        this.bridgeGatewayStorage = new HttpBridgeGatewayStorage(storage, bridgeUrl);\n    }\n    get isReady() {\n        const eventSource = this.eventSource.current();\n        return (eventSource === null || eventSource === void 0 ? void 0 : eventSource.readyState) === EventSource.OPEN;\n    }\n    get isClosed() {\n        const eventSource = this.eventSource.current();\n        return (eventSource === null || eventSource === void 0 ? void 0 : eventSource.readyState) !== EventSource.OPEN;\n    }\n    get isConnecting() {\n        const eventSource = this.eventSource.current();\n        return (eventSource === null || eventSource === void 0 ? void 0 : eventSource.readyState) === EventSource.CONNECTING;\n    }\n    registerSession(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.eventSource.create(options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.openingDeadlineMS);\n        });\n    }\n    send(message, receiver, topic, ttlOrOptions) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: remove deprecated method\n            const options = {};\n            if (typeof ttlOrOptions === 'number') {\n                options.ttl = ttlOrOptions;\n            }\n            else {\n                options.ttl = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.ttl;\n                options.signal = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.signal;\n                options.attempts = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.attempts;\n            }\n            const url = new URL(addPathToUrl(this.bridgeUrl, this.postPath));\n            url.searchParams.append('client_id', this.sessionId);\n            url.searchParams.append('to', receiver);\n            url.searchParams.append('ttl', ((options === null || options === void 0 ? void 0 : options.ttl) || this.defaultTtl).toString());\n            url.searchParams.append('topic', topic);\n            const body = _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.Base64.encode(message);\n            yield callForSuccess((options) => __awaiter(this, void 0, void 0, function* () {\n                const response = yield this.post(url, body, options.signal);\n                if (!response.ok) {\n                    throw new TonConnectError(`Bridge send failed, status ${response.status}`);\n                }\n            }), {\n                attempts: (_a = options === null || options === void 0 ? void 0 : options.attempts) !== null && _a !== void 0 ? _a : Number.MAX_SAFE_INTEGER,\n                delayMs: this.defaultResendDelay,\n                signal: options === null || options === void 0 ? void 0 : options.signal\n            });\n        });\n    }\n    pause() {\n        this.eventSource.dispose().catch(e => logError(`Bridge pause failed, ${e}`));\n    }\n    unPause() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const RECREATE_WITHOUT_DELAY = 0;\n            yield this.eventSource.recreate(RECREATE_WITHOUT_DELAY);\n        });\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.eventSource.dispose().catch(e => logError(`Bridge close failed, ${e}`));\n        });\n    }\n    setListener(listener) {\n        this.listener = listener;\n    }\n    setErrorsListener(errorsListener) {\n        this.errorsListener = errorsListener;\n    }\n    post(url, body, signal) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(url, {\n                method: 'post',\n                body: body,\n                signal: signal\n            });\n            if (!response.ok) {\n                throw new TonConnectError(`Bridge send failed, status ${response.status}`);\n            }\n            return response;\n        });\n    }\n    errorsHandler(eventSource, e) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.isConnecting) {\n                eventSource.close();\n                throw new TonConnectError('Bridge error, failed to connect');\n            }\n            if (this.isReady) {\n                try {\n                    this.errorsListener(e);\n                }\n                catch (e) { }\n                return;\n            }\n            if (this.isClosed) {\n                eventSource.close();\n                logDebug(`Bridge reconnecting, ${this.defaultReconnectDelay}ms delay`);\n                return yield this.eventSource.recreate(this.defaultReconnectDelay);\n            }\n            throw new TonConnectError('Bridge error, unknown state');\n        });\n    }\n    messagesHandler(e) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (e.data === this.heartbeatMessage) {\n                return;\n            }\n            yield this.bridgeGatewayStorage.storeLastEventId(e.lastEventId);\n            if (this.isClosed) {\n                return;\n            }\n            let bridgeIncomingMessage;\n            try {\n                bridgeIncomingMessage = JSON.parse(e.data);\n            }\n            catch (_) {\n                throw new TonConnectError(`Bridge message parse failed, message ${e.data}`);\n            }\n            this.listener(bridgeIncomingMessage);\n        });\n    }\n}\n/**\n * Creates an event source.\n * @param {CreateEventSourceConfig} config - Configuration for creating an event source.\n */\nfunction createEventSource(config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield timeout((resolve, reject, deferOptions) => __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const abortController = createAbortController(deferOptions.signal);\n            const signal = abortController.signal;\n            if (signal.aborted) {\n                reject(new TonConnectError('Bridge connection aborted'));\n                return;\n            }\n            const url = new URL(addPathToUrl(config.bridgeUrl, config.ssePath));\n            url.searchParams.append('client_id', config.sessionId);\n            const lastEventId = yield config.bridgeGatewayStorage.getLastEventId();\n            if (lastEventId) {\n                url.searchParams.append('last_event_id', lastEventId);\n            }\n            if (signal.aborted) {\n                reject(new TonConnectError('Bridge connection aborted'));\n                return;\n            }\n            const eventSource = new EventSource(url.toString());\n            eventSource.onerror = (reason) => __awaiter(this, void 0, void 0, function* () {\n                if (signal.aborted) {\n                    eventSource.close();\n                    reject(new TonConnectError('Bridge connection aborted'));\n                    return;\n                }\n                try {\n                    const newInstance = yield config.errorHandler(eventSource, reason);\n                    if (newInstance !== eventSource) {\n                        eventSource.close();\n                    }\n                    if (newInstance && newInstance !== eventSource) {\n                        resolve(newInstance);\n                    }\n                }\n                catch (e) {\n                    eventSource.close();\n                    reject(e);\n                }\n            });\n            eventSource.onopen = () => {\n                if (signal.aborted) {\n                    eventSource.close();\n                    reject(new TonConnectError('Bridge connection aborted'));\n                    return;\n                }\n                resolve(eventSource);\n            };\n            eventSource.onmessage = (event) => {\n                if (signal.aborted) {\n                    eventSource.close();\n                    reject(new TonConnectError('Bridge connection aborted'));\n                    return;\n                }\n                config.messageHandler(event);\n            };\n            (_a = config.signal) === null || _a === void 0 ? void 0 : _a.addEventListener('abort', () => {\n                eventSource.close();\n                reject(new TonConnectError('Bridge connection aborted'));\n            });\n        }), { timeout: config.openingDeadlineMS, signal: config.signal });\n    });\n}\n\nconst CONNECTION_HTTP_EXPIRATION_TIME = 5 * 60 * 1000;\nfunction isPendingConnectionHttp(connection) {\n    return !('connectEvent' in connection);\n}\nfunction isPendingConnectionHttpRaw(connection) {\n    return !('connectEvent' in connection);\n}\nfunction isExpiredPendingConnectionHttpRaw(connection) {\n    var _a;\n    return Date.now() - ((_a = connection.createdAt) !== null && _a !== void 0 ? _a : 0) > CONNECTION_HTTP_EXPIRATION_TIME;\n}\n\nclass BridgeConnectionStorage {\n    constructor(storage) {\n        this.storage = storage;\n        this.storeKey = 'ton-connect-storage_bridge-connection';\n    }\n    storeConnection(connection) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (connection.type === 'injected') {\n                return this.storage.setItem(this.storeKey, JSON.stringify(connection));\n            }\n            if (!isPendingConnectionHttp(connection)) {\n                const rawSession = {\n                    sessionKeyPair: connection.session.sessionCrypto.stringifyKeypair(),\n                    walletPublicKey: connection.session.walletPublicKey,\n                    bridgeUrl: connection.session.bridgeUrl\n                };\n                const rawConnection = {\n                    type: 'http',\n                    connectEvent: connection.connectEvent,\n                    session: rawSession,\n                    lastWalletEventId: connection.lastWalletEventId,\n                    nextRpcRequestId: connection.nextRpcRequestId\n                };\n                return this.storage.setItem(this.storeKey, JSON.stringify(rawConnection));\n            }\n            const rawConnection = {\n                type: 'http',\n                connectionSource: connection.connectionSource,\n                sessionCrypto: connection.sessionCrypto.stringifyKeypair(),\n                createdAt: Date.now()\n            };\n            return this.storage.setItem(this.storeKey, JSON.stringify(rawConnection));\n        });\n    }\n    removeConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.storage.removeItem(this.storeKey);\n        });\n    }\n    getConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const stored = yield this.storage.getItem(this.storeKey);\n            if (!stored) {\n                return null;\n            }\n            const connection = JSON.parse(stored);\n            if (connection.type === 'injected') {\n                return connection;\n            }\n            if (!isPendingConnectionHttpRaw(connection)) {\n                const sessionCrypto = new _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto(connection.session.sessionKeyPair);\n                return {\n                    type: 'http',\n                    connectEvent: connection.connectEvent,\n                    lastWalletEventId: connection.lastWalletEventId,\n                    nextRpcRequestId: connection.nextRpcRequestId,\n                    session: {\n                        sessionCrypto,\n                        bridgeUrl: connection.session.bridgeUrl,\n                        walletPublicKey: connection.session.walletPublicKey\n                    }\n                };\n            }\n            if (isExpiredPendingConnectionHttpRaw(connection)) {\n                yield this.removeConnection();\n                return null;\n            }\n            return {\n                type: 'http',\n                sessionCrypto: new _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto(connection.sessionCrypto),\n                connectionSource: connection.connectionSource\n            };\n        });\n    }\n    getHttpConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (!connection) {\n                throw new TonConnectError('Trying to read HTTP connection source while nothing is stored');\n            }\n            if (connection.type === 'injected') {\n                throw new TonConnectError('Trying to read HTTP connection source while injected connection is stored');\n            }\n            return connection;\n        });\n    }\n    getHttpPendingConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (!connection) {\n                throw new TonConnectError('Trying to read HTTP connection source while nothing is stored');\n            }\n            if (connection.type === 'injected') {\n                throw new TonConnectError('Trying to read HTTP connection source while injected connection is stored');\n            }\n            if (!isPendingConnectionHttp(connection)) {\n                throw new TonConnectError('Trying to read HTTP-pending connection while http connection is stored');\n            }\n            return connection;\n        });\n    }\n    getInjectedConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (!connection) {\n                throw new TonConnectError('Trying to read Injected bridge connection source while nothing is stored');\n            }\n            if ((connection === null || connection === void 0 ? void 0 : connection.type) === 'http') {\n                throw new TonConnectError('Trying to read Injected bridge connection source while HTTP connection is stored');\n            }\n            return connection;\n        });\n    }\n    storedConnectionType() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const stored = yield this.storage.getItem(this.storeKey);\n            if (!stored) {\n                return null;\n            }\n            const connection = JSON.parse(stored);\n            return connection.type;\n        });\n    }\n    storeLastWalletEventId(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (connection && connection.type === 'http' && !isPendingConnectionHttp(connection)) {\n                connection.lastWalletEventId = id;\n                return this.storeConnection(connection);\n            }\n        });\n    }\n    getLastWalletEventId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (connection && 'lastWalletEventId' in connection) {\n                return connection.lastWalletEventId;\n            }\n            return undefined;\n        });\n    }\n    increaseNextRpcRequestId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (connection && 'nextRpcRequestId' in connection) {\n                const lastId = connection.nextRpcRequestId || 0;\n                connection.nextRpcRequestId = lastId + 1;\n                return this.storeConnection(connection);\n            }\n        });\n    }\n    getNextRpcRequestId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (connection && 'nextRpcRequestId' in connection) {\n                return connection.nextRpcRequestId || 0;\n            }\n            return 0;\n        });\n    }\n}\n\nconst PROTOCOL_VERSION = 2;\n\nclass BridgeProvider {\n    constructor(storage, walletConnectionSource) {\n        this.storage = storage;\n        this.walletConnectionSource = walletConnectionSource;\n        this.type = 'http';\n        this.standardUniversalLink = 'tc://';\n        this.pendingRequests = new Map();\n        this.session = null;\n        this.gateway = null;\n        this.pendingGateways = [];\n        this.listeners = [];\n        this.defaultOpeningDeadlineMS = 12000;\n        this.defaultRetryTimeoutMS = 2000;\n        this.connectionStorage = new BridgeConnectionStorage(storage);\n    }\n    static fromStorage(storage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const bridgeConnectionStorage = new BridgeConnectionStorage(storage);\n            const connection = yield bridgeConnectionStorage.getHttpConnection();\n            if (isPendingConnectionHttp(connection)) {\n                return new BridgeProvider(storage, connection.connectionSource);\n            }\n            return new BridgeProvider(storage, { bridgeUrl: connection.session.bridgeUrl });\n        });\n    }\n    connect(message, options) {\n        var _a;\n        const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n        (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n        this.abortController = abortController;\n        this.closeGateways();\n        const sessionCrypto = new _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto();\n        this.session = {\n            sessionCrypto,\n            bridgeUrl: 'bridgeUrl' in this.walletConnectionSource\n                ? this.walletConnectionSource.bridgeUrl\n                : ''\n        };\n        this.connectionStorage\n            .storeConnection({\n            type: 'http',\n            connectionSource: this.walletConnectionSource,\n            sessionCrypto\n        })\n            .then(() => __awaiter(this, void 0, void 0, function* () {\n            if (abortController.signal.aborted) {\n                return;\n            }\n            yield callForSuccess(_options => {\n                var _a;\n                return this.openGateways(sessionCrypto, {\n                    openingDeadlineMS: (_a = options === null || options === void 0 ? void 0 : options.openingDeadlineMS) !== null && _a !== void 0 ? _a : this.defaultOpeningDeadlineMS,\n                    signal: _options === null || _options === void 0 ? void 0 : _options.signal\n                });\n            }, {\n                attempts: Number.MAX_SAFE_INTEGER,\n                delayMs: this.defaultRetryTimeoutMS,\n                signal: abortController.signal\n            });\n        }));\n        const universalLink = 'universalLink' in this.walletConnectionSource &&\n            this.walletConnectionSource.universalLink\n            ? this.walletConnectionSource.universalLink\n            : this.standardUniversalLink;\n        return this.generateUniversalLink(universalLink, message);\n    }\n    restoreConnection(options) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n            this.abortController = abortController;\n            if (abortController.signal.aborted) {\n                return;\n            }\n            this.closeGateways();\n            const storedConnection = yield this.connectionStorage.getHttpConnection();\n            if (!storedConnection) {\n                return;\n            }\n            if (abortController.signal.aborted) {\n                return;\n            }\n            const openingDeadlineMS = (_b = options === null || options === void 0 ? void 0 : options.openingDeadlineMS) !== null && _b !== void 0 ? _b : this.defaultOpeningDeadlineMS;\n            if (isPendingConnectionHttp(storedConnection)) {\n                this.session = {\n                    sessionCrypto: storedConnection.sessionCrypto,\n                    bridgeUrl: 'bridgeUrl' in this.walletConnectionSource\n                        ? this.walletConnectionSource.bridgeUrl\n                        : ''\n                };\n                return yield this.openGateways(storedConnection.sessionCrypto, {\n                    openingDeadlineMS: openingDeadlineMS,\n                    signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal\n                });\n            }\n            if (Array.isArray(this.walletConnectionSource)) {\n                throw new TonConnectError('Internal error. Connection source is array while WalletConnectionSourceHTTP was expected.');\n            }\n            this.session = storedConnection.session;\n            if (this.gateway) {\n                logDebug('Gateway is already opened, closing previous gateway');\n                yield this.gateway.close();\n            }\n            this.gateway = new BridgeGateway(this.storage, this.walletConnectionSource.bridgeUrl, storedConnection.session.sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this));\n            if (abortController.signal.aborted) {\n                return;\n            }\n            // notify listeners about stored connection\n            this.listeners.forEach(listener => listener(storedConnection.connectEvent));\n            // wait for the connection to be opened\n            try {\n                yield callForSuccess(options => this.gateway.registerSession({\n                    openingDeadlineMS: openingDeadlineMS,\n                    signal: options.signal\n                }), {\n                    attempts: Number.MAX_SAFE_INTEGER,\n                    delayMs: this.defaultRetryTimeoutMS,\n                    signal: abortController.signal\n                });\n            }\n            catch (e) {\n                yield this.disconnect({ signal: abortController.signal });\n                return;\n            }\n        });\n    }\n    sendRequest(request, optionsOrOnRequestSent) {\n        // TODO: remove deprecated method\n        const options = {};\n        if (typeof optionsOrOnRequestSent === 'function') {\n            options.onRequestSent = optionsOrOnRequestSent;\n        }\n        else {\n            options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;\n            options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;\n            options.attempts = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.attempts;\n        }\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            if (!this.gateway || !this.session || !('walletPublicKey' in this.session)) {\n                throw new TonConnectError('Trying to send bridge request without session');\n            }\n            const id = (yield this.connectionStorage.getNextRpcRequestId()).toString();\n            yield this.connectionStorage.increaseNextRpcRequestId();\n            logDebug('Send http-bridge request:', Object.assign(Object.assign({}, request), { id }));\n            const encodedRequest = this.session.sessionCrypto.encrypt(JSON.stringify(Object.assign(Object.assign({}, request), { id })), (0,_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.hexToByteArray)(this.session.walletPublicKey));\n            try {\n                yield this.gateway.send(encodedRequest, this.session.walletPublicKey, request.method, { attempts: options === null || options === void 0 ? void 0 : options.attempts, signal: options === null || options === void 0 ? void 0 : options.signal });\n                (_a = options === null || options === void 0 ? void 0 : options.onRequestSent) === null || _a === void 0 ? void 0 : _a.call(options);\n                this.pendingRequests.set(id.toString(), resolve);\n            }\n            catch (e) {\n                reject(e);\n            }\n        }));\n    }\n    closeConnection() {\n        this.closeGateways();\n        this.listeners = [];\n        this.session = null;\n        this.gateway = null;\n    }\n    disconnect(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                let called = false;\n                let timeoutId = null;\n                const onRequestSent = () => {\n                    if (!called) {\n                        called = true;\n                        this.removeBridgeAndSession().then(resolve);\n                    }\n                };\n                try {\n                    this.closeGateways();\n                    const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n                    timeoutId = setTimeout(() => {\n                        abortController.abort();\n                    }, this.defaultOpeningDeadlineMS);\n                    yield this.sendRequest({ method: 'disconnect', params: [] }, {\n                        onRequestSent: onRequestSent,\n                        signal: abortController.signal,\n                        attempts: 1\n                    });\n                }\n                catch (e) {\n                    logDebug('Disconnect error:', e);\n                    if (!called) {\n                        this.removeBridgeAndSession().then(resolve);\n                    }\n                }\n                finally {\n                    if (timeoutId) {\n                        clearTimeout(timeoutId);\n                    }\n                    onRequestSent();\n                }\n            }));\n        });\n    }\n    listen(callback) {\n        this.listeners.push(callback);\n        return () => (this.listeners = this.listeners.filter(listener => listener !== callback));\n    }\n    pause() {\n        var _a;\n        (_a = this.gateway) === null || _a === void 0 ? void 0 : _a.pause();\n        this.pendingGateways.forEach(bridge => bridge.pause());\n    }\n    unPause() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const promises = this.pendingGateways.map(bridge => bridge.unPause());\n            if (this.gateway) {\n                promises.push(this.gateway.unPause());\n            }\n            yield Promise.all(promises);\n        });\n    }\n    pendingGatewaysListener(gateway, bridgeUrl, bridgeIncomingMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.pendingGateways.includes(gateway)) {\n                yield gateway.close();\n                return;\n            }\n            this.closeGateways({ except: gateway });\n            if (this.gateway) {\n                logDebug('Gateway is already opened, closing previous gateway');\n                yield this.gateway.close();\n            }\n            this.session.bridgeUrl = bridgeUrl;\n            this.gateway = gateway;\n            this.gateway.setErrorsListener(this.gatewayErrorsListener.bind(this));\n            this.gateway.setListener(this.gatewayListener.bind(this));\n            return this.gatewayListener(bridgeIncomingMessage);\n        });\n    }\n    gatewayListener(bridgeIncomingMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const walletMessage = JSON.parse(this.session.sessionCrypto.decrypt(_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.Base64.decode(bridgeIncomingMessage.message).toUint8Array(), (0,_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.hexToByteArray)(bridgeIncomingMessage.from)));\n            logDebug('Wallet message received:', walletMessage);\n            if (!('event' in walletMessage)) {\n                const id = walletMessage.id.toString();\n                const resolve = this.pendingRequests.get(id);\n                if (!resolve) {\n                    logDebug(`Response id ${id} doesn't match any request's id`);\n                    return;\n                }\n                resolve(walletMessage);\n                this.pendingRequests.delete(id);\n                return;\n            }\n            if (walletMessage.id !== undefined) {\n                const lastId = yield this.connectionStorage.getLastWalletEventId();\n                if (lastId !== undefined && walletMessage.id <= lastId) {\n                    logError(`Received event id (=${walletMessage.id}) must be greater than stored last wallet event id (=${lastId}) `);\n                    return;\n                }\n                if (walletMessage.event !== 'connect') {\n                    yield this.connectionStorage.storeLastWalletEventId(walletMessage.id);\n                }\n            }\n            // `this.listeners` might be modified in the event handler\n            const listeners = this.listeners;\n            if (walletMessage.event === 'connect') {\n                yield this.updateSession(walletMessage, bridgeIncomingMessage.from);\n            }\n            if (walletMessage.event === 'disconnect') {\n                logDebug(`Removing bridge and session: received disconnect event`);\n                yield this.removeBridgeAndSession();\n            }\n            listeners.forEach(listener => listener(walletMessage));\n        });\n    }\n    gatewayErrorsListener(e) {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new TonConnectError(`Bridge error ${JSON.stringify(e)}`);\n        });\n    }\n    updateSession(connectEvent, walletPublicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.session = Object.assign(Object.assign({}, this.session), { walletPublicKey });\n            const tonAddrItem = connectEvent.payload.items.find(item => item.name === 'ton_addr');\n            const connectEventToSave = Object.assign(Object.assign({}, connectEvent), { payload: Object.assign(Object.assign({}, connectEvent.payload), { items: [tonAddrItem] }) });\n            yield this.connectionStorage.storeConnection({\n                type: 'http',\n                session: this.session,\n                lastWalletEventId: connectEvent.id,\n                connectEvent: connectEventToSave,\n                nextRpcRequestId: 0\n            });\n        });\n    }\n    removeBridgeAndSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.closeConnection();\n            yield this.connectionStorage.removeConnection();\n        });\n    }\n    generateUniversalLink(universalLink, message) {\n        if (isTelegramUrl(universalLink)) {\n            return this.generateTGUniversalLink(universalLink, message);\n        }\n        return this.generateRegularUniversalLink(universalLink, message);\n    }\n    generateRegularUniversalLink(universalLink, message) {\n        const url = new URL(universalLink);\n        url.searchParams.append('v', PROTOCOL_VERSION.toString());\n        url.searchParams.append('id', this.session.sessionCrypto.sessionId);\n        url.searchParams.append('r', JSON.stringify(message));\n        return url.toString();\n    }\n    generateTGUniversalLink(universalLink, message) {\n        const urlToWrap = this.generateRegularUniversalLink('about:blank', message);\n        const linkParams = urlToWrap.split('?')[1];\n        const startapp = 'tonconnect-' + encodeTelegramUrlParameters(linkParams);\n        // TODO: Remove this line after all dApps and the wallets-list.json have been updated\n        const updatedUniversalLink = this.convertToDirectLink(universalLink);\n        const url = new URL(updatedUniversalLink);\n        url.searchParams.append('startapp', startapp);\n        return url.toString();\n    }\n    // TODO: Remove this method after all dApps and the wallets-list.json have been updated\n    convertToDirectLink(universalLink) {\n        const url = new URL(universalLink);\n        if (url.searchParams.has('attach')) {\n            url.searchParams.delete('attach');\n            url.pathname += '/start';\n        }\n        return url.toString();\n    }\n    openGateways(sessionCrypto, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (Array.isArray(this.walletConnectionSource)) {\n                // close all gateways before opening new ones\n                this.pendingGateways.map(bridge => bridge.close().catch());\n                // open new gateways\n                this.pendingGateways = this.walletConnectionSource.map(source => {\n                    const gateway = new BridgeGateway(this.storage, source.bridgeUrl, sessionCrypto.sessionId, () => { }, () => { });\n                    gateway.setListener(message => this.pendingGatewaysListener(gateway, source.bridgeUrl, message));\n                    return gateway;\n                });\n                yield Promise.allSettled(this.pendingGateways.map(bridge => callForSuccess((_options) => {\n                    var _a;\n                    if (!this.pendingGateways.some(item => item === bridge)) {\n                        return bridge.close();\n                    }\n                    return bridge.registerSession({\n                        openingDeadlineMS: (_a = options === null || options === void 0 ? void 0 : options.openingDeadlineMS) !== null && _a !== void 0 ? _a : this.defaultOpeningDeadlineMS,\n                        signal: _options.signal\n                    });\n                }, {\n                    attempts: Number.MAX_SAFE_INTEGER,\n                    delayMs: this.defaultRetryTimeoutMS,\n                    signal: options === null || options === void 0 ? void 0 : options.signal\n                })));\n                return;\n            }\n            else {\n                if (this.gateway) {\n                    logDebug(`Gateway is already opened, closing previous gateway`);\n                    yield this.gateway.close();\n                }\n                this.gateway = new BridgeGateway(this.storage, this.walletConnectionSource.bridgeUrl, sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this));\n                return yield this.gateway.registerSession({\n                    openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n                    signal: options === null || options === void 0 ? void 0 : options.signal\n                });\n            }\n        });\n    }\n    closeGateways(options) {\n        var _a;\n        (_a = this.gateway) === null || _a === void 0 ? void 0 : _a.close();\n        this.pendingGateways\n            .filter(item => item !== (options === null || options === void 0 ? void 0 : options.except))\n            .forEach(bridge => bridge.close());\n        this.pendingGateways = [];\n    }\n}\n\nfunction hasProperty(value, propertyKey) {\n    return hasProperties(value, [propertyKey]);\n}\nfunction hasProperties(value, propertyKeys) {\n    if (!value || typeof value !== 'object') {\n        return false;\n    }\n    return propertyKeys.every(propertyKey => propertyKey in value);\n}\n\nfunction isJSBridgeWithMetadata(value) {\n    try {\n        if (!hasProperty(value, 'tonconnect') || !hasProperty(value.tonconnect, 'walletInfo')) {\n            return false;\n        }\n        return hasProperties(value.tonconnect.walletInfo, [\n            'name',\n            'app_name',\n            'image',\n            'about_url',\n            'platforms'\n        ]);\n    }\n    catch (_a) {\n        return false;\n    }\n}\n\n/**\n * In memory storage like localStorage, but without persistence.\n * Uses as a fallback for localStorage in Safari's private mode.\n */\nclass InMemoryStorage {\n    constructor() {\n        this.storage = {};\n    }\n    static getInstance() {\n        if (!InMemoryStorage.instance) {\n            InMemoryStorage.instance = new InMemoryStorage();\n        }\n        return InMemoryStorage.instance;\n    }\n    get length() {\n        return Object.keys(this.storage).length;\n    }\n    clear() {\n        this.storage = {};\n    }\n    getItem(key) {\n        var _a;\n        return (_a = this.storage[key]) !== null && _a !== void 0 ? _a : null;\n    }\n    key(index) {\n        var _a;\n        const keys = Object.keys(this.storage);\n        if (index < 0 || index >= keys.length) {\n            return null;\n        }\n        return (_a = keys[index]) !== null && _a !== void 0 ? _a : null;\n    }\n    removeItem(key) {\n        delete this.storage[key];\n    }\n    setItem(key, value) {\n        this.storage[key] = value;\n    }\n}\n\nfunction getWindow() {\n    if (typeof window === 'undefined') {\n        return undefined;\n    }\n    return window;\n}\n/**\n * The function try to get window keys, if it is not available it returns empty array.\n * As an example, for Safari's private mode it returns empty array, because the browser does not allow to get window keys.\n */\nfunction tryGetWindowKeys() {\n    const window = getWindow();\n    if (!window) {\n        return [];\n    }\n    try {\n        return Object.keys(window);\n    }\n    catch (_a) {\n        return [];\n    }\n}\nfunction getDocument() {\n    if (typeof document === 'undefined') {\n        return undefined;\n    }\n    return document;\n}\nfunction getWebPageManifest() {\n    var _a;\n    const origin = (_a = getWindow()) === null || _a === void 0 ? void 0 : _a.location.origin;\n    if (origin) {\n        return origin + '/tonconnect-manifest.json';\n    }\n    return '';\n}\n/**\n * Returns `localStorage` if it is available. In Safari's private mode, it returns `InMemoryStorage`. In Node.js, it throws an error.\n */\nfunction tryGetLocalStorage() {\n    if (isLocalStorageAvailable()) {\n        return localStorage;\n    }\n    if (isNodeJs()) {\n        throw new TonConnectError('`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector');\n    }\n    return InMemoryStorage.getInstance();\n}\n/**\n * Checks if `localStorage` is available.\n */\nfunction isLocalStorageAvailable() {\n    // We use a try/catch block because Safari's private mode throws an error when attempting to access localStorage.\n    try {\n        return typeof localStorage !== 'undefined';\n    }\n    catch (_a) {\n        return false;\n    }\n}\n/**\n * Checks if the environment is Node.js.\n */\nfunction isNodeJs() {\n    return (typeof process !== 'undefined' && process.versions != null && process.versions.node != null);\n}\n\nclass InjectedProvider {\n    constructor(storage, injectedWalletKey) {\n        this.injectedWalletKey = injectedWalletKey;\n        this.type = 'injected';\n        this.unsubscribeCallback = null;\n        this.listenSubscriptions = false;\n        this.listeners = [];\n        const window = InjectedProvider.window;\n        if (!InjectedProvider.isWindowContainsWallet(window, injectedWalletKey)) {\n            throw new WalletNotInjectedError();\n        }\n        this.connectionStorage = new BridgeConnectionStorage(storage);\n        this.injectedWallet = window[injectedWalletKey].tonconnect;\n    }\n    static fromStorage(storage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const bridgeConnectionStorage = new BridgeConnectionStorage(storage);\n            const connection = yield bridgeConnectionStorage.getInjectedConnection();\n            return new InjectedProvider(storage, connection.jsBridgeKey);\n        });\n    }\n    static isWalletInjected(injectedWalletKey) {\n        return InjectedProvider.isWindowContainsWallet(this.window, injectedWalletKey);\n    }\n    static isInsideWalletBrowser(injectedWalletKey) {\n        if (InjectedProvider.isWindowContainsWallet(this.window, injectedWalletKey)) {\n            return this.window[injectedWalletKey].tonconnect.isWalletBrowser;\n        }\n        return false;\n    }\n    static getCurrentlyInjectedWallets() {\n        if (!this.window) {\n            return [];\n        }\n        const windowKeys = tryGetWindowKeys();\n        const wallets = windowKeys.filter(([_, value]) => isJSBridgeWithMetadata(value));\n        return wallets.map(([jsBridgeKey, wallet]) => ({\n            name: wallet.tonconnect.walletInfo.name,\n            appName: wallet.tonconnect.walletInfo.app_name,\n            aboutUrl: wallet.tonconnect.walletInfo.about_url,\n            imageUrl: wallet.tonconnect.walletInfo.image,\n            tondns: wallet.tonconnect.walletInfo.tondns,\n            jsBridgeKey,\n            injected: true,\n            embedded: wallet.tonconnect.isWalletBrowser,\n            platforms: wallet.tonconnect.walletInfo.platforms,\n            features: wallet.tonconnect.walletInfo.features\n        }));\n    }\n    static isWindowContainsWallet(window, injectedWalletKey) {\n        return (!!window &&\n            injectedWalletKey in window &&\n            typeof window[injectedWalletKey] === 'object' &&\n            'tonconnect' in window[injectedWalletKey]);\n    }\n    connect(message) {\n        this._connect(PROTOCOL_VERSION, message);\n    }\n    restoreConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                logDebug(`Injected Provider restoring connection...`);\n                const connectEvent = yield this.injectedWallet.restoreConnection();\n                logDebug('Injected Provider restoring connection response', connectEvent);\n                if (connectEvent.event === 'connect') {\n                    this.makeSubscriptions();\n                    this.listeners.forEach(listener => listener(connectEvent));\n                }\n                else {\n                    yield this.connectionStorage.removeConnection();\n                }\n            }\n            catch (e) {\n                yield this.connectionStorage.removeConnection();\n                console.error(e);\n            }\n        });\n    }\n    closeConnection() {\n        if (this.listenSubscriptions) {\n            this.injectedWallet.disconnect();\n        }\n        this.closeAllListeners();\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise(resolve => {\n                const onRequestSent = () => {\n                    this.closeAllListeners();\n                    this.connectionStorage.removeConnection().then(resolve);\n                };\n                try {\n                    this.injectedWallet.disconnect();\n                    onRequestSent();\n                }\n                catch (e) {\n                    logDebug(e);\n                    this.sendRequest({\n                        method: 'disconnect',\n                        params: []\n                    }, onRequestSent);\n                }\n            });\n        });\n    }\n    closeAllListeners() {\n        var _a;\n        this.listenSubscriptions = false;\n        this.listeners = [];\n        (_a = this.unsubscribeCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    listen(eventsCallback) {\n        this.listeners.push(eventsCallback);\n        return () => (this.listeners = this.listeners.filter(listener => listener !== eventsCallback));\n    }\n    sendRequest(request, optionsOrOnRequestSent) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: remove deprecated method\n            const options = {};\n            if (typeof optionsOrOnRequestSent === 'function') {\n                options.onRequestSent = optionsOrOnRequestSent;\n            }\n            else {\n                options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;\n                options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;\n            }\n            const id = (yield this.connectionStorage.getNextRpcRequestId()).toString();\n            yield this.connectionStorage.increaseNextRpcRequestId();\n            logDebug('Send injected-bridge request:', Object.assign(Object.assign({}, request), { id }));\n            const result = this.injectedWallet.send(Object.assign(Object.assign({}, request), { id }));\n            result.then(response => logDebug('Wallet message received:', response));\n            (_a = options === null || options === void 0 ? void 0 : options.onRequestSent) === null || _a === void 0 ? void 0 : _a.call(options);\n            return result;\n        });\n    }\n    _connect(protocolVersion, message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                logDebug(`Injected Provider connect request: protocolVersion: ${protocolVersion}, message:`, message);\n                const connectEvent = yield this.injectedWallet.connect(protocolVersion, message);\n                logDebug('Injected Provider connect response:', connectEvent);\n                if (connectEvent.event === 'connect') {\n                    yield this.updateSession();\n                    this.makeSubscriptions();\n                }\n                this.listeners.forEach(listener => listener(connectEvent));\n            }\n            catch (e) {\n                logDebug('Injected Provider connect error:', e);\n                const connectEventError = {\n                    event: 'connect_error',\n                    payload: {\n                        code: 0,\n                        message: e === null || e === void 0 ? void 0 : e.toString()\n                    }\n                };\n                this.listeners.forEach(listener => listener(connectEventError));\n            }\n        });\n    }\n    makeSubscriptions() {\n        this.listenSubscriptions = true;\n        this.unsubscribeCallback = this.injectedWallet.listen(e => {\n            logDebug('Wallet message received:', e);\n            if (this.listenSubscriptions) {\n                this.listeners.forEach(listener => listener(e));\n            }\n            if (e.event === 'disconnect') {\n                this.disconnect();\n            }\n        });\n    }\n    updateSession() {\n        return this.connectionStorage.storeConnection({\n            type: 'injected',\n            jsBridgeKey: this.injectedWalletKey,\n            nextRpcRequestId: 0\n        });\n    }\n}\nInjectedProvider.window = getWindow();\n\n/**\n * Default storage to save protocol data, uses `localStorage` if it is available. In Safari's private mode, it uses `InMemoryStorage`. In Node.js, it throws an error.\n */\nclass DefaultStorage {\n    constructor() {\n        this.localStorage = tryGetLocalStorage();\n    }\n    getItem(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.localStorage.getItem(key);\n        });\n    }\n    removeItem(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.localStorage.removeItem(key);\n        });\n    }\n    setItem(key, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.localStorage.setItem(key, value);\n        });\n    }\n}\n\n/**\n * Checks if `WalletInfo` is `WalletInfoInjectable` and `WalletInfo` is injected to the current webpage (`walletInfo.injected === true`).\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoCurrentlyInjected(value) {\n    return isWalletInfoInjectable(value) && value.injected;\n}\n/**\n * Checks if `WalletInfo` is `WalletInfoInjectable` and dApp is opened inside this wallet's browser.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoCurrentlyEmbedded(value) {\n    return isWalletInfoCurrentlyInjected(value) && value.embedded;\n}\n/**\n * Checks if `WalletInfo` is `WalletInfoInjected`, but doesn't check if it is injected to the page or not.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoInjectable(value) {\n    return 'jsBridgeKey' in value;\n}\n/**\n * Checks if `WalletInfo` is `WalletInfoRemote`.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoRemote(value) {\n    return 'bridgeUrl' in value;\n}\n/**\n * @deprecated use `isWalletInfoInjectable` or `isWalletInfoCurrentlyInjected` instead.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoInjected(value) {\n    return 'jsBridgeKey' in value;\n}\n\nconst FALLBACK_WALLETS_LIST = [\n    {\n        app_name: 'telegram-wallet',\n        name: 'Wallet',\n        image: 'https://wallet.tg/images/logo-288.png',\n        about_url: 'https://wallet.tg/',\n        universal_url: 'https://t.me/wallet?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://walletbot.me/tonconnect-bridge/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux']\n    },\n    {\n        app_name: 'tonkeeper',\n        name: 'Tonkeeper',\n        image: 'https://tonkeeper.com/assets/tonconnect-icon.png',\n        tondns: 'tonkeeper.ton',\n        about_url: 'https://tonkeeper.com',\n        universal_url: 'https://app.tonkeeper.com/ton-connect',\n        deepLink: 'tonkeeper-tc://',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://bridge.tonapi.io/bridge'\n            },\n            {\n                type: 'js',\n                key: 'tonkeeper'\n            }\n        ],\n        platforms: ['ios', 'android', 'chrome', 'firefox', 'macos']\n    },\n    {\n        app_name: 'mytonwallet',\n        name: 'MyTonWallet',\n        image: 'https://static.mytonwallet.io/icon-256.png',\n        about_url: 'https://mytonwallet.io',\n        universal_url: 'https://connect.mytonwallet.org',\n        bridge: [\n            {\n                type: 'js',\n                key: 'mytonwallet'\n            },\n            {\n                type: 'sse',\n                url: 'https://tonconnectbridge.mytonwallet.org/bridge/'\n            }\n        ],\n        platforms: ['chrome', 'windows', 'macos', 'linux', 'ios', 'android', 'firefox']\n    },\n    {\n        app_name: 'tonhub',\n        name: 'Tonhub',\n        image: 'https://tonhub.com/tonconnect_logo.png',\n        about_url: 'https://tonhub.com',\n        universal_url: 'https://tonhub.com/ton-connect',\n        bridge: [\n            {\n                type: 'js',\n                key: 'tonhub'\n            },\n            {\n                type: 'sse',\n                url: 'https://connect.tonhubapi.com/tonconnect'\n            }\n        ],\n        platforms: ['ios', 'android']\n    },\n    {\n        app_name: 'bitgetTonWallet',\n        name: 'Bitget Wallet',\n        image: 'https://raw.githubusercontent.com/bitgetwallet/download/refs/heads/main/logo/png/bitget_wallet_logo_288_mini.png',\n        about_url: 'https://web3.bitget.com',\n        deepLink: 'bitkeep://',\n        bridge: [\n            {\n                type: 'js',\n                key: 'bitgetTonWallet'\n            },\n            {\n                type: 'sse',\n                url: 'https://ton-connect-bridge.bgwapi.io/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'chrome'],\n        universal_url: 'https://bkcode.vip/ton-connect'\n    },\n    {\n        app_name: 'okxMiniWallet',\n        name: 'OKX Mini Wallet',\n        image: 'https://static.okx.com/cdn/assets/imgs/2411/8BE1A4A434D8F58A.png',\n        about_url: 'https://www.okx.com/web3',\n        universal_url: 'https://t.me/OKX_WALLET_BOT?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://www.okx.com/tonbridge/discover/rpc/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux']\n    },\n    {\n        app_name: 'binanceWeb3TonWallet',\n        name: 'Binance Web3 Wallet',\n        image: 'https://public.bnbstatic.com/static/binance-w3w/ton-provider/binancew3w.png',\n        about_url: 'https://www.binance.com/en/web3wallet',\n        deepLink: 'bnc://app.binance.com/cedefi/ton-connect',\n        bridge: [\n            {\n                type: 'js',\n                key: 'binancew3w'\n            },\n            {\n                type: 'sse',\n                url: 'https://wallet.binance.com/tonbridge/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux'],\n        universal_url: 'https://app.binance.com/cedefi/ton-connect'\n    },\n    {\n        app_name: 'fintopio-tg',\n        name: 'Fintopio',\n        image: 'https://fintopio.com/tonconnect-icon.png',\n        about_url: 'https://fintopio.com',\n        universal_url: 'https://t.me/fintopio?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://wallet-bridge.fintopio.com/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux']\n    },\n    {\n        app_name: 'okxTonWallet',\n        name: 'OKX Wallet',\n        image: 'https://static.okx.com/cdn/assets/imgs/247/58E63FEA47A2B7D7.png',\n        about_url: 'https://www.okx.com/web3',\n        universal_url: 'https://www.okx.com/download?appendQuery=true&deeplink=okx://web3/wallet/tonconnect',\n        bridge: [\n            {\n                type: 'js',\n                key: 'okxTonWallet'\n            },\n            {\n                type: 'sse',\n                url: 'https://www.okx.com/tonbridge/discover/rpc/bridge'\n            }\n        ],\n        platforms: ['chrome', 'safari', 'firefox', 'ios', 'android']\n    },\n    {\n        app_name: 'hot',\n        name: 'HOT',\n        image: 'https://raw.githubusercontent.com/hot-dao/media/main/logo.png',\n        about_url: 'https://hot-labs.org/',\n        universal_url: 'https://t.me/herewalletbot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://sse-bridge.hot-labs.org'\n            },\n            {\n                type: 'js',\n                key: 'hotWallet'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux']\n    },\n    {\n        app_name: 'bybitTonWallet',\n        name: 'Bybit Wallet',\n        image: 'https://raw.githubusercontent.com/bybit-web3/bybit-web3.github.io/main/docs/images/bybit-logo.png',\n        about_url: 'https://www.bybit.com/web3',\n        universal_url: 'https://app.bybit.com/ton-connect',\n        deepLink: 'bybitapp://',\n        bridge: [\n            {\n                type: 'js',\n                key: 'bybitTonWallet'\n            },\n            {\n                type: 'sse',\n                url: 'https://api-node.bybit.com/spot/api/web3/bridge/ton/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'chrome']\n    },\n    {\n        app_name: 'dewallet',\n        name: 'DeWallet',\n        image: 'https://raw.githubusercontent.com/delab-team/manifests-images/main/WalletAvatar.png',\n        about_url: 'https://delabwallet.com',\n        universal_url: 'https://t.me/dewallet?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://bridge.dewallet.pro/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux']\n    },\n    {\n        app_name: 'safepalwallet',\n        name: 'SafePal',\n        image: 'https://s.pvcliping.com/web/public_image/SafePal_x288.png',\n        tondns: '',\n        about_url: 'https://www.safepal.com',\n        universal_url: 'https://link.safepal.io/ton-connect',\n        deepLink: 'safepal-tc://',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://ton-bridge.safepal.com/tonbridge/v1/bridge'\n            },\n            {\n                type: 'js',\n                key: 'safepalwallet'\n            }\n        ],\n        platforms: ['ios', 'android', 'chrome', 'firefox']\n    },\n    {\n        app_name: 'GateWallet',\n        name: 'GateWallet',\n        image: 'https://img.gatedataimg.com/prd-ordinal-imgs/036f07bb8730716e/gateio-0925.png',\n        about_url: 'https://www.gate.io/',\n        bridge: [\n            {\n                type: 'js',\n                key: 'gatetonwallet'\n            },\n            {\n                type: 'sse',\n                url: 'https://dapp.gateio.services/tonbridge_api/bridge/v1'\n            }\n        ],\n        platforms: ['ios', 'android'],\n        universal_url: 'https://gateio.go.link/gateio/web3?adj_t=1ff8khdw_1fu4ccc7'\n    },\n    {\n        app_name: 'openmask',\n        name: 'OpenMask',\n        image: 'https://raw.githubusercontent.com/OpenProduct/openmask-extension/main/public/openmask-logo-288.png',\n        about_url: 'https://www.openmask.app/',\n        bridge: [\n            {\n                type: 'js',\n                key: 'openmask'\n            }\n        ],\n        platforms: ['chrome']\n    },\n    {\n        app_name: 'BitgetWeb3',\n        name: 'BitgetWeb3',\n        image: 'https://img.bitgetimg.com/image/third/1731638059795.png',\n        about_url: '​https://www.bitget.com',\n        universal_url: 'https://t.me/BitgetOfficialBot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://ton-connect-bridge.bgwapi.io/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'windows', 'macos', 'linux']\n    },\n    {\n        app_name: 'tobi',\n        name: 'Tobi',\n        image: 'https://app.tobiwallet.app/icons/logo-288.png',\n        about_url: 'https://tobi.fun',\n        universal_url: 'https://t.me/TobiCopilotBot?attach=wallet',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://ton-bridge.tobiwallet.app/bridge'\n            }\n        ],\n        platforms: ['ios', 'android', 'macos', 'windows', 'linux']\n    },\n    {\n        app_name: 'xtonwallet',\n        name: 'XTONWallet',\n        image: 'https://xtonwallet.com/assets/img/icon-256-back.png',\n        about_url: 'https://xtonwallet.com',\n        bridge: [\n            {\n                type: 'js',\n                key: 'xtonwallet'\n            }\n        ],\n        platforms: ['chrome', 'firefox']\n    },\n    {\n        app_name: 'tonwallet',\n        name: 'TON Wallet',\n        image: 'https://wallet.ton.org/assets/ui/qr-logo.png',\n        about_url: 'https://chrome.google.com/webstore/detail/ton-wallet/nphplpgoakhhjchkkhmiggakijnkhfnd',\n        bridge: [\n            {\n                type: 'js',\n                key: 'tonwallet'\n            }\n        ],\n        platforms: ['chrome']\n    }\n];\n\nclass WalletsListManager {\n    constructor(options) {\n        var _a;\n        this.walletsListCache = null;\n        this.walletsListCacheCreationTimestamp = null;\n        this.walletsListSource =\n            (_a = options === null || options === void 0 ? void 0 : options.walletsListSource) !== null && _a !== void 0 ? _a : 'https://raw.githubusercontent.com/ton-blockchain/wallets-list/main/wallets-v2.json';\n        this.cacheTTLMs = options === null || options === void 0 ? void 0 : options.cacheTTLMs;\n    }\n    getWallets() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.cacheTTLMs &&\n                this.walletsListCacheCreationTimestamp &&\n                Date.now() > this.walletsListCacheCreationTimestamp + this.cacheTTLMs) {\n                this.walletsListCache = null;\n            }\n            if (!this.walletsListCache) {\n                this.walletsListCache = this.fetchWalletsList();\n                this.walletsListCache\n                    .then(() => {\n                    this.walletsListCacheCreationTimestamp = Date.now();\n                })\n                    .catch(() => {\n                    this.walletsListCache = null;\n                    this.walletsListCacheCreationTimestamp = null;\n                });\n            }\n            return this.walletsListCache;\n        });\n    }\n    getEmbeddedWallet() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const walletsList = yield this.getWallets();\n            const embeddedWallets = walletsList.filter(isWalletInfoCurrentlyEmbedded);\n            return embeddedWallets.length === 1 ? embeddedWallets[0] : null;\n        });\n    }\n    fetchWalletsList() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let walletsList = [];\n            try {\n                const walletsResponse = yield fetch(this.walletsListSource);\n                walletsList = yield walletsResponse.json();\n                if (!Array.isArray(walletsList)) {\n                    throw new FetchWalletsError('Wrong wallets list format, wallets list must be an array.');\n                }\n                const wrongFormatWallets = walletsList.filter(wallet => !this.isCorrectWalletConfigDTO(wallet));\n                if (wrongFormatWallets.length) {\n                    logError(`Wallet(s) ${wrongFormatWallets\n                        .map(wallet => (wallet === null || wallet === void 0 ? void 0 : wallet.name) || 'unknown')\n                        .join(', ')} config format is wrong. They were removed from the wallets list.`);\n                    walletsList = walletsList.filter(wallet => this.isCorrectWalletConfigDTO(wallet));\n                }\n            }\n            catch (e) {\n                logError(e);\n                walletsList = FALLBACK_WALLETS_LIST;\n            }\n            let currentlyInjectedWallets = [];\n            try {\n                currentlyInjectedWallets = InjectedProvider.getCurrentlyInjectedWallets();\n            }\n            catch (e) {\n                logError(e);\n            }\n            return this.mergeWalletsLists(this.walletConfigDTOListToWalletConfigList(walletsList), currentlyInjectedWallets);\n        });\n    }\n    walletConfigDTOListToWalletConfigList(walletConfigDTO) {\n        return walletConfigDTO.map(walletConfigDTO => {\n            const walletConfig = {\n                name: walletConfigDTO.name,\n                appName: walletConfigDTO.app_name,\n                imageUrl: walletConfigDTO.image,\n                aboutUrl: walletConfigDTO.about_url,\n                tondns: walletConfigDTO.tondns,\n                platforms: walletConfigDTO.platforms,\n                features: walletConfigDTO.features\n            };\n            walletConfigDTO.bridge.forEach(bridge => {\n                if (bridge.type === 'sse') {\n                    walletConfig.bridgeUrl = bridge.url;\n                    walletConfig.universalLink =\n                        walletConfigDTO.universal_url;\n                    walletConfig.deepLink = walletConfigDTO.deepLink;\n                }\n                if (bridge.type === 'js') {\n                    const jsBridgeKey = bridge.key;\n                    walletConfig.jsBridgeKey = jsBridgeKey;\n                    walletConfig.injected =\n                        InjectedProvider.isWalletInjected(jsBridgeKey);\n                    walletConfig.embedded =\n                        InjectedProvider.isInsideWalletBrowser(jsBridgeKey);\n                }\n            });\n            return walletConfig;\n        });\n    }\n    mergeWalletsLists(list1, list2) {\n        const names = new Set(list1.concat(list2).map(item => item.name));\n        return [...names.values()].map(name => {\n            const list1Item = list1.find(item => item.name === name);\n            const list2Item = list2.find(item => item.name === name);\n            return Object.assign(Object.assign({}, (list1Item && Object.assign({}, list1Item))), (list2Item && Object.assign({}, list2Item)));\n        });\n    }\n    // eslint-disable-next-line complexity\n    isCorrectWalletConfigDTO(value) {\n        if (!value || !(typeof value === 'object')) {\n            return false;\n        }\n        const containsName = 'name' in value;\n        const containsAppName = 'app_name' in value;\n        const containsImage = 'image' in value;\n        const containsAbout = 'about_url' in value;\n        const containsPlatforms = 'platforms' in value;\n        if (!containsName ||\n            !containsImage ||\n            !containsAbout ||\n            !containsPlatforms ||\n            !containsAppName) {\n            return false;\n        }\n        if (!value.platforms ||\n            !Array.isArray(value.platforms) ||\n            !value.platforms.length) {\n            return false;\n        }\n        if (!('bridge' in value) ||\n            !Array.isArray(value.bridge) ||\n            !value.bridge.length) {\n            return false;\n        }\n        const bridge = value.bridge;\n        if (bridge.some(item => !item || typeof item !== 'object' || !('type' in item))) {\n            return false;\n        }\n        const sseBridge = bridge.find(item => item.type === 'sse');\n        if (sseBridge) {\n            if (!(typeof sseBridge === 'object' && 'url' in sseBridge) ||\n                !sseBridge.url ||\n                !value.universal_url) {\n                return false;\n            }\n        }\n        const jsBridge = bridge.find(item => item.type === 'js');\n        if (jsBridge) {\n            if (typeof jsBridge !== 'object' ||\n                !('key' in jsBridge) ||\n                !jsBridge.key) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\nfunction checkSendTransactionSupport(features, options) {\n    const supportsDeprecatedSendTransactionFeature = features.includes('SendTransaction');\n    const sendTransactionFeature = findFeature(features, 'SendTransaction');\n    const requiredFeature = {\n        minMessages: options.requiredMessagesNumber,\n        extraCurrencyRequired: options.requireExtraCurrencies\n    };\n    if (!supportsDeprecatedSendTransactionFeature && !sendTransactionFeature) {\n        throw new WalletNotSupportFeatureError(\"Wallet doesn't support SendTransaction feature.\", {\n            cause: { requiredFeature: { featureName: 'SendTransaction', value: requiredFeature } }\n        });\n    }\n    if (options.requireExtraCurrencies) {\n        if (!sendTransactionFeature || !sendTransactionFeature.extraCurrencySupported) {\n            throw new WalletNotSupportFeatureError(`Wallet is not able to handle such SendTransaction request. Extra currencies support is required.`, {\n                cause: {\n                    requiredFeature: { featureName: 'SendTransaction', value: requiredFeature }\n                }\n            });\n        }\n    }\n    if (sendTransactionFeature && sendTransactionFeature.maxMessages !== undefined) {\n        if (sendTransactionFeature.maxMessages < options.requiredMessagesNumber) {\n            throw new WalletNotSupportFeatureError(`Wallet is not able to handle such SendTransaction request. Max support messages number is ${sendTransactionFeature.maxMessages}, but ${options.requiredMessagesNumber} is required.`, {\n                cause: {\n                    requiredFeature: { featureName: 'SendTransaction', value: requiredFeature }\n                }\n            });\n        }\n        return;\n    }\n    logWarning(\"Connected wallet didn't provide information about max allowed messages in the SendTransaction request. Request may be rejected by the wallet.\");\n}\nfunction checkSignDataSupport(features, options) {\n    const signDataFeature = features.find(feature => feature && typeof feature === 'object' && feature.name === 'SignData');\n    if (!signDataFeature) {\n        throw new WalletNotSupportFeatureError(\"Wallet doesn't support SignData feature.\", {\n            cause: {\n                requiredFeature: {\n                    featureName: 'SignData',\n                    value: { types: options.requiredTypes }\n                }\n            }\n        });\n    }\n    const unsupportedTypes = options.requiredTypes.filter(requiredType => !signDataFeature.types.includes(requiredType));\n    if (unsupportedTypes.length) {\n        throw new WalletNotSupportFeatureError(`Wallet doesn't support required SignData types: ${unsupportedTypes.join(', ')}.`, {\n            cause: {\n                requiredFeature: { featureName: 'SignData', value: { types: unsupportedTypes } }\n            }\n        });\n    }\n}\nfunction checkRequiredWalletFeatures(features, walletsRequiredFeatures) {\n    if (typeof walletsRequiredFeatures !== 'object') {\n        return true;\n    }\n    const { sendTransaction, signData } = walletsRequiredFeatures;\n    if (sendTransaction) {\n        const feature = findFeature(features, 'SendTransaction');\n        if (!feature) {\n            return false;\n        }\n        if (!checkSendTransaction(feature, sendTransaction)) {\n            return false;\n        }\n    }\n    if (signData) {\n        const feature = findFeature(features, 'SignData');\n        if (!feature) {\n            return false;\n        }\n        if (!checkSignData(feature, signData)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction findFeature(features, requiredFeatureName) {\n    return features.find(f => f && typeof f === 'object' && f.name === requiredFeatureName);\n}\nfunction checkSendTransaction(feature, requiredFeature) {\n    const correctMessagesNumber = requiredFeature.minMessages === undefined ||\n        requiredFeature.minMessages <= feature.maxMessages;\n    const correctExtraCurrency = !requiredFeature.extraCurrencyRequired || feature.extraCurrencySupported;\n    return !!(correctMessagesNumber && correctExtraCurrency);\n}\nfunction checkSignData(feature, requiredFeature) {\n    return requiredFeature.types.every(requiredType => feature.types.includes(requiredType));\n}\n\n/**\n * Create a request version event.\n */\nfunction createRequestVersionEvent() {\n    return {\n        type: 'request-version'\n    };\n}\n/**\n * Create a response version event.\n * @param version\n */\nfunction createResponseVersionEvent(version) {\n    return {\n        type: 'response-version',\n        version: version\n    };\n}\n/**\n * Create a version info.\n * @param version\n */\nfunction createVersionInfo(version) {\n    return {\n        ton_connect_sdk_lib: version.ton_connect_sdk_lib,\n        ton_connect_ui_lib: version.ton_connect_ui_lib\n    };\n}\nfunction createConnectionInfo(version, wallet) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const isTonProof = ((_a = wallet === null || wallet === void 0 ? void 0 : wallet.connectItems) === null || _a === void 0 ? void 0 : _a.tonProof) && 'proof' in wallet.connectItems.tonProof;\n    const authType = isTonProof ? 'ton_proof' : 'ton_addr';\n    return {\n        wallet_address: (_c = (_b = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _b === void 0 ? void 0 : _b.address) !== null && _c !== void 0 ? _c : null,\n        wallet_type: (_d = wallet === null || wallet === void 0 ? void 0 : wallet.device.appName) !== null && _d !== void 0 ? _d : null,\n        wallet_version: (_e = wallet === null || wallet === void 0 ? void 0 : wallet.device.appVersion) !== null && _e !== void 0 ? _e : null,\n        auth_type: authType,\n        custom_data: Object.assign({ chain_id: (_g = (_f = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _f === void 0 ? void 0 : _f.chain) !== null && _g !== void 0 ? _g : null, provider: (_h = wallet === null || wallet === void 0 ? void 0 : wallet.provider) !== null && _h !== void 0 ? _h : null }, createVersionInfo(version))\n    };\n}\n/**\n * Create a connection init event.\n */\nfunction createConnectionStartedEvent(version) {\n    return {\n        type: 'connection-started',\n        custom_data: createVersionInfo(version)\n    };\n}\n/**\n * Create a connection completed event.\n * @param version\n * @param wallet\n */\nfunction createConnectionCompletedEvent(version, wallet) {\n    return Object.assign({ type: 'connection-completed', is_success: true }, createConnectionInfo(version, wallet));\n}\n/**\n * Create a connection error event.\n * @param version\n * @param error_message\n * @param errorCode\n */\nfunction createConnectionErrorEvent(version, error_message, errorCode) {\n    return {\n        type: 'connection-error',\n        is_success: false,\n        error_message: error_message,\n        error_code: errorCode !== null && errorCode !== void 0 ? errorCode : null,\n        custom_data: createVersionInfo(version)\n    };\n}\n/**\n * Create a connection restoring started event.\n */\nfunction createConnectionRestoringStartedEvent(version) {\n    return {\n        type: 'connection-restoring-started',\n        custom_data: createVersionInfo(version)\n    };\n}\n/**\n * Create a connection restoring completed event.\n * @param version\n * @param wallet\n */\nfunction createConnectionRestoringCompletedEvent(version, wallet) {\n    return Object.assign({ type: 'connection-restoring-completed', is_success: true }, createConnectionInfo(version, wallet));\n}\n/**\n * Create a connection restoring error event.\n * @param version\n * @param errorMessage\n */\nfunction createConnectionRestoringErrorEvent(version, errorMessage) {\n    return {\n        type: 'connection-restoring-error',\n        is_success: false,\n        error_message: errorMessage,\n        custom_data: createVersionInfo(version)\n    };\n}\nfunction createTransactionInfo(wallet, transaction) {\n    var _a, _b, _c, _d;\n    return {\n        valid_until: (_a = String(transaction.validUntil)) !== null && _a !== void 0 ? _a : null,\n        from: (_d = (_b = transaction.from) !== null && _b !== void 0 ? _b : (_c = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _c === void 0 ? void 0 : _c.address) !== null && _d !== void 0 ? _d : null,\n        messages: transaction.messages.map(message => {\n            var _a, _b;\n            return ({\n                address: (_a = message.address) !== null && _a !== void 0 ? _a : null,\n                amount: (_b = message.amount) !== null && _b !== void 0 ? _b : null\n            });\n        })\n    };\n}\n/**\n * Create a transaction init event.\n * @param version\n * @param wallet\n * @param transaction\n */\nfunction createTransactionSentForSignatureEvent(version, wallet, transaction) {\n    return Object.assign(Object.assign({ type: 'transaction-sent-for-signature' }, createConnectionInfo(version, wallet)), createTransactionInfo(wallet, transaction));\n}\n/**\n * Create a transaction signed event.\n * @param version\n * @param wallet\n * @param transaction\n * @param signedTransaction\n */\nfunction createTransactionSignedEvent(version, wallet, transaction, signedTransaction) {\n    return Object.assign(Object.assign({ type: 'transaction-signed', is_success: true, signed_transaction: signedTransaction.boc }, createConnectionInfo(version, wallet)), createTransactionInfo(wallet, transaction));\n}\n/**\n * Create a transaction error event.\n * @param version\n * @param wallet\n * @param transaction\n * @param errorMessage\n * @param errorCode\n */\nfunction createTransactionSigningFailedEvent(version, wallet, transaction, errorMessage, errorCode) {\n    return Object.assign(Object.assign({ type: 'transaction-signing-failed', is_success: false, error_message: errorMessage, error_code: errorCode !== null && errorCode !== void 0 ? errorCode : null }, createConnectionInfo(version, wallet)), createTransactionInfo(wallet, transaction));\n}\nfunction createDataSentForSignatureEvent(version, wallet, data) {\n    return Object.assign({ type: 'sign-data-request-initiated', data }, createConnectionInfo(version, wallet));\n}\nfunction createDataSignedEvent(version, wallet, data, signedData) {\n    return Object.assign({ type: 'sign-data-request-completed', is_success: true, data, signed_data: signedData }, createConnectionInfo(version, wallet));\n}\nfunction createDataSigningFailedEvent(version, wallet, data, errorMessage, errorCode) {\n    return Object.assign({ type: 'sign-data-request-failed', is_success: false, data, error_message: errorMessage, error_code: errorCode !== null && errorCode !== void 0 ? errorCode : null }, createConnectionInfo(version, wallet));\n}\n/**\n * Create a disconnect event.\n * @param version\n * @param wallet\n * @param scope\n * @returns\n */\nfunction createDisconnectionEvent(version, wallet, scope) {\n    return Object.assign({ type: 'disconnection', scope: scope }, createConnectionInfo(version, wallet));\n}\n\n/**\n * A concrete implementation of EventDispatcher that dispatches events to the browser window.\n */\nclass BrowserEventDispatcher {\n    constructor() {\n        /**\n         * The window object, possibly undefined in a server environment.\n         * @private\n         */\n        this.window = getWindow();\n    }\n    /**\n     * Dispatches an event with the given name and details to the browser window.\n     * @param eventName - The name of the event to dispatch.\n     * @param eventDetails - The details of the event to dispatch.\n     * @returns A promise that resolves when the event has been dispatched.\n     */\n    dispatchEvent(eventName, eventDetails) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const event = new CustomEvent(eventName, { detail: eventDetails });\n            (_a = this.window) === null || _a === void 0 ? void 0 : _a.dispatchEvent(event);\n        });\n    }\n    /**\n     * Adds an event listener to the browser window.\n     * @param eventName - The name of the event to listen for.\n     * @param listener - The listener to add.\n     * @param options - The options for the listener.\n     * @returns A function that removes the listener.\n     */\n    addEventListener(eventName, listener, options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            (_a = this.window) === null || _a === void 0 ? void 0 : _a.addEventListener(eventName, listener, options);\n            return () => {\n                var _a;\n                return (_a = this.window) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, listener);\n            };\n        });\n    }\n}\n\n/**\n * Tracker for TonConnect user actions, such as transaction signing, connection, etc.\n *\n * List of events:\n *  * `connection-started`: when a user starts connecting a wallet.\n *  * `connection-completed`: when a user successfully connected a wallet.\n *  * `connection-error`: when a user cancels a connection or there is an error during the connection process.\n *  * `connection-restoring-started`: when the dApp starts restoring a connection.\n *  * `connection-restoring-completed`: when the dApp successfully restores a connection.\n *  * `connection-restoring-error`: when the dApp fails to restore a connection.\n *  * `disconnection`: when a user starts disconnecting a wallet.\n *  * `transaction-sent-for-signature`: when a user sends a transaction for signature.\n *  * `transaction-signed`: when a user successfully signs a transaction.\n *  * `transaction-signing-failed`: when a user cancels transaction signing or there is an error during the signing process.\n *  * `sign-data-request-initiated`: when a user sends data for signature.\n *  * `sign-data-request-completed`: when a user successfully signs data.\n *  * `sign-data-request-failed`: when a user cancels data signing or there is an error during the signing process.\n *\n * If you want to track user actions, you can subscribe to the window events with prefix `ton-connect-`:\n *\n * @example\n * window.addEventListener('ton-connect-transaction-sent-for-signature', (event) => {\n *    console.log('Transaction init', event.detail);\n * });\n *\n * @internal\n */\nclass TonConnectTracker {\n    constructor(options) {\n        var _a;\n        /**\n         * Event prefix for user actions.\n         * @private\n         */\n        this.eventPrefix = 'ton-connect-';\n        /**\n         * TonConnect UI version.\n         */\n        this.tonConnectUiVersion = null;\n        this.eventDispatcher = (_a = options === null || options === void 0 ? void 0 : options.eventDispatcher) !== null && _a !== void 0 ? _a : new BrowserEventDispatcher();\n        this.tonConnectSdkVersion = options.tonConnectSdkVersion;\n        this.init().catch();\n    }\n    /**\n     * Version of the library.\n     */\n    get version() {\n        return createVersionInfo({\n            ton_connect_sdk_lib: this.tonConnectSdkVersion,\n            ton_connect_ui_lib: this.tonConnectUiVersion\n        });\n    }\n    /**\n     * Called once when the tracker is created and request version other libraries.\n     */\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this.setRequestVersionHandler();\n                this.tonConnectUiVersion = yield this.requestTonConnectUiVersion();\n            }\n            catch (e) { }\n        });\n    }\n    /**\n     * Set request version handler.\n     * @private\n     */\n    setRequestVersionHandler() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.eventDispatcher.addEventListener('ton-connect-request-version', () => __awaiter(this, void 0, void 0, function* () {\n                yield this.eventDispatcher.dispatchEvent('ton-connect-response-version', createResponseVersionEvent(this.tonConnectSdkVersion));\n            }));\n        });\n    }\n    /**\n     * Request TonConnect UI version.\n     * @private\n     */\n    requestTonConnectUiVersion() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    yield this.eventDispatcher.addEventListener('ton-connect-ui-response-version', (event) => {\n                        resolve(event.detail.version);\n                    }, { once: true });\n                    yield this.eventDispatcher.dispatchEvent('ton-connect-ui-request-version', createRequestVersionEvent());\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }));\n        });\n    }\n    /**\n     * Emit user action event to the window.\n     * @param eventDetails\n     * @private\n     */\n    dispatchUserActionEvent(eventDetails) {\n        try {\n            this.eventDispatcher\n                .dispatchEvent(`${this.eventPrefix}${eventDetails.type}`, eventDetails)\n                .catch();\n        }\n        catch (e) { }\n    }\n    /**\n     * Track connection init event.\n     * @param args\n     */\n    trackConnectionStarted(...args) {\n        try {\n            const event = createConnectionStartedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track connection success event.\n     * @param args\n     */\n    trackConnectionCompleted(...args) {\n        try {\n            const event = createConnectionCompletedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track connection error event.\n     * @param args\n     */\n    trackConnectionError(...args) {\n        try {\n            const event = createConnectionErrorEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track connection restoring init event.\n     * @param args\n     */\n    trackConnectionRestoringStarted(...args) {\n        try {\n            const event = createConnectionRestoringStartedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track connection restoring success event.\n     * @param args\n     */\n    trackConnectionRestoringCompleted(...args) {\n        try {\n            const event = createConnectionRestoringCompletedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track connection restoring error event.\n     * @param args\n     */\n    trackConnectionRestoringError(...args) {\n        try {\n            const event = createConnectionRestoringErrorEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track disconnect event.\n     * @param args\n     */\n    trackDisconnection(...args) {\n        try {\n            const event = createDisconnectionEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track transaction init event.\n     * @param args\n     */\n    trackTransactionSentForSignature(...args) {\n        try {\n            const event = createTransactionSentForSignatureEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track transaction signed event.\n     * @param args\n     */\n    trackTransactionSigned(...args) {\n        try {\n            const event = createTransactionSignedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track transaction error event.\n     * @param args\n     */\n    trackTransactionSigningFailed(...args) {\n        try {\n            const event = createTransactionSigningFailedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track sign data init event.\n     * @param args\n     */\n    trackDataSentForSignature(...args) {\n        try {\n            const event = createDataSentForSignatureEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track sign data success event.\n     * @param args\n     */\n    trackDataSigned(...args) {\n        try {\n            const event = createDataSignedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n    /**\n     * Track sign data error event.\n     * @param args\n     */\n    trackDataSigningFailed(...args) {\n        try {\n            const event = createDataSigningFailedEvent(this.version, ...args);\n            this.dispatchUserActionEvent(event);\n        }\n        catch (e) { }\n    }\n}\n\nconst tonConnectSdkVersion = \"3.2.0\";\n\nclass TonConnect {\n    constructor(options) {\n        this.walletsList = new WalletsListManager();\n        this._wallet = null;\n        this.provider = null;\n        this.statusChangeSubscriptions = [];\n        this.statusChangeErrorSubscriptions = [];\n        this.dappSettings = {\n            manifestUrl: (options === null || options === void 0 ? void 0 : options.manifestUrl) || getWebPageManifest(),\n            storage: (options === null || options === void 0 ? void 0 : options.storage) || new DefaultStorage()\n        };\n        this.walletsRequiredFeatures = options === null || options === void 0 ? void 0 : options.walletsRequiredFeatures;\n        this.walletsList = new WalletsListManager({\n            walletsListSource: options === null || options === void 0 ? void 0 : options.walletsListSource,\n            cacheTTLMs: options === null || options === void 0 ? void 0 : options.walletsListCacheTTLMs\n        });\n        this.tracker = new TonConnectTracker({\n            eventDispatcher: options === null || options === void 0 ? void 0 : options.eventDispatcher,\n            tonConnectSdkVersion: tonConnectSdkVersion\n        });\n        if (!this.dappSettings.manifestUrl) {\n            throw new DappMetadataError('Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest');\n        }\n        this.bridgeConnectionStorage = new BridgeConnectionStorage(this.dappSettings.storage);\n        if (!(options === null || options === void 0 ? void 0 : options.disableAutoPauseConnection)) {\n            this.addWindowFocusAndBlurSubscriptions();\n        }\n    }\n    /**\n     * Returns available wallets list.\n     */\n    static getWallets() {\n        return this.walletsList.getWallets();\n    }\n    /**\n     * Shows if the wallet is connected right now.\n     */\n    get connected() {\n        return this._wallet !== null;\n    }\n    /**\n     * Current connected account or null if no account is connected.\n     */\n    get account() {\n        var _a;\n        return ((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.account) || null;\n    }\n    /**\n     * Current connected wallet or null if no account is connected.\n     */\n    get wallet() {\n        return this._wallet;\n    }\n    set wallet(value) {\n        this._wallet = value;\n        this.statusChangeSubscriptions.forEach(callback => callback(this._wallet));\n    }\n    /**\n     * Returns available wallets list.\n     */\n    getWallets() {\n        return this.walletsList.getWallets();\n    }\n    /**\n     * Allows to subscribe to connection status changes and handle connection errors.\n     * @param callback will be called after connections status changes with actual wallet or null.\n     * @param errorsHandler (optional) will be called with some instance of TonConnectError when connect error is received.\n     * @returns unsubscribe callback.\n     */\n    onStatusChange(callback, errorsHandler) {\n        this.statusChangeSubscriptions.push(callback);\n        if (errorsHandler) {\n            this.statusChangeErrorSubscriptions.push(errorsHandler);\n        }\n        return () => {\n            this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter(item => item !== callback);\n            if (errorsHandler) {\n                this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter(item => item !== errorsHandler);\n            }\n        };\n    }\n    connect(wallet, requestOrOptions) {\n        var _a, _b;\n        // TODO: remove deprecated method\n        const options = {};\n        if (typeof requestOrOptions === 'object' && 'tonProof' in requestOrOptions) {\n            options.request = requestOrOptions;\n        }\n        if (typeof requestOrOptions === 'object' &&\n            ('openingDeadlineMS' in requestOrOptions ||\n                'signal' in requestOrOptions ||\n                'request' in requestOrOptions)) {\n            options.request = requestOrOptions === null || requestOrOptions === void 0 ? void 0 : requestOrOptions.request;\n            options.openingDeadlineMS = requestOrOptions === null || requestOrOptions === void 0 ? void 0 : requestOrOptions.openingDeadlineMS;\n            options.signal = requestOrOptions === null || requestOrOptions === void 0 ? void 0 : requestOrOptions.signal;\n        }\n        if (this.connected) {\n            throw new WalletAlreadyConnectedError();\n        }\n        const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n        (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n        this.abortController = abortController;\n        if (abortController.signal.aborted) {\n            throw new TonConnectError('Connection was aborted');\n        }\n        (_b = this.provider) === null || _b === void 0 ? void 0 : _b.closeConnection();\n        this.provider = this.createProvider(wallet);\n        abortController.signal.addEventListener('abort', () => {\n            var _a;\n            (_a = this.provider) === null || _a === void 0 ? void 0 : _a.closeConnection();\n            this.provider = null;\n        });\n        this.tracker.trackConnectionStarted();\n        return this.provider.connect(this.createConnectRequest(options === null || options === void 0 ? void 0 : options.request), {\n            openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n            signal: abortController.signal\n        });\n    }\n    /**\n     * Try to restore existing session and reconnect to the corresponding wallet. Call it immediately when your app is loaded.\n     */\n    restoreConnection(options) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            this.tracker.trackConnectionRestoringStarted();\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n            this.abortController = abortController;\n            if (abortController.signal.aborted) {\n                this.tracker.trackConnectionRestoringError('Connection restoring was aborted');\n                return;\n            }\n            // TODO: potentially race condition here\n            const [bridgeConnectionType, embeddedWallet] = yield Promise.all([\n                this.bridgeConnectionStorage.storedConnectionType(),\n                this.walletsList.getEmbeddedWallet()\n            ]);\n            if (abortController.signal.aborted) {\n                this.tracker.trackConnectionRestoringError('Connection restoring was aborted');\n                return;\n            }\n            let provider = null;\n            try {\n                switch (bridgeConnectionType) {\n                    case 'http':\n                        provider = yield BridgeProvider.fromStorage(this.dappSettings.storage);\n                        break;\n                    case 'injected':\n                        provider = yield InjectedProvider.fromStorage(this.dappSettings.storage);\n                        break;\n                    default:\n                        if (embeddedWallet) {\n                            provider = this.createProvider(embeddedWallet);\n                        }\n                        else {\n                            return;\n                        }\n                }\n            }\n            catch (_c) {\n                this.tracker.trackConnectionRestoringError('Provider is not restored');\n                yield this.bridgeConnectionStorage.removeConnection();\n                provider === null || provider === void 0 ? void 0 : provider.closeConnection();\n                provider = null;\n                return;\n            }\n            if (abortController.signal.aborted) {\n                provider === null || provider === void 0 ? void 0 : provider.closeConnection();\n                this.tracker.trackConnectionRestoringError('Connection restoring was aborted');\n                return;\n            }\n            if (!provider) {\n                logError('Provider is not restored');\n                this.tracker.trackConnectionRestoringError('Provider is not restored');\n                return;\n            }\n            (_b = this.provider) === null || _b === void 0 ? void 0 : _b.closeConnection();\n            this.provider = provider;\n            provider.listen(this.walletEventsListener.bind(this));\n            const onAbortRestore = () => {\n                this.tracker.trackConnectionRestoringError('Connection restoring was aborted');\n                provider === null || provider === void 0 ? void 0 : provider.closeConnection();\n                provider = null;\n            };\n            abortController.signal.addEventListener('abort', onAbortRestore);\n            const restoreConnectionTask = callForSuccess((_options) => __awaiter(this, void 0, void 0, function* () {\n                yield (provider === null || provider === void 0 ? void 0 : provider.restoreConnection({\n                    openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n                    signal: _options.signal\n                }));\n                abortController.signal.removeEventListener('abort', onAbortRestore);\n                if (this.connected) {\n                    this.tracker.trackConnectionRestoringCompleted(this.wallet);\n                }\n                else {\n                    this.tracker.trackConnectionRestoringError('Connection restoring failed');\n                }\n            }), {\n                attempts: Number.MAX_SAFE_INTEGER,\n                delayMs: 2000,\n                signal: options === null || options === void 0 ? void 0 : options.signal\n            });\n            const restoreConnectionTimeout = new Promise(resolve => setTimeout(() => resolve(), 12000) // connection deadline\n            );\n            return Promise.race([restoreConnectionTask, restoreConnectionTimeout]);\n        });\n    }\n    sendTransaction(transaction, optionsOrOnRequestSent) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: remove deprecated method\n            const options = {};\n            if (typeof optionsOrOnRequestSent === 'function') {\n                options.onRequestSent = optionsOrOnRequestSent;\n            }\n            else {\n                options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;\n                options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;\n            }\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            if (abortController.signal.aborted) {\n                throw new TonConnectError('Transaction sending was aborted');\n            }\n            this.checkConnection();\n            const requiredMessagesNumber = transaction.messages.length;\n            const requireExtraCurrencies = transaction.messages.some(m => m.extraCurrency && Object.keys(m.extraCurrency).length > 0);\n            checkSendTransactionSupport(this.wallet.device.features, {\n                requiredMessagesNumber,\n                requireExtraCurrencies\n            });\n            this.tracker.trackTransactionSentForSignature(this.wallet, transaction);\n            const { validUntil, messages } = transaction, tx = __rest(transaction, [\"validUntil\", \"messages\"]);\n            const from = transaction.from || this.account.address;\n            const network = transaction.network || this.account.chain;\n            const response = yield this.provider.sendRequest(sendTransactionParser.convertToRpcRequest(Object.assign(Object.assign({}, tx), { from,\n                network, valid_until: validUntil, messages: messages.map((_a) => {\n                    var { extraCurrency } = _a, msg = __rest(_a, [\"extraCurrency\"]);\n                    return (Object.assign(Object.assign({}, msg), { extra_currency: extraCurrency }));\n                }) })), { onRequestSent: options.onRequestSent, signal: abortController.signal });\n            if (sendTransactionParser.isError(response)) {\n                this.tracker.trackTransactionSigningFailed(this.wallet, transaction, response.error.message, response.error.code);\n                return sendTransactionParser.parseAndThrowError(response);\n            }\n            const result = sendTransactionParser.convertFromRpcResponse(response);\n            this.tracker.trackTransactionSigned(this.wallet, transaction, result);\n            return result;\n        });\n    }\n    signData(data, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            if (abortController.signal.aborted) {\n                throw new TonConnectError('data sending was aborted');\n            }\n            this.checkConnection();\n            checkSignDataSupport(this.wallet.device.features, { requiredTypes: [data.type] });\n            this.tracker.trackDataSentForSignature(this.wallet, data);\n            const from = data.from || this.account.address;\n            const network = data.network || this.account.chain;\n            const response = yield this.provider.sendRequest(signDataParser.convertToRpcRequest(Object.assign(Object.assign({}, data), { from,\n                network })), { onRequestSent: options === null || options === void 0 ? void 0 : options.onRequestSent, signal: abortController.signal });\n            if (signDataParser.isError(response)) {\n                this.tracker.trackDataSigningFailed(this.wallet, data, response.error.message, response.error.code);\n                return signDataParser.parseAndThrowError(response);\n            }\n            const result = signDataParser.convertFromRpcResponse(response);\n            this.tracker.trackDataSigned(this.wallet, data, result);\n            return result;\n        });\n    }\n    /**\n     * Disconnect form thw connected wallet and drop current session.\n     */\n    disconnect(options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.connected) {\n                throw new WalletNotConnectedError();\n            }\n            const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n            const prevAbortController = this.abortController;\n            this.abortController = abortController;\n            if (abortController.signal.aborted) {\n                throw new TonConnectError('Disconnect was aborted');\n            }\n            this.onWalletDisconnected('dapp');\n            yield ((_a = this.provider) === null || _a === void 0 ? void 0 : _a.disconnect({\n                signal: abortController.signal\n            }));\n            prevAbortController === null || prevAbortController === void 0 ? void 0 : prevAbortController.abort();\n        });\n    }\n    /**\n     * Pause bridge HTTP connection. Might be helpful, if you want to pause connections while browser tab is unfocused,\n     * or if you use SDK with NodeJS and want to save server resources.\n     */\n    pauseConnection() {\n        var _a;\n        if (((_a = this.provider) === null || _a === void 0 ? void 0 : _a.type) !== 'http') {\n            return;\n        }\n        this.provider.pause();\n    }\n    /**\n     * Unpause bridge HTTP connection if it is paused.\n     */\n    unPauseConnection() {\n        var _a;\n        if (((_a = this.provider) === null || _a === void 0 ? void 0 : _a.type) !== 'http') {\n            return Promise.resolve();\n        }\n        return this.provider.unPause();\n    }\n    addWindowFocusAndBlurSubscriptions() {\n        const document = getDocument();\n        if (!document) {\n            return;\n        }\n        try {\n            document.addEventListener('visibilitychange', () => {\n                if (document.hidden) {\n                    this.pauseConnection();\n                }\n                else {\n                    this.unPauseConnection().catch();\n                }\n            });\n        }\n        catch (e) {\n            logError('Cannot subscribe to the document.visibilitychange: ', e);\n        }\n    }\n    createProvider(wallet) {\n        let provider;\n        if (!Array.isArray(wallet) && isWalletConnectionSourceJS(wallet)) {\n            provider = new InjectedProvider(this.dappSettings.storage, wallet.jsBridgeKey);\n        }\n        else {\n            provider = new BridgeProvider(this.dappSettings.storage, wallet);\n        }\n        provider.listen(this.walletEventsListener.bind(this));\n        return provider;\n    }\n    walletEventsListener(e) {\n        switch (e.event) {\n            case 'connect':\n                this.onWalletConnected(e.payload);\n                break;\n            case 'connect_error':\n                this.tracker.trackConnectionError(e.payload.message, e.payload.code);\n                const walletError = connectErrorsParser.parseError(e.payload);\n                this.onWalletConnectError(walletError);\n                break;\n            case 'disconnect':\n                this.onWalletDisconnected('wallet');\n        }\n    }\n    onWalletConnected(connectEvent) {\n        var _a;\n        const tonAccountItem = connectEvent.items.find(item => item.name === 'ton_addr');\n        const tonProofItem = connectEvent.items.find(item => item.name === 'ton_proof');\n        if (!tonAccountItem) {\n            throw new TonConnectError('ton_addr connection item was not found');\n        }\n        const hasRequiredFeatures = checkRequiredWalletFeatures(connectEvent.device.features, this.walletsRequiredFeatures);\n        if (!hasRequiredFeatures) {\n            (_a = this.provider) === null || _a === void 0 ? void 0 : _a.disconnect();\n            this.onWalletConnectError(new WalletMissingRequiredFeaturesError('Wallet does not support required features', { cause: { connectEvent } }));\n            return;\n        }\n        const wallet = {\n            device: connectEvent.device,\n            provider: this.provider.type,\n            account: {\n                address: tonAccountItem.address,\n                chain: tonAccountItem.network,\n                walletStateInit: tonAccountItem.walletStateInit,\n                publicKey: tonAccountItem.publicKey\n            }\n        };\n        if (tonProofItem) {\n            let tonProof = undefined;\n            try {\n                if ('proof' in tonProofItem) { // success\n                    tonProof = {\n                        name: 'ton_proof',\n                        proof: {\n                            timestamp: tonProofItem.proof.timestamp,\n                            domain: {\n                                lengthBytes: tonProofItem.proof.domain.lengthBytes,\n                                value: tonProofItem.proof.domain.value,\n                            },\n                            payload: tonProofItem.proof.payload,\n                            signature: tonProofItem.proof.signature,\n                        }\n                    };\n                }\n                else if ('error' in tonProofItem) { // error\n                    tonProof = {\n                        name: 'ton_proof',\n                        error: {\n                            code: tonProofItem.error.code,\n                            message: tonProofItem.error.message,\n                        }\n                    };\n                }\n                else {\n                    throw new TonConnectError('Invalid data format');\n                }\n            }\n            catch (e) {\n                tonProof = {\n                    name: 'ton_proof',\n                    error: {\n                        code: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_ITEM_ERROR_CODES.UNKNOWN_ERROR,\n                        message: 'Invalid data format'\n                    }\n                };\n            }\n            wallet.connectItems = { tonProof };\n        }\n        this.wallet = wallet;\n        this.tracker.trackConnectionCompleted(wallet);\n    }\n    onWalletConnectError(error) {\n        this.statusChangeErrorSubscriptions.forEach(errorsHandler => errorsHandler(error));\n        logDebug(error);\n        if (error instanceof ManifestNotFoundError || error instanceof ManifestContentErrorError) {\n            logError(error);\n            throw error;\n        }\n    }\n    onWalletDisconnected(scope) {\n        this.tracker.trackDisconnection(this.wallet, scope);\n        this.wallet = null;\n    }\n    checkConnection() {\n        if (!this.connected) {\n            throw new WalletNotConnectedError();\n        }\n    }\n    createConnectRequest(request) {\n        const items = [\n            {\n                name: 'ton_addr'\n            }\n        ];\n        if (request === null || request === void 0 ? void 0 : request.tonProof) {\n            items.push({\n                name: 'ton_proof',\n                payload: request.tonProof\n            });\n        }\n        return {\n            manifestUrl: this.dappSettings.manifestUrl,\n            items\n        };\n    }\n}\nTonConnect.walletsList = new WalletsListManager();\n/**\n * Check if specified wallet is injected and available to use with the app.\n * @param walletJSKey target wallet's js bridge key.\n */\nTonConnect.isWalletInjected = (walletJSKey) => InjectedProvider.isWalletInjected(walletJSKey);\n/**\n * Check if the app is opened inside specified wallet's browser.\n * @param walletJSKey target wallet's js bridge key.\n */\nTonConnect.isInsideWalletBrowser = (walletJSKey) => InjectedProvider.isInsideWalletBrowser(walletJSKey);\n\nconst noBounceableTag = 0x51;\nconst testOnlyTag = 0x80;\n/**\n * Converts raw TON address to no-bounceable user-friendly format. [See details]{@link https://ton.org/docs/learn/overviews/addresses#user-friendly-address}\n * @param hexAddress raw TON address formatted as \"0:<hex string without 0x>\".\n * @param [testOnly=false] convert address to test-only form. [See details]{@link https://ton.org/docs/learn/overviews/addresses#user-friendly-address}\n */\nfunction toUserFriendlyAddress(hexAddress, testOnly = false) {\n    const { wc, hex } = parseHexAddress(hexAddress);\n    let tag = noBounceableTag;\n    if (testOnly) {\n        tag |= testOnlyTag;\n    }\n    const addr = new Int8Array(34);\n    addr[0] = tag;\n    addr[1] = wc;\n    addr.set(hex, 2);\n    const addressWithChecksum = new Uint8Array(36);\n    addressWithChecksum.set(addr);\n    addressWithChecksum.set(crc16(addr), 34);\n    let addressBase64 = _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.Base64.encode(addressWithChecksum);\n    return addressBase64.replace(/\\+/g, '-').replace(/\\//g, '_');\n}\nfunction parseHexAddress(hexAddress) {\n    if (!hexAddress.includes(':')) {\n        throw new WrongAddressError(`Wrong address ${hexAddress}. Address must include \":\".`);\n    }\n    const parts = hexAddress.split(':');\n    if (parts.length !== 2) {\n        throw new WrongAddressError(`Wrong address ${hexAddress}. Address must include \":\" only once.`);\n    }\n    const wc = parseInt(parts[0]);\n    if (wc !== 0 && wc !== -1) {\n        throw new WrongAddressError(`Wrong address ${hexAddress}. WC must be eq 0 or -1, but ${wc} received.`);\n    }\n    const hex = parts[1];\n    if ((hex === null || hex === void 0 ? void 0 : hex.length) !== 64) {\n        throw new WrongAddressError(`Wrong address ${hexAddress}. Hex part must be 64bytes length, but ${hex === null || hex === void 0 ? void 0 : hex.length} received.`);\n    }\n    return {\n        wc,\n        hex: hexToBytes(hex)\n    };\n}\nfunction crc16(data) {\n    const poly = 0x1021;\n    let reg = 0;\n    const message = new Uint8Array(data.length + 2);\n    message.set(data);\n    for (let byte of message) {\n        let mask = 0x80;\n        while (mask > 0) {\n            reg <<= 1;\n            if (byte & mask) {\n                reg += 1;\n            }\n            mask >>= 1;\n            if (reg > 0xffff) {\n                reg &= 0xffff;\n                reg ^= poly;\n            }\n        }\n    }\n    return new Uint8Array([Math.floor(reg / 256), reg % 256]);\n}\nconst toByteMap = {};\nfor (let ord = 0; ord <= 0xff; ord++) {\n    let s = ord.toString(16);\n    if (s.length < 2) {\n        s = '0' + s;\n    }\n    toByteMap[s] = ord;\n}\nfunction hexToBytes(hex) {\n    hex = hex.toLowerCase();\n    const length2 = hex.length;\n    if (length2 % 2 !== 0) {\n        throw new ParseHexError('Hex string must have length a multiple of 2: ' + hex);\n    }\n    const length = length2 / 2;\n    const result = new Uint8Array(length);\n    for (let i = 0; i < length; i++) {\n        const doubled = i * 2;\n        const hexSubstring = hex.substring(doubled, doubled + 2);\n        if (!toByteMap.hasOwnProperty(hexSubstring)) {\n            throw new ParseHexError('Invalid hex character: ' + hexSubstring);\n        }\n        result[i] = toByteMap[hexSubstring];\n    }\n    return result;\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRvbmNvbm5lY3Qrc2RrQDMuMi4wL25vZGVfbW9kdWxlcy9AdG9uY29ubmVjdC9zZGsvbGliL2VzbS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVMO0FBQ2hDO0FBQzNHO0FBQ047O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3QkFBd0IsRUFBRSxzQkFBc0IsRUFBRSxrQ0FBa0MsRUFBRSw4QkFBOEI7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssMkVBQXlCO0FBQzlCLEtBQUssMkVBQXlCO0FBQzlCLEtBQUssMkVBQXlCO0FBQzlCLEtBQUssMkVBQXlCO0FBQzlCLEtBQUssMkVBQXlCO0FBQzlCLEtBQUssMkVBQXlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssOEVBQTRCO0FBQ2pDLEtBQUssOEVBQTRCO0FBQ2pDLEtBQUssOEVBQTRCO0FBQ2pDLEtBQUssOEVBQTRCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSyx1RUFBcUI7QUFDMUIsS0FBSyx1RUFBcUI7QUFDMUIsS0FBSyx1RUFBcUI7QUFDMUIsS0FBSyx1RUFBcUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsY0FBYztBQUN6QixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEgsWUFBWTtBQUN0STtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxVQUFVO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsRUFBRTtBQUN0RTtBQUNBO0FBQ0Esa0NBQWtDLGdDQUFnQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUMsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsY0FBYztBQUN6QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxRQUFRO0FBQ3BFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSSxZQUFZO0FBQ3pCLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0RBQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGdCQUFnQjtBQUM1RjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSwrRUFBK0UsRUFBRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixFQUFFO0FBQzNGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdFQUF3RSxnQkFBZ0I7QUFDeEY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwyQkFBMkI7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixPQUFPO0FBQ3pGO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVMsS0FBSywwREFBMEQ7QUFDeEUsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsK0RBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtEQUFhO0FBQ2hEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHlDQUF5QztBQUMxRixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsK0RBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHdDQUF3QyxnQ0FBZ0M7QUFDeEU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixjQUFjLElBQUk7QUFDbEcsbUhBQW1ILGNBQWMsSUFBSSxJQUFJLG9FQUFjO0FBQ3ZKO0FBQ0Esd0dBQXdHLHdKQUF3SjtBQUNoUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiw2Q0FBNkMsa0NBQWtDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRix3REFBTSx1REFBdUQsb0VBQWM7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxpQkFBaUIsdURBQXVELE9BQU87QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGtCQUFrQjtBQUN4RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseURBQXlELG1CQUFtQixpQkFBaUI7QUFDN0Y7QUFDQSxxRUFBcUUsbUJBQW1CLHVDQUF1QywyQkFBMkIsc0JBQXNCLEdBQUc7QUFDbkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0hBQXdILFdBQVc7QUFDbkk7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixjQUFjLElBQUk7QUFDdEcsa0ZBQWtGLGNBQWMsSUFBSTtBQUNwRztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsZ0JBQWdCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0NBQWdDLDhDQUE4QztBQUMvSCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSkFBZ0osbUNBQW1DLFFBQVEsZ0NBQWdDO0FBQzNOO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyw0QkFBNEI7QUFDOUg7QUFDQSxtQ0FBbUMsa0NBQWtDO0FBQ3JFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb1NBQW9TO0FBQ3pVO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQWdEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBEQUEwRDtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx3Q0FBd0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlGQUF5RjtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywrSkFBK0o7QUFDeE07QUFDQTtBQUNBLDJCQUEyQiwyQ0FBMkM7QUFDdEU7QUFDQTtBQUNBLDJCQUEyQixzRkFBc0Y7QUFDakg7QUFDQTtBQUNBLDJCQUEyQixtS0FBbUs7QUFDOUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFDQUFxQztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHNCQUFzQjtBQUM3RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFJLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQixFQUFFLGtCQUFrQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0EscUlBQXFJLFNBQVM7QUFDOUk7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDLDBEQUEwRCxVQUFVLCtCQUErQjtBQUNuRyxpQkFBaUIsR0FBRyxNQUFNLHNFQUFzRTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDRCQUE0QjtBQUM1RjtBQUNBO0FBQ0E7QUFDQSw4SEFBOEgsV0FBVztBQUN6SSx5QkFBeUIsTUFBTSx3SEFBd0g7QUFDdko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SCxTQUFTLGdCQUFnQjtBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwRUFBd0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsV0FBVztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsV0FBVztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsV0FBVywrQkFBK0IsSUFBSTtBQUNuRztBQUNBO0FBQ0E7QUFDQSxxREFBcUQsV0FBVyx5Q0FBeUMsc0RBQXNEO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ21DO0FBQ2htQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRvbmNvbm5lY3Qrc2RrQDMuMi4wL25vZGVfbW9kdWxlcy9AdG9uY29ubmVjdC9zZGsvbGliL2VzbS9pbmRleC5tanM/OWM2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTLCBTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTLCBTSUdOX0RBVEFfRVJST1JfQ09ERVMsIEJhc2U2NCwgU2Vzc2lvbkNyeXB0bywgaGV4VG9CeXRlQXJyYXksIENPTk5FQ1RfSVRFTV9FUlJPUl9DT0RFUyB9IGZyb20gJ0B0b25jb25uZWN0L3Byb3RvY29sJztcbmV4cG9ydCB7IENIQUlOLCBDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTLCBDT05ORUNUX0lURU1fRVJST1JfQ09ERVMsIFNFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVMsIFNJR05fREFUQV9FUlJPUl9DT0RFUyB9IGZyb20gJ0B0b25jb25uZWN0L3Byb3RvY29sJztcbmltcG9ydCAnQHRvbmNvbm5lY3QvaXNvbW9ycGhpYy1ldmVudHNvdXJjZSc7XG5pbXBvcnQgJ0B0b25jb25uZWN0L2lzb21vcnBoaWMtZmV0Y2gnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgVG9uQ29ubmVjdCBlcnJvcnMuIFlvdSBjYW4gY2hlY2sgaWYgdGhlIGVycm9yIHdhcyB0cmlnZ2VyZWQgYnkgdGhlIEB0b25jb25uZWN0L3NkayB1c2luZyBgZXJyIGluc3RhbmNlb2YgVG9uQ29ubmVjdEVycm9yYC5cbiAqL1xuY2xhc3MgVG9uQ29ubmVjdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGAke1RvbkNvbm5lY3RFcnJvci5wcmVmaXh9ICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSR7dGhpcy5pbmZvID8gJzogJyArIHRoaXMuaW5mbyA6ICcnfSR7bWVzc2FnZSA/ICdcXG4nICsgbWVzc2FnZSA6ICcnfWA7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBUb25Db25uZWN0RXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5Ub25Db25uZWN0RXJyb3IucHJlZml4ID0gJ1tUT05fQ09OTkVDVF9TREtfRVJST1JdJztcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBwYXNzZWQgRGFwcE1ldGFkYXRhIGlzIGluIGluY29ycmVjdCBmb3JtYXQuXG4gKi9cbmNsYXNzIERhcHBNZXRhZGF0YUVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdQYXNzZWQgRGFwcE1ldGFkYXRhIGlzIGluIGluY29ycmVjdCBmb3JtYXQuJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIERhcHBNZXRhZGF0YUVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHBhc3NlZCBtYW5pZmVzdCBjb250YWlucyBlcnJvcnMuXG4gKi9cbmNsYXNzIE1hbmlmZXN0Q29udGVudEVycm9yRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ1Bhc3NlZCBgdG9uY29ubmVjdC1tYW5pZmVzdC5qc29uYCBjb250YWlucyBlcnJvcnMuIENoZWNrIGZvcm1hdCBvZiB5b3VyIG1hbmlmZXN0LiBTZWUgbW9yZSBodHRwczovL2dpdGh1Yi5jb20vdG9uLWNvbm5lY3QvZG9jcy9ibG9iL21haW4vcmVxdWVzdHMtcmVzcG9uc2VzLm1kI2FwcC1tYW5pZmVzdCc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBNYW5pZmVzdENvbnRlbnRFcnJvckVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHdhbGxldCBjYW4ndCBnZXQgbWFuaWZlc3QgYnkgcGFzc2VkIG1hbmlmZXN0VXJsLlxuICovXG5jbGFzcyBNYW5pZmVzdE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ01hbmlmZXN0IG5vdCBmb3VuZC4gTWFrZSBzdXJlIHlvdSBhZGRlZCBgdG9uY29ubmVjdC1tYW5pZmVzdC5qc29uYCB0byB0aGUgcm9vdCBvZiB5b3VyIGFwcCBvciBwYXNzZWQgY29ycmVjdCBtYW5pZmVzdFVybC4gU2VlIG1vcmUgaHR0cHM6Ly9naXRodWIuY29tL3Rvbi1jb25uZWN0L2RvY3MvYmxvYi9tYWluL3JlcXVlc3RzLXJlc3BvbnNlcy5tZCNhcHAtbWFuaWZlc3QnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgTWFuaWZlc3ROb3RGb3VuZEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHdhbGxldCBjb25uZWN0aW9uIGNhbGxlZCBidXQgd2FsbGV0IGFscmVhZHkgY29ubmVjdGVkLiBUbyBhdm9pZCB0aGUgZXJyb3IsIGRpc2Nvbm5lY3QgdGhlIHdhbGxldCBiZWZvcmUgZG9pbmcgYSBuZXcgY29ubmVjdGlvbi5cbiAqL1xuY2xhc3MgV2FsbGV0QWxyZWFkeUNvbm5lY3RlZEVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdXYWxsZXQgY29ubmVjdGlvbiBjYWxsZWQgYnV0IHdhbGxldCBhbHJlYWR5IGNvbm5lY3RlZC4gVG8gYXZvaWQgdGhlIGVycm9yLCBkaXNjb25uZWN0IHRoZSB3YWxsZXQgYmVmb3JlIGRvaW5nIGEgbmV3IGNvbm5lY3Rpb24uJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFdhbGxldEFscmVhZHlDb25uZWN0ZWRFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBzZW5kIHRyYW5zYWN0aW9uIG9yIG90aGVyIHByb3RvY29sIG1ldGhvZHMgY2FsbGVkIHdoaWxlIHdhbGxldCBpcyBub3QgY29ubmVjdGVkLlxuICovXG5jbGFzcyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiAnU2VuZCB0cmFuc2FjdGlvbiBvciBvdGhlciBwcm90b2NvbCBtZXRob2RzIGNhbGxlZCB3aGlsZSB3YWxsZXQgaXMgbm90IGNvbm5lY3RlZC4nO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlcmUgaXMgYW4gYXR0ZW1wdCB0byBjb25uZWN0IHRvIHRoZSBpbmplY3RlZCB3YWxsZXQgd2hpbGUgaXQgaXMgbm90IGV4aXN0cyBpbiB0aGUgd2VicGFnZS5cbiAqL1xuY2xhc3MgV2FsbGV0Tm90SW5qZWN0ZWRFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiAnVGhlcmUgaXMgYW4gYXR0ZW1wdCB0byBjb25uZWN0IHRvIHRoZSBpbmplY3RlZCB3YWxsZXQgd2hpbGUgaXQgaXMgbm90IGV4aXN0cyBpbiB0aGUgd2VicGFnZS4nO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgV2FsbGV0Tm90SW5qZWN0ZWRFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiB3YWxsZXQgZG9lc24ndCBzdXBwb3J0IHJlcXVlc3RlZCBmZWF0dXJlIG1ldGhvZC5cbiAqL1xuY2xhc3MgV2FsbGV0Tm90U3VwcG9ydEZlYXR1cmVFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiBcIldhbGxldCBkb2Vzbid0IHN1cHBvcnQgcmVxdWVzdGVkIGZlYXR1cmUgbWV0aG9kLlwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgV2FsbGV0Tm90U3VwcG9ydEZlYXR1cmVFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiB3YWxsZXQgY2FuJ3QgZ2V0IG1hbmlmZXN0IGJ5IHBhc3NlZCBtYW5pZmVzdFVybC5cbiAqL1xuY2xhc3MgV2FsbGV0TWlzc2luZ1JlcXVpcmVkRmVhdHVyZXNFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiAnTWlzc2luZyByZXF1aXJlZCBmZWF0dXJlcy4gWW91IG5lZWQgdG8gdXBkYXRlIHlvdXIgd2FsbGV0Lic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBXYWxsZXRNaXNzaW5nUmVxdWlyZWRGZWF0dXJlc0Vycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1dhbGxldENvbm5lY3Rpb25Tb3VyY2VKUyh2YWx1ZSkge1xuICAgIHJldHVybiAnanNCcmlkZ2VLZXknIGluIHZhbHVlO1xufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHVzZXIgcmVqZWN0cyB0aGUgYWN0aW9uIGluIHRoZSB3YWxsZXQuXG4gKi9cbmNsYXNzIFVzZXJSZWplY3RzRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ1VzZXIgcmVqZWN0cyB0aGUgYWN0aW9uIGluIHRoZSB3YWxsZXQuJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFVzZXJSZWplY3RzRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gcmVxdWVzdCB0byB0aGUgd2FsbGV0IGNvbnRhaW5zIGVycm9ycy5cbiAqL1xuY2xhc3MgQmFkUmVxdWVzdEVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdSZXF1ZXN0IHRvIHRoZSB3YWxsZXQgY29udGFpbnMgZXJyb3JzLic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBCYWRSZXF1ZXN0RXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYXBwIHRyaWVzIHRvIHNlbmQgcnBjIHJlcXVlc3QgdG8gdGhlIGluamVjdGVkIHdhbGxldCB3aGlsZSBub3QgY29ubmVjdGVkLlxuICovXG5jbGFzcyBVbmtub3duQXBwRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ0FwcCB0cmllcyB0byBzZW5kIHJwYyByZXF1ZXN0IHRvIHRoZSBpbmplY3RlZCB3YWxsZXQgd2hpbGUgbm90IGNvbm5lY3RlZC4nO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgVW5rbm93bkFwcEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIGBTdG9yYWdlYCB3YXMgbm90IHNwZWNpZmllZCBpbiB0aGUgYERhcHBNZXRhZGF0YWAgYW5kIGRlZmF1bHQgYGxvY2FsU3RvcmFnZWAgd2FzIG5vdCBkZXRlY3RlZCBpbiB0aGUgTm9kZS5qcyBlbnZpcm9ubWVudC5cbiAqL1xuY2xhc3MgTG9jYWxzdG9yYWdlTm90Rm91bmRFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiAnU3RvcmFnZSB3YXMgbm90IHNwZWNpZmllZCBpbiB0aGUgYERhcHBNZXRhZGF0YWAgYW5kIGRlZmF1bHQgYGxvY2FsU3RvcmFnZWAgd2FzIG5vdCBkZXRlY3RlZCBpbiB0aGUgZW52aXJvbm1lbnQuJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIExvY2Fsc3RvcmFnZU5vdEZvdW5kRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZmV0Y2hpbmcgdGhlIHdhbGxldHMgbGlzdC5cbiAqL1xuY2xhc3MgRmV0Y2hXYWxsZXRzRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIGZldGNoaW5nIHRoZSB3YWxsZXRzIGxpc3QuJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEZldGNoV2FsbGV0c0Vycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHBhc3NlZCBhZGRyZXNzIGlzIGluIGluY29ycmVjdCBmb3JtYXQuXG4gKi9cbmNsYXNzIFdyb25nQWRkcmVzc0Vycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdQYXNzZWQgYWRkcmVzcyBpcyBpbiBpbmNvcnJlY3QgZm9ybWF0Lic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBXcm9uZ0FkZHJlc3NFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBwYXNzZWQgaGV4IGlzIGluIGluY29ycmVjdCBmb3JtYXQuXG4gKi9cbmNsYXNzIFBhcnNlSGV4RXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ1Bhc3NlZCBoZXggaXMgaW4gaW5jb3JyZWN0IGZvcm1hdC4nO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgUGFyc2VIZXhFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBVbmhhbmRlZCB1bmtub3duIGVycm9yLlxuICovXG5jbGFzcyBVbmtub3duRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBVbmtub3duRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbmNvbnN0IGNvbm5lY3RFdmVudEVycm9yc0NvZGVzID0ge1xuICAgIFtDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTLlVOS05PV05fRVJST1JdOiBVbmtub3duRXJyb3IsXG4gICAgW0NPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVMuVVNFUl9SRUpFQ1RTX0VSUk9SXTogVXNlclJlamVjdHNFcnJvcixcbiAgICBbQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFUy5CQURfUkVRVUVTVF9FUlJPUl06IEJhZFJlcXVlc3RFcnJvcixcbiAgICBbQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFUy5VTktOT1dOX0FQUF9FUlJPUl06IFVua25vd25BcHBFcnJvcixcbiAgICBbQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFUy5NQU5JRkVTVF9OT1RfRk9VTkRfRVJST1JdOiBNYW5pZmVzdE5vdEZvdW5kRXJyb3IsXG4gICAgW0NPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVMuTUFOSUZFU1RfQ09OVEVOVF9FUlJPUl06IE1hbmlmZXN0Q29udGVudEVycm9yRXJyb3Jcbn07XG5jbGFzcyBDb25uZWN0RXJyb3JzUGFyc2VyIHtcbiAgICBwYXJzZUVycm9yKGVycm9yKSB7XG4gICAgICAgIGxldCBFcnJvckNvbnN0cnVjdG9yID0gVW5rbm93bkVycm9yO1xuICAgICAgICBpZiAoZXJyb3IuY29kZSBpbiBjb25uZWN0RXZlbnRFcnJvcnNDb2Rlcykge1xuICAgICAgICAgICAgRXJyb3JDb25zdHJ1Y3RvciA9IGNvbm5lY3RFdmVudEVycm9yc0NvZGVzW2Vycm9yLmNvZGVdIHx8IFVua25vd25FcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yQ29uc3RydWN0b3IoZXJyb3IubWVzc2FnZSk7XG4gICAgfVxufVxuY29uc3QgY29ubmVjdEVycm9yc1BhcnNlciA9IG5ldyBDb25uZWN0RXJyb3JzUGFyc2VyKCk7XG5cbmNsYXNzIFJwY1BhcnNlciB7XG4gICAgaXNFcnJvcihyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gJ2Vycm9yJyBpbiByZXNwb25zZTtcbiAgICB9XG59XG5cbmNvbnN0IHNlbmRUcmFuc2FjdGlvbkVycm9ycyA9IHtcbiAgICBbU0VORF9UUkFOU0FDVElPTl9FUlJPUl9DT0RFUy5VTktOT1dOX0VSUk9SXTogVW5rbm93bkVycm9yLFxuICAgIFtTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTLlVTRVJfUkVKRUNUU19FUlJPUl06IFVzZXJSZWplY3RzRXJyb3IsXG4gICAgW1NFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVMuQkFEX1JFUVVFU1RfRVJST1JdOiBCYWRSZXF1ZXN0RXJyb3IsXG4gICAgW1NFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVMuVU5LTk9XTl9BUFBfRVJST1JdOiBVbmtub3duQXBwRXJyb3Jcbn07XG5jbGFzcyBTZW5kVHJhbnNhY3Rpb25QYXJzZXIgZXh0ZW5kcyBScGNQYXJzZXIge1xuICAgIGNvbnZlcnRUb1JwY1JlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWV0aG9kOiAnc2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgIHBhcmFtczogW0pTT04uc3RyaW5naWZ5KHJlcXVlc3QpXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBwYXJzZUFuZFRocm93RXJyb3IocmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IEVycm9yQ29uc3RydWN0b3IgPSBVbmtub3duRXJyb3I7XG4gICAgICAgIGlmIChyZXNwb25zZS5lcnJvci5jb2RlIGluIHNlbmRUcmFuc2FjdGlvbkVycm9ycykge1xuICAgICAgICAgICAgRXJyb3JDb25zdHJ1Y3RvciA9IHNlbmRUcmFuc2FjdGlvbkVycm9yc1tyZXNwb25zZS5lcnJvci5jb2RlXSB8fCBVbmtub3duRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yQ29uc3RydWN0b3IocmVzcG9uc2UuZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnZlcnRGcm9tUnBjUmVzcG9uc2UocnBjUmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJvYzogcnBjUmVzcG9uc2UucmVzdWx0XG4gICAgICAgIH07XG4gICAgfVxufVxuY29uc3Qgc2VuZFRyYW5zYWN0aW9uUGFyc2VyID0gbmV3IFNlbmRUcmFuc2FjdGlvblBhcnNlcigpO1xuXG5jb25zdCBzaWduRGF0YUVycm9ycyA9IHtcbiAgICBbU0lHTl9EQVRBX0VSUk9SX0NPREVTLlVOS05PV05fRVJST1JdOiBVbmtub3duRXJyb3IsXG4gICAgW1NJR05fREFUQV9FUlJPUl9DT0RFUy5VU0VSX1JFSkVDVFNfRVJST1JdOiBVc2VyUmVqZWN0c0Vycm9yLFxuICAgIFtTSUdOX0RBVEFfRVJST1JfQ09ERVMuQkFEX1JFUVVFU1RfRVJST1JdOiBCYWRSZXF1ZXN0RXJyb3IsXG4gICAgW1NJR05fREFUQV9FUlJPUl9DT0RFUy5VTktOT1dOX0FQUF9FUlJPUl06IFVua25vd25BcHBFcnJvclxufTtcbmNsYXNzIFNpZ25EYXRhUGFyc2VyIGV4dGVuZHMgUnBjUGFyc2VyIHtcbiAgICBjb252ZXJ0VG9ScGNSZXF1ZXN0KHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ3NpZ25EYXRhJyxcbiAgICAgICAgICAgIHBhcmFtczogW0pTT04uc3RyaW5naWZ5KHBheWxvYWQpXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBwYXJzZUFuZFRocm93RXJyb3IocmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IEVycm9yQ29uc3RydWN0b3IgPSBVbmtub3duRXJyb3I7XG4gICAgICAgIGlmIChyZXNwb25zZS5lcnJvci5jb2RlIGluIHNpZ25EYXRhRXJyb3JzKSB7XG4gICAgICAgICAgICBFcnJvckNvbnN0cnVjdG9yID0gc2lnbkRhdGFFcnJvcnNbcmVzcG9uc2UuZXJyb3IuY29kZV0gfHwgVW5rbm93bkVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvckNvbnN0cnVjdG9yKHJlc3BvbnNlLmVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb252ZXJ0RnJvbVJwY1Jlc3BvbnNlKHJwY1Jlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBycGNSZXNwb25zZS5yZXN1bHQ7XG4gICAgfVxufVxuY29uc3Qgc2lnbkRhdGFQYXJzZXIgPSBuZXcgU2lnbkRhdGFQYXJzZXIoKTtcblxuY2xhc3MgSHR0cEJyaWRnZUdhdGV3YXlTdG9yYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihzdG9yYWdlLCBicmlkZ2VVcmwpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICAgICAgdGhpcy5zdG9yZUtleSA9ICd0b24tY29ubmVjdC1zdG9yYWdlX2h0dHAtYnJpZGdlLWdhdGV3YXk6OicgKyBicmlkZ2VVcmw7XG4gICAgfVxuICAgIHN0b3JlTGFzdEV2ZW50SWQobGFzdEV2ZW50SWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnN0b3JlS2V5LCBsYXN0RXZlbnRJZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVMYXN0RXZlbnRJZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnN0b3JlS2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldExhc3RFdmVudElkKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkID0geWllbGQgdGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yZUtleSk7XG4gICAgICAgICAgICBpZiAoIXN0b3JlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0b3JlZDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVVcmxMYXN0U2xhc2godXJsKSB7XG4gICAgaWYgKHVybC5zbGljZSgtMSkgPT09ICcvJykge1xuICAgICAgICByZXR1cm4gdXJsLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn1cbmZ1bmN0aW9uIGFkZFBhdGhUb1VybCh1cmwsIHBhdGgpIHtcbiAgICByZXR1cm4gcmVtb3ZlVXJsTGFzdFNsYXNoKHVybCkgKyAnLycgKyBwYXRoO1xufVxuZnVuY3Rpb24gaXNUZWxlZ3JhbVVybChsaW5rKSB7XG4gICAgaWYgKCFsaW5rKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChsaW5rKTtcbiAgICByZXR1cm4gdXJsLnByb3RvY29sID09PSAndGc6JyB8fCB1cmwuaG9zdG5hbWUgPT09ICd0Lm1lJztcbn1cbmZ1bmN0aW9uIGVuY29kZVRlbGVncmFtVXJsUGFyYW1ldGVycyhwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIHBhcmFtZXRlcnNcbiAgICAgICAgLnJlcGxhY2VBbGwoJy4nLCAnJTJFJylcbiAgICAgICAgLnJlcGxhY2VBbGwoJy0nLCAnJTJEJylcbiAgICAgICAgLnJlcGxhY2VBbGwoJ18nLCAnJTVGJylcbiAgICAgICAgLnJlcGxhY2VBbGwoJyYnLCAnLScpXG4gICAgICAgIC5yZXBsYWNlQWxsKCc9JywgJ19fJylcbiAgICAgICAgLnJlcGxhY2VBbGwoJyUnLCAnLS0nKTtcbn1cblxuLyoqXG4gKiBEZWxheXMgdGhlIGV4ZWN1dGlvbiBvZiBjb2RlIGZvciBhIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSB0aGUgZXhlY3V0aW9uLlxuICogQHBhcmFtIHtEZWxheU9wdGlvbnN9IFtvcHRpb25zXSAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIGRlbGF5LlxuICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgc3BlY2lmaWVkIGRlbGF5LCBvciByZWplY3RzIGlmIHRoZSBkZWxheSBpcyBhYm9ydGVkLlxuICovXG5mdW5jdGlvbiBkZWxheSh0aW1lb3V0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IFRvbkNvbm5lY3RFcnJvcignRGVsYXkgYWJvcnRlZCcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoKSwgdGltZW91dCk7XG4gICAgICAgICAgICAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUb25Db25uZWN0RXJyb3IoJ0RlbGF5IGFib3J0ZWQnKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBBYm9ydENvbnRyb2xsZXIgaW5zdGFuY2Ugd2l0aCBhbiBvcHRpb25hbCBBYm9ydFNpZ25hbC5cbiAqXG4gKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBbc2lnbmFsXSAtIEFuIG9wdGlvbmFsIEFib3J0U2lnbmFsIHRvIHVzZSBmb3IgYWJvcnRpbmcgdGhlIGNvbnRyb2xsZXIuXG4gKiBAcmV0dXJucyB7QWJvcnRDb250cm9sbGVyfSAtIEFuIGluc3RhbmNlIG9mIEFib3J0Q29udHJvbGxlci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQWJvcnRDb250cm9sbGVyKHNpZ25hbCkge1xuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBpZiAoc2lnbmFsID09PSBudWxsIHx8IHNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzaWduYWwgPT09IG51bGwgfHwgc2lnbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYWJvcnRDb250cm9sbGVyO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIGNhbGwgdG9uIGFwaSB1bnRpbCB3ZSBnZXQgcmVzcG9uc2UuXG4gKiBCZWNhdXNlIHRvbiBuZXR3b3JrIGlzIHByZXR0eSB1bnN0YWJsZSB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSByZXNwb25zZSBpcyBmaW5hbC5cbiAqIEBwYXJhbSB7VH0gZm4gLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge0NhbGxGb3JTdWNjZXNzT3B0aW9uc30gW29wdGlvbnNdIC0gb3B0aW9uYWwgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNhbGxGb3JTdWNjZXNzKGZuLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBhdHRlbXB0cyA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRlbXB0cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTA7XG4gICAgICAgIGNvbnN0IGRlbGF5TXMgPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVsYXlNcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMjAwO1xuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCk7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoYEV4cGVjdGVkIGEgZnVuY3Rpb24sIGdvdCAke3R5cGVvZiBmbn1gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBsYXN0RXJyb3I7XG4gICAgICAgIHdoaWxlIChpIDwgYXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKGBBYm9ydGVkIGFmdGVyIGF0dGVtcHRzICR7aX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGZuKHsgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGxhc3RFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBhdHRlbXB0cykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBkZWxheShkZWxheU1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbGFzdEVycm9yO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBsb2dEZWJ1ZyguLi5hcmdzKSB7XG4gICAge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnW1RPTl9DT05ORUNUX1NES10nLCAuLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGxvZ0Vycm9yKC4uLmFyZ3MpIHtcbiAgICB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVE9OX0NPTk5FQ1RfU0RLXScsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgfVxufVxuZnVuY3Rpb24gbG9nV2FybmluZyguLi5hcmdzKSB7XG4gICAge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbVE9OX0NPTk5FQ1RfU0RLXScsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJlc291cmNlLlxuICpcbiAqIEB0ZW1wbGF0ZSBUIC0gVGhlIHR5cGUgb2YgdGhlIHJlc291cmNlLlxuICogQHRlbXBsYXRlIEFyZ3MgLSBUaGUgdHlwZSBvZiB0aGUgYXJndW1lbnRzIGZvciBjcmVhdGluZyB0aGUgcmVzb3VyY2UuXG4gKlxuICogQHBhcmFtIHsoLi4uYXJnczogQXJncykgPT4gUHJvbWlzZTxUPn0gY3JlYXRlRm4gLSBBIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGUgcmVzb3VyY2UuXG4gKiBAcGFyYW0geyhyZXNvdXJjZTogVCkgPT4gUHJvbWlzZTx2b2lkPn0gW2Rpc3Bvc2VGbl0gLSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IGRpc3Bvc2VzIHRoZSByZXNvdXJjZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVzb3VyY2UoY3JlYXRlRm4sIGRpc3Bvc2VGbikge1xuICAgIGxldCBjdXJyZW50UmVzb3VyY2UgPSBudWxsO1xuICAgIGxldCBjdXJyZW50QXJncyA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRQcm9taXNlID0gbnVsbDtcbiAgICBsZXQgY3VycmVudFNpZ25hbCA9IG51bGw7XG4gICAgbGV0IGFib3J0Q29udHJvbGxlciA9IG51bGw7XG4gICAgLy8gY3JlYXRlIGEgbmV3IHJlc291cmNlXG4gICAgY29uc3QgY3JlYXRlID0gKHNpZ25hbCwgLi4uYXJncykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjdXJyZW50U2lnbmFsID0gc2lnbmFsICE9PSBudWxsICYmIHNpZ25hbCAhPT0gdm9pZCAwID8gc2lnbmFsIDogbnVsbDtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyID09PSBudWxsIHx8IGFib3J0Q29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIGFib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcihzaWduYWwpO1xuICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdSZXNvdXJjZSBjcmVhdGlvbiB3YXMgYWJvcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdzID0gYXJncyAhPT0gbnVsbCAmJiBhcmdzICE9PSB2b2lkIDAgPyBhcmdzIDogbnVsbDtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IGNyZWF0ZUZuKGFib3J0Q29udHJvbGxlci5zaWduYWwsIC4uLmFyZ3MpO1xuICAgICAgICBjdXJyZW50UHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIGNvbnN0IHJlc291cmNlID0geWllbGQgcHJvbWlzZTtcbiAgICAgICAgaWYgKGN1cnJlbnRQcm9taXNlICE9PSBwcm9taXNlICYmIHJlc291cmNlICE9PSBjdXJyZW50UmVzb3VyY2UpIHtcbiAgICAgICAgICAgIHlpZWxkIGRpc3Bvc2VGbihyZXNvdXJjZSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdSZXNvdXJjZSBjcmVhdGlvbiB3YXMgYWJvcnRlZCBieSBhIG5ldyByZXNvdXJjZSBjcmVhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRSZXNvdXJjZSA9IHJlc291cmNlO1xuICAgICAgICByZXR1cm4gY3VycmVudFJlc291cmNlO1xuICAgIH0pO1xuICAgIC8vIGdldCB0aGUgY3VycmVudCByZXNvdXJjZVxuICAgIGNvbnN0IGN1cnJlbnQgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBjdXJyZW50UmVzb3VyY2UgIT09IG51bGwgJiYgY3VycmVudFJlc291cmNlICE9PSB2b2lkIDAgPyBjdXJyZW50UmVzb3VyY2UgOiBudWxsO1xuICAgIH07XG4gICAgLy8gZGlzcG9zZSB0aGUgY3VycmVudCByZXNvdXJjZVxuICAgIGNvbnN0IGRpc3Bvc2UgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNvdXJjZSA9IGN1cnJlbnRSZXNvdXJjZTtcbiAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gY3VycmVudFByb21pc2U7XG4gICAgICAgICAgICBjdXJyZW50UHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGxTZXR0bGVkKFtcbiAgICAgICAgICAgICAgICByZXNvdXJjZSA/IGRpc3Bvc2VGbihyZXNvdXJjZSkgOiBQcm9taXNlLnJlc29sdmUoKSxcbiAgICAgICAgICAgICAgICBwcm9taXNlID8gZGlzcG9zZUZuKHlpZWxkIHByb21pc2UpIDogUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9KTtcbiAgICAvLyByZWNyZWF0ZSB0aGUgY3VycmVudCByZXNvdXJjZVxuICAgIGNvbnN0IHJlY3JlYXRlID0gKGRlbGF5TXMpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcmVzb3VyY2UgPSBjdXJyZW50UmVzb3VyY2U7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBjdXJyZW50UHJvbWlzZTtcbiAgICAgICAgY29uc3QgYXJncyA9IGN1cnJlbnRBcmdzO1xuICAgICAgICBjb25zdCBzaWduYWwgPSBjdXJyZW50U2lnbmFsO1xuICAgICAgICB5aWVsZCBkZWxheShkZWxheU1zKTtcbiAgICAgICAgaWYgKHJlc291cmNlID09PSBjdXJyZW50UmVzb3VyY2UgJiZcbiAgICAgICAgICAgIHByb21pc2UgPT09IGN1cnJlbnRQcm9taXNlICYmXG4gICAgICAgICAgICBhcmdzID09PSBjdXJyZW50QXJncyAmJlxuICAgICAgICAgICAgc2lnbmFsID09PSBjdXJyZW50U2lnbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgY3JlYXRlKGN1cnJlbnRTaWduYWwsIC4uLihhcmdzICE9PSBudWxsICYmIGFyZ3MgIT09IHZvaWQgMCA/IGFyZ3MgOiBbXSkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1Jlc291cmNlIHJlY3JlYXRpb24gd2FzIGFib3J0ZWQgYnkgYSBuZXcgcmVzb3VyY2UgY3JlYXRpb24nKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGUsXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIGRpc3Bvc2UsXG4gICAgICAgIHJlY3JlYXRlXG4gICAgfTtcbn1cblxuLyoqXG4gKiBFeGVjdXRlcyBhIGZ1bmN0aW9uIGFuZCBwcm92aWRlcyBkZWZlcnJlZCBiZWhhdmlvciwgYWxsb3dpbmcgZm9yIGEgdGltZW91dCBhbmQgYWJvcnQgZnVuY3Rpb25hbGl0eS5cbiAqXG4gKiBAcGFyYW0ge0RlZmVycmFibGU8VD59IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUuIEl0IHNob3VsZCByZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZGVzaXJlZCByZXN1bHQuXG4gKiBAcGFyYW0ge0RlZmVyT3B0aW9uc30gb3B0aW9ucyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIGRlZmVyIGJlaGF2aW9yLlxuICogQHJldHVybnMge1Byb21pc2U8VD59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBleGVjdXRlZCBmdW5jdGlvbiwgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yIGlmIGl0IHRpbWVzIG91dCBvciBpcyBhYm9ydGVkLlxuICovXG5mdW5jdGlvbiB0aW1lb3V0KGZuLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGltZW91dCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50aW1lb3V0O1xuICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWw7XG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKHNpZ25hbCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBUb25Db25uZWN0RXJyb3IoJ09wZXJhdGlvbiBhYm9ydGVkJykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdGltZW91dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVG9uQ29ubmVjdEVycm9yKGBUaW1lb3V0IGFmdGVyICR7dGltZW91dH1tc2ApKTtcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgVG9uQ29ubmVjdEVycm9yKCdPcGVyYXRpb24gYWJvcnRlZCcpKTtcbiAgICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBkZWZlck9wdGlvbnMgPSB7IHRpbWVvdXQsIGFib3J0OiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsIH07XG4gICAgICAgIHlpZWxkIGZuKCguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIHJlc29sdmUoLi4uYXJncyk7XG4gICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH0sIGRlZmVyT3B0aW9ucyk7XG4gICAgfSkpO1xufVxuXG5jbGFzcyBCcmlkZ2VHYXRld2F5IHtcbiAgICBjb25zdHJ1Y3RvcihzdG9yYWdlLCBicmlkZ2VVcmwsIHNlc3Npb25JZCwgbGlzdGVuZXIsIGVycm9yc0xpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuYnJpZGdlVXJsID0gYnJpZGdlVXJsO1xuICAgICAgICB0aGlzLnNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLmVycm9yc0xpc3RlbmVyID0gZXJyb3JzTGlzdGVuZXI7XG4gICAgICAgIHRoaXMuc3NlUGF0aCA9ICdldmVudHMnO1xuICAgICAgICB0aGlzLnBvc3RQYXRoID0gJ21lc3NhZ2UnO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdE1lc3NhZ2UgPSAnaGVhcnRiZWF0JztcbiAgICAgICAgdGhpcy5kZWZhdWx0VHRsID0gMzAwO1xuICAgICAgICB0aGlzLmRlZmF1bHRSZWNvbm5lY3REZWxheSA9IDIwMDA7XG4gICAgICAgIHRoaXMuZGVmYXVsdFJlc2VuZERlbGF5ID0gNTAwMDtcbiAgICAgICAgdGhpcy5ldmVudFNvdXJjZSA9IGNyZWF0ZVJlc291cmNlKChzaWduYWwsIG9wZW5pbmdEZWFkbGluZU1TKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFNvdXJjZUNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBicmlkZ2VVcmw6IHRoaXMuYnJpZGdlVXJsLFxuICAgICAgICAgICAgICAgIHNzZVBhdGg6IHRoaXMuc3NlUGF0aCxcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIGJyaWRnZUdhdGV3YXlTdG9yYWdlOiB0aGlzLmJyaWRnZUdhdGV3YXlTdG9yYWdlLFxuICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcjogdGhpcy5lcnJvcnNIYW5kbGVyLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXI6IHRoaXMubWVzc2FnZXNIYW5kbGVyLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBzaWduYWwsXG4gICAgICAgICAgICAgICAgb3BlbmluZ0RlYWRsaW5lTVM6IG9wZW5pbmdEZWFkbGluZU1TXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNyZWF0ZUV2ZW50U291cmNlKGV2ZW50U291cmNlQ29uZmlnKTtcbiAgICAgICAgfSksIChyZXNvdXJjZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmVzb3VyY2UuY2xvc2UoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmJyaWRnZUdhdGV3YXlTdG9yYWdlID0gbmV3IEh0dHBCcmlkZ2VHYXRld2F5U3RvcmFnZShzdG9yYWdlLCBicmlkZ2VVcmwpO1xuICAgIH1cbiAgICBnZXQgaXNSZWFkeSgpIHtcbiAgICAgICAgY29uc3QgZXZlbnRTb3VyY2UgPSB0aGlzLmV2ZW50U291cmNlLmN1cnJlbnQoKTtcbiAgICAgICAgcmV0dXJuIChldmVudFNvdXJjZSA9PT0gbnVsbCB8fCBldmVudFNvdXJjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZlbnRTb3VyY2UucmVhZHlTdGF0ZSkgPT09IEV2ZW50U291cmNlLk9QRU47XG4gICAgfVxuICAgIGdldCBpc0Nsb3NlZCgpIHtcbiAgICAgICAgY29uc3QgZXZlbnRTb3VyY2UgPSB0aGlzLmV2ZW50U291cmNlLmN1cnJlbnQoKTtcbiAgICAgICAgcmV0dXJuIChldmVudFNvdXJjZSA9PT0gbnVsbCB8fCBldmVudFNvdXJjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZlbnRTb3VyY2UucmVhZHlTdGF0ZSkgIT09IEV2ZW50U291cmNlLk9QRU47XG4gICAgfVxuICAgIGdldCBpc0Nvbm5lY3RpbmcoKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50U291cmNlID0gdGhpcy5ldmVudFNvdXJjZS5jdXJyZW50KCk7XG4gICAgICAgIHJldHVybiAoZXZlbnRTb3VyY2UgPT09IG51bGwgfHwgZXZlbnRTb3VyY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50U291cmNlLnJlYWR5U3RhdGUpID09PSBFdmVudFNvdXJjZS5DT05ORUNUSU5HO1xuICAgIH1cbiAgICByZWdpc3RlclNlc3Npb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5ldmVudFNvdXJjZS5jcmVhdGUob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wZW5pbmdEZWFkbGluZU1TKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmQobWVzc2FnZSwgcmVjZWl2ZXIsIHRvcGljLCB0dGxPck9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGRlcHJlY2F0ZWQgbWV0aG9kXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIHR0bE9yT3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnR0bCA9IHR0bE9yT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudHRsID0gdHRsT3JPcHRpb25zID09PSBudWxsIHx8IHR0bE9yT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHRsT3JPcHRpb25zLnR0bDtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbCA9IHR0bE9yT3B0aW9ucyA9PT0gbnVsbCB8fCB0dGxPck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR0bE9yT3B0aW9ucy5zaWduYWw7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5hdHRlbXB0cyA9IHR0bE9yT3B0aW9ucyA9PT0gbnVsbCB8fCB0dGxPck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR0bE9yT3B0aW9ucy5hdHRlbXB0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYWRkUGF0aFRvVXJsKHRoaXMuYnJpZGdlVXJsLCB0aGlzLnBvc3RQYXRoKSk7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnY2xpZW50X2lkJywgdGhpcy5zZXNzaW9uSWQpO1xuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3RvJywgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3R0bCcsICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnR0bCkgfHwgdGhpcy5kZWZhdWx0VHRsKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCd0b3BpYycsIHRvcGljKTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBCYXNlNjQuZW5jb2RlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgeWllbGQgY2FsbEZvclN1Y2Nlc3MoKG9wdGlvbnMpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucG9zdCh1cmwsIGJvZHksIG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoYEJyaWRnZSBzZW5kIGZhaWxlZCwgc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdHM6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRlbXB0cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICAgICAgZGVsYXlNczogdGhpcy5kZWZhdWx0UmVzZW5kRGVsYXksXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLmV2ZW50U291cmNlLmRpc3Bvc2UoKS5jYXRjaChlID0+IGxvZ0Vycm9yKGBCcmlkZ2UgcGF1c2UgZmFpbGVkLCAke2V9YCkpO1xuICAgIH1cbiAgICB1blBhdXNlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgUkVDUkVBVEVfV0lUSE9VVF9ERUxBWSA9IDA7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmV2ZW50U291cmNlLnJlY3JlYXRlKFJFQ1JFQVRFX1dJVEhPVVRfREVMQVkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmV2ZW50U291cmNlLmRpc3Bvc2UoKS5jYXRjaChlID0+IGxvZ0Vycm9yKGBCcmlkZ2UgY2xvc2UgZmFpbGVkLCAke2V9YCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIH1cbiAgICBzZXRFcnJvcnNMaXN0ZW5lcihlcnJvcnNMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmVycm9yc0xpc3RlbmVyID0gZXJyb3JzTGlzdGVuZXI7XG4gICAgfVxuICAgIHBvc3QodXJsLCBib2R5LCBzaWduYWwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAncG9zdCcsXG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IHNpZ25hbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcihgQnJpZGdlIHNlbmQgZmFpbGVkLCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlcnJvcnNIYW5kbGVyKGV2ZW50U291cmNlLCBlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICBldmVudFNvdXJjZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ0JyaWRnZSBlcnJvciwgZmFpbGVkIHRvIGNvbm5lY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yc0xpc3RlbmVyKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBldmVudFNvdXJjZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKGBCcmlkZ2UgcmVjb25uZWN0aW5nLCAke3RoaXMuZGVmYXVsdFJlY29ubmVjdERlbGF5fW1zIGRlbGF5YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZXZlbnRTb3VyY2UucmVjcmVhdGUodGhpcy5kZWZhdWx0UmVjb25uZWN0RGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignQnJpZGdlIGVycm9yLCB1bmtub3duIHN0YXRlJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtZXNzYWdlc0hhbmRsZXIoZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGUuZGF0YSA9PT0gdGhpcy5oZWFydGJlYXRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgdGhpcy5icmlkZ2VHYXRld2F5U3RvcmFnZS5zdG9yZUxhc3RFdmVudElkKGUubGFzdEV2ZW50SWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYnJpZGdlSW5jb21pbmdNZXNzYWdlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBicmlkZ2VJbmNvbWluZ01lc3NhZ2UgPSBKU09OLnBhcnNlKGUuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoYEJyaWRnZSBtZXNzYWdlIHBhcnNlIGZhaWxlZCwgbWVzc2FnZSAke2UuZGF0YX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXIoYnJpZGdlSW5jb21pbmdNZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGV2ZW50IHNvdXJjZS5cbiAqIEBwYXJhbSB7Q3JlYXRlRXZlbnRTb3VyY2VDb25maWd9IGNvbmZpZyAtIENvbmZpZ3VyYXRpb24gZm9yIGNyZWF0aW5nIGFuIGV2ZW50IHNvdXJjZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXZlbnRTb3VyY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIHlpZWxkIHRpbWVvdXQoKHJlc29sdmUsIHJlamVjdCwgZGVmZXJPcHRpb25zKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIoZGVmZXJPcHRpb25zLnNpZ25hbCk7XG4gICAgICAgICAgICBjb25zdCBzaWduYWwgPSBhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUb25Db25uZWN0RXJyb3IoJ0JyaWRnZSBjb25uZWN0aW9uIGFib3J0ZWQnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChhZGRQYXRoVG9VcmwoY29uZmlnLmJyaWRnZVVybCwgY29uZmlnLnNzZVBhdGgpKTtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdjbGllbnRfaWQnLCBjb25maWcuc2Vzc2lvbklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RFdmVudElkID0geWllbGQgY29uZmlnLmJyaWRnZUdhdGV3YXlTdG9yYWdlLmdldExhc3RFdmVudElkKCk7XG4gICAgICAgICAgICBpZiAobGFzdEV2ZW50SWQpIHtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnbGFzdF9ldmVudF9pZCcsIGxhc3RFdmVudElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVG9uQ29ubmVjdEVycm9yKCdCcmlkZ2UgY29ubmVjdGlvbiBhYm9ydGVkJykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50U291cmNlID0gbmV3IEV2ZW50U291cmNlKHVybC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGV2ZW50U291cmNlLm9uZXJyb3IgPSAocmVhc29uKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVG9uQ29ubmVjdEVycm9yKCdCcmlkZ2UgY29ubmVjdGlvbiBhYm9ydGVkJykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0luc3RhbmNlID0geWllbGQgY29uZmlnLmVycm9ySGFuZGxlcihldmVudFNvdXJjZSwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luc3RhbmNlICE9PSBldmVudFNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTb3VyY2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3SW5zdGFuY2UgJiYgbmV3SW5zdGFuY2UgIT09IGV2ZW50U291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5ld0luc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBldmVudFNvdXJjZS5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U291cmNlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVG9uQ29ubmVjdEVycm9yKCdCcmlkZ2UgY29ubmVjdGlvbiBhYm9ydGVkJykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnRTb3VyY2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV2ZW50U291cmNlLm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudFNvdXJjZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFRvbkNvbm5lY3RFcnJvcignQnJpZGdlIGNvbm5lY3Rpb24gYWJvcnRlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25maWcubWVzc2FnZUhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIChfYSA9IGNvbmZpZy5zaWduYWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudFNvdXJjZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVG9uQ29ubmVjdEVycm9yKCdCcmlkZ2UgY29ubmVjdGlvbiBhYm9ydGVkJykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLCB7IHRpbWVvdXQ6IGNvbmZpZy5vcGVuaW5nRGVhZGxpbmVNUywgc2lnbmFsOiBjb25maWcuc2lnbmFsIH0pO1xuICAgIH0pO1xufVxuXG5jb25zdCBDT05ORUNUSU9OX0hUVFBfRVhQSVJBVElPTl9USU1FID0gNSAqIDYwICogMTAwMDtcbmZ1bmN0aW9uIGlzUGVuZGluZ0Nvbm5lY3Rpb25IdHRwKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gISgnY29ubmVjdEV2ZW50JyBpbiBjb25uZWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGlzUGVuZGluZ0Nvbm5lY3Rpb25IdHRwUmF3KGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gISgnY29ubmVjdEV2ZW50JyBpbiBjb25uZWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGlzRXhwaXJlZFBlbmRpbmdDb25uZWN0aW9uSHR0cFJhdyhjb25uZWN0aW9uKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gKChfYSA9IGNvbm5lY3Rpb24uY3JlYXRlZEF0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSA+IENPTk5FQ1RJT05fSFRUUF9FWFBJUkFUSU9OX1RJTUU7XG59XG5cbmNsYXNzIEJyaWRnZUNvbm5lY3Rpb25TdG9yYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihzdG9yYWdlKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgICAgIHRoaXMuc3RvcmVLZXkgPSAndG9uLWNvbm5lY3Qtc3RvcmFnZV9icmlkZ2UtY29ubmVjdGlvbic7XG4gICAgfVxuICAgIHN0b3JlQ29ubmVjdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi50eXBlID09PSAnaW5qZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmVLZXksIEpTT04uc3RyaW5naWZ5KGNvbm5lY3Rpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQZW5kaW5nQ29ubmVjdGlvbkh0dHAoY29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYXdTZXNzaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uS2V5UGFpcjogY29ubmVjdGlvbi5zZXNzaW9uLnNlc3Npb25DcnlwdG8uc3RyaW5naWZ5S2V5cGFpcigpLFxuICAgICAgICAgICAgICAgICAgICB3YWxsZXRQdWJsaWNLZXk6IGNvbm5lY3Rpb24uc2Vzc2lvbi53YWxsZXRQdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICAgIGJyaWRnZVVybDogY29ubmVjdGlvbi5zZXNzaW9uLmJyaWRnZVVybFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3Q29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2h0dHAnLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0RXZlbnQ6IGNvbm5lY3Rpb24uY29ubmVjdEV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uOiByYXdTZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBsYXN0V2FsbGV0RXZlbnRJZDogY29ubmVjdGlvbi5sYXN0V2FsbGV0RXZlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJwY1JlcXVlc3RJZDogY29ubmVjdGlvbi5uZXh0UnBjUmVxdWVzdElkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yZUtleSwgSlNPTi5zdHJpbmdpZnkocmF3Q29ubmVjdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmF3Q29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHR0cCcsXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvblNvdXJjZTogY29ubmVjdGlvbi5jb25uZWN0aW9uU291cmNlLFxuICAgICAgICAgICAgICAgIHNlc3Npb25DcnlwdG86IGNvbm5lY3Rpb24uc2Vzc2lvbkNyeXB0by5zdHJpbmdpZnlLZXlwYWlyKCksXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmVLZXksIEpTT04uc3RyaW5naWZ5KHJhd0Nvbm5lY3Rpb24pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZUNvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5zdG9yZUtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb25uZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkID0geWllbGQgdGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yZUtleSk7XG4gICAgICAgICAgICBpZiAoIXN0b3JlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLnR5cGUgPT09ICdpbmplY3RlZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQZW5kaW5nQ29ubmVjdGlvbkh0dHBSYXcoY29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uQ3J5cHRvID0gbmV3IFNlc3Npb25DcnlwdG8oY29ubmVjdGlvbi5zZXNzaW9uLnNlc3Npb25LZXlQYWlyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaHR0cCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RFdmVudDogY29ubmVjdGlvbi5jb25uZWN0RXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RXYWxsZXRFdmVudElkOiBjb25uZWN0aW9uLmxhc3RXYWxsZXRFdmVudElkLFxuICAgICAgICAgICAgICAgICAgICBuZXh0UnBjUmVxdWVzdElkOiBjb25uZWN0aW9uLm5leHRScGNSZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25DcnlwdG8sXG4gICAgICAgICAgICAgICAgICAgICAgICBicmlkZ2VVcmw6IGNvbm5lY3Rpb24uc2Vzc2lvbi5icmlkZ2VVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXRQdWJsaWNLZXk6IGNvbm5lY3Rpb24uc2Vzc2lvbi53YWxsZXRQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNFeHBpcmVkUGVuZGluZ0Nvbm5lY3Rpb25IdHRwUmF3KGNvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5yZW1vdmVDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdodHRwJyxcbiAgICAgICAgICAgICAgICBzZXNzaW9uQ3J5cHRvOiBuZXcgU2Vzc2lvbkNyeXB0byhjb25uZWN0aW9uLnNlc3Npb25DcnlwdG8pLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Tb3VyY2U6IGNvbm5lY3Rpb24uY29ubmVjdGlvblNvdXJjZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEh0dHBDb25uZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHlpZWxkIHRoaXMuZ2V0Q29ubmVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignVHJ5aW5nIHRvIHJlYWQgSFRUUCBjb25uZWN0aW9uIHNvdXJjZSB3aGlsZSBub3RoaW5nIGlzIHN0b3JlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24udHlwZSA9PT0gJ2luamVjdGVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1RyeWluZyB0byByZWFkIEhUVFAgY29ubmVjdGlvbiBzb3VyY2Ugd2hpbGUgaW5qZWN0ZWQgY29ubmVjdGlvbiBpcyBzdG9yZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SHR0cFBlbmRpbmdDb25uZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHlpZWxkIHRoaXMuZ2V0Q29ubmVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignVHJ5aW5nIHRvIHJlYWQgSFRUUCBjb25uZWN0aW9uIHNvdXJjZSB3aGlsZSBub3RoaW5nIGlzIHN0b3JlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24udHlwZSA9PT0gJ2luamVjdGVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1RyeWluZyB0byByZWFkIEhUVFAgY29ubmVjdGlvbiBzb3VyY2Ugd2hpbGUgaW5qZWN0ZWQgY29ubmVjdGlvbiBpcyBzdG9yZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQZW5kaW5nQ29ubmVjdGlvbkh0dHAoY29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdUcnlpbmcgdG8gcmVhZCBIVFRQLXBlbmRpbmcgY29ubmVjdGlvbiB3aGlsZSBodHRwIGNvbm5lY3Rpb24gaXMgc3RvcmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEluamVjdGVkQ29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB5aWVsZCB0aGlzLmdldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1RyeWluZyB0byByZWFkIEluamVjdGVkIGJyaWRnZSBjb25uZWN0aW9uIHNvdXJjZSB3aGlsZSBub3RoaW5nIGlzIHN0b3JlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChjb25uZWN0aW9uID09PSBudWxsIHx8IGNvbm5lY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24udHlwZSkgPT09ICdodHRwJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1RyeWluZyB0byByZWFkIEluamVjdGVkIGJyaWRnZSBjb25uZWN0aW9uIHNvdXJjZSB3aGlsZSBIVFRQIGNvbm5lY3Rpb24gaXMgc3RvcmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3JlZENvbm5lY3Rpb25UeXBlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkID0geWllbGQgdGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yZUtleSk7XG4gICAgICAgICAgICBpZiAoIXN0b3JlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLnR5cGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdG9yZUxhc3RXYWxsZXRFdmVudElkKGlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgdGhpcy5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbiAmJiBjb25uZWN0aW9uLnR5cGUgPT09ICdodHRwJyAmJiAhaXNQZW5kaW5nQ29ubmVjdGlvbkh0dHAoY29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmxhc3RXYWxsZXRFdmVudElkID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmVDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TGFzdFdhbGxldEV2ZW50SWQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgdGhpcy5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbiAmJiAnbGFzdFdhbGxldEV2ZW50SWQnIGluIGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5sYXN0V2FsbGV0RXZlbnRJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbmNyZWFzZU5leHRScGNSZXF1ZXN0SWQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgdGhpcy5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbiAmJiAnbmV4dFJwY1JlcXVlc3RJZCcgaW4gY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RJZCA9IGNvbm5lY3Rpb24ubmV4dFJwY1JlcXVlc3RJZCB8fCAwO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ubmV4dFJwY1JlcXVlc3RJZCA9IGxhc3RJZCArIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmVDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TmV4dFJwY1JlcXVlc3RJZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB5aWVsZCB0aGlzLmdldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uICYmICduZXh0UnBjUmVxdWVzdElkJyBpbiBjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24ubmV4dFJwY1JlcXVlc3RJZCB8fCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY29uc3QgUFJPVE9DT0xfVkVSU0lPTiA9IDI7XG5cbmNsYXNzIEJyaWRnZVByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzdG9yYWdlLCB3YWxsZXRDb25uZWN0aW9uU291cmNlKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgICAgIHRoaXMud2FsbGV0Q29ubmVjdGlvblNvdXJjZSA9IHdhbGxldENvbm5lY3Rpb25Tb3VyY2U7XG4gICAgICAgIHRoaXMudHlwZSA9ICdodHRwJztcbiAgICAgICAgdGhpcy5zdGFuZGFyZFVuaXZlcnNhbExpbmsgPSAndGM6Ly8nO1xuICAgICAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5nYXRld2F5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nR2F0ZXdheXMgPSBbXTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5kZWZhdWx0T3BlbmluZ0RlYWRsaW5lTVMgPSAxMjAwMDtcbiAgICAgICAgdGhpcy5kZWZhdWx0UmV0cnlUaW1lb3V0TVMgPSAyMDAwO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlID0gbmV3IEJyaWRnZUNvbm5lY3Rpb25TdG9yYWdlKHN0b3JhZ2UpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0b3JhZ2Uoc3RvcmFnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UgPSBuZXcgQnJpZGdlQ29ubmVjdGlvblN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgYnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UuZ2V0SHR0cENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChpc1BlbmRpbmdDb25uZWN0aW9uSHR0cChjb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnJpZGdlUHJvdmlkZXIoc3RvcmFnZSwgY29ubmVjdGlvbi5jb25uZWN0aW9uU291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQnJpZGdlUHJvdmlkZXIoc3RvcmFnZSwgeyBicmlkZ2VVcmw6IGNvbm5lY3Rpb24uc2Vzc2lvbi5icmlkZ2VVcmwgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCk7XG4gICAgICAgIChfYSA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWJvcnQoKTtcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMuY2xvc2VHYXRld2F5cygpO1xuICAgICAgICBjb25zdCBzZXNzaW9uQ3J5cHRvID0gbmV3IFNlc3Npb25DcnlwdG8oKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0ge1xuICAgICAgICAgICAgc2Vzc2lvbkNyeXB0byxcbiAgICAgICAgICAgIGJyaWRnZVVybDogJ2JyaWRnZVVybCcgaW4gdGhpcy53YWxsZXRDb25uZWN0aW9uU291cmNlXG4gICAgICAgICAgICAgICAgPyB0aGlzLndhbGxldENvbm5lY3Rpb25Tb3VyY2UuYnJpZGdlVXJsXG4gICAgICAgICAgICAgICAgOiAnJ1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlXG4gICAgICAgICAgICAuc3RvcmVDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICdodHRwJyxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Tb3VyY2U6IHRoaXMud2FsbGV0Q29ubmVjdGlvblNvdXJjZSxcbiAgICAgICAgICAgIHNlc3Npb25DcnlwdG9cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBjYWxsRm9yU3VjY2Vzcyhfb3B0aW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZW5HYXRld2F5cyhzZXNzaW9uQ3J5cHRvLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5pbmdEZWFkbGluZU1TOiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub3BlbmluZ0RlYWRsaW5lTVMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuZGVmYXVsdE9wZW5pbmdEZWFkbGluZU1TLFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IF9vcHRpb25zID09PSBudWxsIHx8IF9vcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucy5zaWduYWxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBhdHRlbXB0czogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICAgICAgZGVsYXlNczogdGhpcy5kZWZhdWx0UmV0cnlUaW1lb3V0TVMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB1bml2ZXJzYWxMaW5rID0gJ3VuaXZlcnNhbExpbmsnIGluIHRoaXMud2FsbGV0Q29ubmVjdGlvblNvdXJjZSAmJlxuICAgICAgICAgICAgdGhpcy53YWxsZXRDb25uZWN0aW9uU291cmNlLnVuaXZlcnNhbExpbmtcbiAgICAgICAgICAgID8gdGhpcy53YWxsZXRDb25uZWN0aW9uU291cmNlLnVuaXZlcnNhbExpbmtcbiAgICAgICAgICAgIDogdGhpcy5zdGFuZGFyZFVuaXZlcnNhbExpbms7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlVW5pdmVyc2FsTGluayh1bml2ZXJzYWxMaW5rLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgcmVzdG9yZUNvbm5lY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWwpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5hYm9ydENvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hYm9ydCgpO1xuICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbG9zZUdhdGV3YXlzKCk7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWRDb25uZWN0aW9uID0geWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5nZXRIdHRwQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKCFzdG9yZWRDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wZW5pbmdEZWFkbGluZU1TID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wZW5pbmdEZWFkbGluZU1TKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLmRlZmF1bHRPcGVuaW5nRGVhZGxpbmVNUztcbiAgICAgICAgICAgIGlmIChpc1BlbmRpbmdDb25uZWN0aW9uSHR0cChzdG9yZWRDb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkNyeXB0bzogc3RvcmVkQ29ubmVjdGlvbi5zZXNzaW9uQ3J5cHRvLFxuICAgICAgICAgICAgICAgICAgICBicmlkZ2VVcmw6ICdicmlkZ2VVcmwnIGluIHRoaXMud2FsbGV0Q29ubmVjdGlvblNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLndhbGxldENvbm5lY3Rpb25Tb3VyY2UuYnJpZGdlVXJsXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICcnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5vcGVuR2F0ZXdheXMoc3RvcmVkQ29ubmVjdGlvbi5zZXNzaW9uQ3J5cHRvLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5pbmdEZWFkbGluZU1TOiBvcGVuaW5nRGVhZGxpbmVNUyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLndhbGxldENvbm5lY3Rpb25Tb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignSW50ZXJuYWwgZXJyb3IuIENvbm5lY3Rpb24gc291cmNlIGlzIGFycmF5IHdoaWxlIFdhbGxldENvbm5lY3Rpb25Tb3VyY2VIVFRQIHdhcyBleHBlY3RlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IHN0b3JlZENvbm5lY3Rpb24uc2Vzc2lvbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmdhdGV3YXkpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnR2F0ZXdheSBpcyBhbHJlYWR5IG9wZW5lZCwgY2xvc2luZyBwcmV2aW91cyBnYXRld2F5Jyk7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5nYXRld2F5LmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdhdGV3YXkgPSBuZXcgQnJpZGdlR2F0ZXdheSh0aGlzLnN0b3JhZ2UsIHRoaXMud2FsbGV0Q29ubmVjdGlvblNvdXJjZS5icmlkZ2VVcmwsIHN0b3JlZENvbm5lY3Rpb24uc2Vzc2lvbi5zZXNzaW9uQ3J5cHRvLnNlc3Npb25JZCwgdGhpcy5nYXRld2F5TGlzdGVuZXIuYmluZCh0aGlzKSwgdGhpcy5nYXRld2F5RXJyb3JzTGlzdGVuZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm90aWZ5IGxpc3RlbmVycyBhYm91dCBzdG9yZWQgY29ubmVjdGlvblxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcihzdG9yZWRDb25uZWN0aW9uLmNvbm5lY3RFdmVudCkpO1xuICAgICAgICAgICAgLy8gd2FpdCBmb3IgdGhlIGNvbm5lY3Rpb24gdG8gYmUgb3BlbmVkXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNhbGxGb3JTdWNjZXNzKG9wdGlvbnMgPT4gdGhpcy5nYXRld2F5LnJlZ2lzdGVyU2Vzc2lvbih7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5pbmdEZWFkbGluZU1TOiBvcGVuaW5nRGVhZGxpbmVNUyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbFxuICAgICAgICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgICAgICAgICAgZGVsYXlNczogdGhpcy5kZWZhdWx0UmV0cnlUaW1lb3V0TVMsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRpc2Nvbm5lY3QoeyBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZFJlcXVlc3QocmVxdWVzdCwgb3B0aW9uc09yT25SZXF1ZXN0U2VudCkge1xuICAgICAgICAvLyBUT0RPOiByZW1vdmUgZGVwcmVjYXRlZCBtZXRob2RcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMub25SZXF1ZXN0U2VudCA9IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLm9uUmVxdWVzdFNlbnQgPSBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSBudWxsIHx8IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQub25SZXF1ZXN0U2VudDtcbiAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsID0gb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gbnVsbCB8fCBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zT3JPblJlcXVlc3RTZW50LnNpZ25hbDtcbiAgICAgICAgICAgIG9wdGlvbnMuYXR0ZW1wdHMgPSBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSBudWxsIHx8IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQuYXR0ZW1wdHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghdGhpcy5nYXRld2F5IHx8ICF0aGlzLnNlc3Npb24gfHwgISgnd2FsbGV0UHVibGljS2V5JyBpbiB0aGlzLnNlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignVHJ5aW5nIHRvIHNlbmQgYnJpZGdlIHJlcXVlc3Qgd2l0aG91dCBzZXNzaW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZCA9ICh5aWVsZCB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLmdldE5leHRScGNSZXF1ZXN0SWQoKSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdGlvblN0b3JhZ2UuaW5jcmVhc2VOZXh0UnBjUmVxdWVzdElkKCk7XG4gICAgICAgICAgICBsb2dEZWJ1ZygnU2VuZCBodHRwLWJyaWRnZSByZXF1ZXN0OicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHsgaWQgfSkpO1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZFJlcXVlc3QgPSB0aGlzLnNlc3Npb24uc2Vzc2lvbkNyeXB0by5lbmNyeXB0KEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHsgaWQgfSkpLCBoZXhUb0J5dGVBcnJheSh0aGlzLnNlc3Npb24ud2FsbGV0UHVibGljS2V5KSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2F0ZXdheS5zZW5kKGVuY29kZWRSZXF1ZXN0LCB0aGlzLnNlc3Npb24ud2FsbGV0UHVibGljS2V5LCByZXF1ZXN0Lm1ldGhvZCwgeyBhdHRlbXB0czogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dGVtcHRzLCBzaWduYWw6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWwgfSk7XG4gICAgICAgICAgICAgICAgKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uUmVxdWVzdFNlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzLnNldChpZC50b1N0cmluZygpLCByZXNvbHZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNsb3NlQ29ubmVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5jbG9zZUdhdGV3YXlzKCk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2F0ZXdheSA9IG51bGw7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCB0aW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uUmVxdWVzdFNlbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVCcmlkZ2VBbmRTZXNzaW9uKCkudGhlbihyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZUdhdGV3YXlzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5kZWZhdWx0T3BlbmluZ0RlYWRsaW5lTVMpO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnNlbmRSZXF1ZXN0KHsgbWV0aG9kOiAnZGlzY29ubmVjdCcsIHBhcmFtczogW10gfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25SZXF1ZXN0U2VudDogb25SZXF1ZXN0U2VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzOiAxXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnRGlzY29ubmVjdCBlcnJvcjonLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQnJpZGdlQW5kU2Vzc2lvbigpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9uUmVxdWVzdFNlbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsaXN0ZW4oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiAodGhpcy5saXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycy5maWx0ZXIobGlzdGVuZXIgPT4gbGlzdGVuZXIgIT09IGNhbGxiYWNrKSk7XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuZ2F0ZXdheSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdXNlKCk7XG4gICAgICAgIHRoaXMucGVuZGluZ0dhdGV3YXlzLmZvckVhY2goYnJpZGdlID0+IGJyaWRnZS5wYXVzZSgpKTtcbiAgICB9XG4gICAgdW5QYXVzZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5wZW5kaW5nR2F0ZXdheXMubWFwKGJyaWRnZSA9PiBicmlkZ2UudW5QYXVzZSgpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdhdGV3YXkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZ2F0ZXdheS51blBhdXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGVuZGluZ0dhdGV3YXlzTGlzdGVuZXIoZ2F0ZXdheSwgYnJpZGdlVXJsLCBicmlkZ2VJbmNvbWluZ01lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wZW5kaW5nR2F0ZXdheXMuaW5jbHVkZXMoZ2F0ZXdheSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBnYXRld2F5LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbG9zZUdhdGV3YXlzKHsgZXhjZXB0OiBnYXRld2F5IH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2F0ZXdheSkge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdHYXRld2F5IGlzIGFscmVhZHkgb3BlbmVkLCBjbG9zaW5nIHByZXZpb3VzIGdhdGV3YXknKTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmdhdGV3YXkuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5icmlkZ2VVcmwgPSBicmlkZ2VVcmw7XG4gICAgICAgICAgICB0aGlzLmdhdGV3YXkgPSBnYXRld2F5O1xuICAgICAgICAgICAgdGhpcy5nYXRld2F5LnNldEVycm9yc0xpc3RlbmVyKHRoaXMuZ2F0ZXdheUVycm9yc0xpc3RlbmVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5nYXRld2F5LnNldExpc3RlbmVyKHRoaXMuZ2F0ZXdheUxpc3RlbmVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2F0ZXdheUxpc3RlbmVyKGJyaWRnZUluY29taW5nTWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnYXRld2F5TGlzdGVuZXIoYnJpZGdlSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXRNZXNzYWdlID0gSlNPTi5wYXJzZSh0aGlzLnNlc3Npb24uc2Vzc2lvbkNyeXB0by5kZWNyeXB0KEJhc2U2NC5kZWNvZGUoYnJpZGdlSW5jb21pbmdNZXNzYWdlLm1lc3NhZ2UpLnRvVWludDhBcnJheSgpLCBoZXhUb0J5dGVBcnJheShicmlkZ2VJbmNvbWluZ01lc3NhZ2UuZnJvbSkpKTtcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdXYWxsZXQgbWVzc2FnZSByZWNlaXZlZDonLCB3YWxsZXRNZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICghKCdldmVudCcgaW4gd2FsbGV0TWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IHdhbGxldE1lc3NhZ2UuaWQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlID0gdGhpcy5wZW5kaW5nUmVxdWVzdHMuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoYFJlc3BvbnNlIGlkICR7aWR9IGRvZXNuJ3QgbWF0Y2ggYW55IHJlcXVlc3QncyBpZGApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUod2FsbGV0TWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2FsbGV0TWVzc2FnZS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdElkID0geWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5nZXRMYXN0V2FsbGV0RXZlbnRJZCgpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0SWQgIT09IHVuZGVmaW5lZCAmJiB3YWxsZXRNZXNzYWdlLmlkIDw9IGxhc3RJZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFcnJvcihgUmVjZWl2ZWQgZXZlbnQgaWQgKD0ke3dhbGxldE1lc3NhZ2UuaWR9KSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBzdG9yZWQgbGFzdCB3YWxsZXQgZXZlbnQgaWQgKD0ke2xhc3RJZH0pIGApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh3YWxsZXRNZXNzYWdlLmV2ZW50ICE9PSAnY29ubmVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5zdG9yZUxhc3RXYWxsZXRFdmVudElkKHdhbGxldE1lc3NhZ2UuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGB0aGlzLmxpc3RlbmVyc2AgbWlnaHQgYmUgbW9kaWZpZWQgaW4gdGhlIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzO1xuICAgICAgICAgICAgaWYgKHdhbGxldE1lc3NhZ2UuZXZlbnQgPT09ICdjb25uZWN0Jykge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMudXBkYXRlU2Vzc2lvbih3YWxsZXRNZXNzYWdlLCBicmlkZ2VJbmNvbWluZ01lc3NhZ2UuZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2FsbGV0TWVzc2FnZS5ldmVudCA9PT0gJ2Rpc2Nvbm5lY3QnKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoYFJlbW92aW5nIGJyaWRnZSBhbmQgc2Vzc2lvbjogcmVjZWl2ZWQgZGlzY29ubmVjdCBldmVudGApO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucmVtb3ZlQnJpZGdlQW5kU2Vzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIod2FsbGV0TWVzc2FnZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2F0ZXdheUVycm9yc0xpc3RlbmVyKGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoYEJyaWRnZSBlcnJvciAke0pTT04uc3RyaW5naWZ5KGUpfWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlU2Vzc2lvbihjb25uZWN0RXZlbnQsIHdhbGxldFB1YmxpY0tleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnNlc3Npb24pLCB7IHdhbGxldFB1YmxpY0tleSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRvbkFkZHJJdGVtID0gY29ubmVjdEV2ZW50LnBheWxvYWQuaXRlbXMuZmluZChpdGVtID0+IGl0ZW0ubmFtZSA9PT0gJ3Rvbl9hZGRyJyk7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0RXZlbnRUb1NhdmUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbm5lY3RFdmVudCksIHsgcGF5bG9hZDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25uZWN0RXZlbnQucGF5bG9hZCksIHsgaXRlbXM6IFt0b25BZGRySXRlbV0gfSkgfSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLnN0b3JlQ29ubmVjdGlvbih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2h0dHAnLFxuICAgICAgICAgICAgICAgIHNlc3Npb246IHRoaXMuc2Vzc2lvbixcbiAgICAgICAgICAgICAgICBsYXN0V2FsbGV0RXZlbnRJZDogY29ubmVjdEV2ZW50LmlkLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RFdmVudDogY29ubmVjdEV2ZW50VG9TYXZlLFxuICAgICAgICAgICAgICAgIG5leHRScGNSZXF1ZXN0SWQ6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlQnJpZGdlQW5kU2Vzc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLnJlbW92ZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdlbmVyYXRlVW5pdmVyc2FsTGluayh1bml2ZXJzYWxMaW5rLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChpc1RlbGVncmFtVXJsKHVuaXZlcnNhbExpbmspKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVRHVW5pdmVyc2FsTGluayh1bml2ZXJzYWxMaW5rLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVJlZ3VsYXJVbml2ZXJzYWxMaW5rKHVuaXZlcnNhbExpbmssIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBnZW5lcmF0ZVJlZ3VsYXJVbml2ZXJzYWxMaW5rKHVuaXZlcnNhbExpbmssIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh1bml2ZXJzYWxMaW5rKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3YnLCBQUk9UT0NPTF9WRVJTSU9OLnRvU3RyaW5nKCkpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnaWQnLCB0aGlzLnNlc3Npb24uc2Vzc2lvbkNyeXB0by5zZXNzaW9uSWQpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgncicsIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgIH1cbiAgICBnZW5lcmF0ZVRHVW5pdmVyc2FsTGluayh1bml2ZXJzYWxMaW5rLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHVybFRvV3JhcCA9IHRoaXMuZ2VuZXJhdGVSZWd1bGFyVW5pdmVyc2FsTGluaygnYWJvdXQ6YmxhbmsnLCBtZXNzYWdlKTtcbiAgICAgICAgY29uc3QgbGlua1BhcmFtcyA9IHVybFRvV3JhcC5zcGxpdCgnPycpWzFdO1xuICAgICAgICBjb25zdCBzdGFydGFwcCA9ICd0b25jb25uZWN0LScgKyBlbmNvZGVUZWxlZ3JhbVVybFBhcmFtZXRlcnMobGlua1BhcmFtcyk7XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIGxpbmUgYWZ0ZXIgYWxsIGRBcHBzIGFuZCB0aGUgd2FsbGV0cy1saXN0Lmpzb24gaGF2ZSBiZWVuIHVwZGF0ZWRcbiAgICAgICAgY29uc3QgdXBkYXRlZFVuaXZlcnNhbExpbmsgPSB0aGlzLmNvbnZlcnRUb0RpcmVjdExpbmsodW5pdmVyc2FsTGluayk7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodXBkYXRlZFVuaXZlcnNhbExpbmspO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnc3RhcnRhcHAnLCBzdGFydGFwcCk7XG4gICAgICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgbWV0aG9kIGFmdGVyIGFsbCBkQXBwcyBhbmQgdGhlIHdhbGxldHMtbGlzdC5qc29uIGhhdmUgYmVlbiB1cGRhdGVkXG4gICAgY29udmVydFRvRGlyZWN0TGluayh1bml2ZXJzYWxMaW5rKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodW5pdmVyc2FsTGluayk7XG4gICAgICAgIGlmICh1cmwuc2VhcmNoUGFyYW1zLmhhcygnYXR0YWNoJykpIHtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKCdhdHRhY2gnKTtcbiAgICAgICAgICAgIHVybC5wYXRobmFtZSArPSAnL3N0YXJ0JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIG9wZW5HYXRld2F5cyhzZXNzaW9uQ3J5cHRvLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLndhbGxldENvbm5lY3Rpb25Tb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gY2xvc2UgYWxsIGdhdGV3YXlzIGJlZm9yZSBvcGVuaW5nIG5ldyBvbmVzXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nR2F0ZXdheXMubWFwKGJyaWRnZSA9PiBicmlkZ2UuY2xvc2UoKS5jYXRjaCgpKTtcbiAgICAgICAgICAgICAgICAvLyBvcGVuIG5ldyBnYXRld2F5c1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0dhdGV3YXlzID0gdGhpcy53YWxsZXRDb25uZWN0aW9uU291cmNlLm1hcChzb3VyY2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXRld2F5ID0gbmV3IEJyaWRnZUdhdGV3YXkodGhpcy5zdG9yYWdlLCBzb3VyY2UuYnJpZGdlVXJsLCBzZXNzaW9uQ3J5cHRvLnNlc3Npb25JZCwgKCkgPT4geyB9LCAoKSA9PiB7IH0pO1xuICAgICAgICAgICAgICAgICAgICBnYXRld2F5LnNldExpc3RlbmVyKG1lc3NhZ2UgPT4gdGhpcy5wZW5kaW5nR2F0ZXdheXNMaXN0ZW5lcihnYXRld2F5LCBzb3VyY2UuYnJpZGdlVXJsLCBtZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnYXRld2F5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsU2V0dGxlZCh0aGlzLnBlbmRpbmdHYXRld2F5cy5tYXAoYnJpZGdlID0+IGNhbGxGb3JTdWNjZXNzKChfb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wZW5kaW5nR2F0ZXdheXMuc29tZShpdGVtID0+IGl0ZW0gPT09IGJyaWRnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBicmlkZ2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnJpZGdlLnJlZ2lzdGVyU2Vzc2lvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuaW5nRGVhZGxpbmVNUzogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wZW5pbmdEZWFkbGluZU1TKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmRlZmF1bHRPcGVuaW5nRGVhZGxpbmVNUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogX29wdGlvbnMuc2lnbmFsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdHM6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgICAgICAgICBkZWxheU1zOiB0aGlzLmRlZmF1bHRSZXRyeVRpbWVvdXRNUyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsXG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nYXRld2F5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKGBHYXRld2F5IGlzIGFscmVhZHkgb3BlbmVkLCBjbG9zaW5nIHByZXZpb3VzIGdhdGV3YXlgKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5nYXRld2F5LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZ2F0ZXdheSA9IG5ldyBCcmlkZ2VHYXRld2F5KHRoaXMuc3RvcmFnZSwgdGhpcy53YWxsZXRDb25uZWN0aW9uU291cmNlLmJyaWRnZVVybCwgc2Vzc2lvbkNyeXB0by5zZXNzaW9uSWQsIHRoaXMuZ2F0ZXdheUxpc3RlbmVyLmJpbmQodGhpcyksIHRoaXMuZ2F0ZXdheUVycm9yc0xpc3RlbmVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmdhdGV3YXkucmVnaXN0ZXJTZXNzaW9uKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbmluZ0RlYWRsaW5lTVM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vcGVuaW5nRGVhZGxpbmVNUyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9zZUdhdGV3YXlzKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmdhdGV3YXkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xuICAgICAgICB0aGlzLnBlbmRpbmdHYXRld2F5c1xuICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZXhjZXB0KSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGJyaWRnZSA9PiBicmlkZ2UuY2xvc2UoKSk7XG4gICAgICAgIHRoaXMucGVuZGluZ0dhdGV3YXlzID0gW107XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNQcm9wZXJ0eSh2YWx1ZSwgcHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gaGFzUHJvcGVydGllcyh2YWx1ZSwgW3Byb3BlcnR5S2V5XSk7XG59XG5mdW5jdGlvbiBoYXNQcm9wZXJ0aWVzKHZhbHVlLCBwcm9wZXJ0eUtleXMpIHtcbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcGVydHlLZXlzLmV2ZXJ5KHByb3BlcnR5S2V5ID0+IHByb3BlcnR5S2V5IGluIHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gaXNKU0JyaWRnZVdpdGhNZXRhZGF0YSh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghaGFzUHJvcGVydHkodmFsdWUsICd0b25jb25uZWN0JykgfHwgIWhhc1Byb3BlcnR5KHZhbHVlLnRvbmNvbm5lY3QsICd3YWxsZXRJbmZvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzUHJvcGVydGllcyh2YWx1ZS50b25jb25uZWN0LndhbGxldEluZm8sIFtcbiAgICAgICAgICAgICduYW1lJyxcbiAgICAgICAgICAgICdhcHBfbmFtZScsXG4gICAgICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAgICAgJ2Fib3V0X3VybCcsXG4gICAgICAgICAgICAncGxhdGZvcm1zJ1xuICAgICAgICBdKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogSW4gbWVtb3J5IHN0b3JhZ2UgbGlrZSBsb2NhbFN0b3JhZ2UsIGJ1dCB3aXRob3V0IHBlcnNpc3RlbmNlLlxuICogVXNlcyBhcyBhIGZhbGxiYWNrIGZvciBsb2NhbFN0b3JhZ2UgaW4gU2FmYXJpJ3MgcHJpdmF0ZSBtb2RlLlxuICovXG5jbGFzcyBJbk1lbW9yeVN0b3JhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSB7fTtcbiAgICB9XG4gICAgc3RhdGljIGdldEluc3RhbmNlKCkge1xuICAgICAgICBpZiAoIUluTWVtb3J5U3RvcmFnZS5pbnN0YW5jZSkge1xuICAgICAgICAgICAgSW5NZW1vcnlTdG9yYWdlLmluc3RhbmNlID0gbmV3IEluTWVtb3J5U3RvcmFnZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBJbk1lbW9yeVN0b3JhZ2UuaW5zdGFuY2U7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN0b3JhZ2UpLmxlbmd0aDtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHt9O1xuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnN0b3JhZ2Vba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICB9XG4gICAga2V5KGluZGV4KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuc3RvcmFnZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0ga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2EgPSBrZXlzW2luZGV4XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICB9XG4gICAgcmVtb3ZlSXRlbShrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RvcmFnZVtrZXldO1xuICAgIH1cbiAgICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlW2tleV0gPSB2YWx1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvdygpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdztcbn1cbi8qKlxuICogVGhlIGZ1bmN0aW9uIHRyeSB0byBnZXQgd2luZG93IGtleXMsIGlmIGl0IGlzIG5vdCBhdmFpbGFibGUgaXQgcmV0dXJucyBlbXB0eSBhcnJheS5cbiAqIEFzIGFuIGV4YW1wbGUsIGZvciBTYWZhcmkncyBwcml2YXRlIG1vZGUgaXQgcmV0dXJucyBlbXB0eSBhcnJheSwgYmVjYXVzZSB0aGUgYnJvd3NlciBkb2VzIG5vdCBhbGxvdyB0byBnZXQgd2luZG93IGtleXMuXG4gKi9cbmZ1bmN0aW9uIHRyeUdldFdpbmRvd0tleXMoKSB7XG4gICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgaWYgKCF3aW5kb3cpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMod2luZG93KTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRXZWJQYWdlTWFuaWZlc3QoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG9yaWdpbiA9IChfYSA9IGdldFdpbmRvdygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYXRpb24ub3JpZ2luO1xuICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbiArICcvdG9uY29ubmVjdC1tYW5pZmVzdC5qc29uJztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBSZXR1cm5zIGBsb2NhbFN0b3JhZ2VgIGlmIGl0IGlzIGF2YWlsYWJsZS4gSW4gU2FmYXJpJ3MgcHJpdmF0ZSBtb2RlLCBpdCByZXR1cm5zIGBJbk1lbW9yeVN0b3JhZ2VgLiBJbiBOb2RlLmpzLCBpdCB0aHJvd3MgYW4gZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIHRyeUdldExvY2FsU3RvcmFnZSgpIHtcbiAgICBpZiAoaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSkge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlO1xuICAgIH1cbiAgICBpZiAoaXNOb2RlSnMoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdgbG9jYWxTdG9yYWdlYCBpcyB1bmF2YWlsYWJsZSwgYnV0IGl0IGlzIHJlcXVpcmVkIGZvciBUb25Db25uZWN0LiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Rvbi1jb25uZWN0L3Nkay90cmVlL21haW4vcGFja2FnZXMvc2RrI2luaXQtY29ubmVjdG9yJyk7XG4gICAgfVxuICAgIHJldHVybiBJbk1lbW9yeVN0b3JhZ2UuZ2V0SW5zdGFuY2UoKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGBsb2NhbFN0b3JhZ2VgIGlzIGF2YWlsYWJsZS5cbiAqL1xuZnVuY3Rpb24gaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSB7XG4gICAgLy8gV2UgdXNlIGEgdHJ5L2NhdGNoIGJsb2NrIGJlY2F1c2UgU2FmYXJpJ3MgcHJpdmF0ZSBtb2RlIHRocm93cyBhbiBlcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gYWNjZXNzIGxvY2FsU3RvcmFnZS5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGVudmlyb25tZW50IGlzIE5vZGUuanMuXG4gKi9cbmZ1bmN0aW9uIGlzTm9kZUpzKCkge1xuICAgIHJldHVybiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbnMgIT0gbnVsbCAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT0gbnVsbCk7XG59XG5cbmNsYXNzIEluamVjdGVkUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0b3JhZ2UsIGluamVjdGVkV2FsbGV0S2V5KSB7XG4gICAgICAgIHRoaXMuaW5qZWN0ZWRXYWxsZXRLZXkgPSBpbmplY3RlZFdhbGxldEtleTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2luamVjdGVkJztcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5saXN0ZW5TdWJzY3JpcHRpb25zID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIGNvbnN0IHdpbmRvdyA9IEluamVjdGVkUHJvdmlkZXIud2luZG93O1xuICAgICAgICBpZiAoIUluamVjdGVkUHJvdmlkZXIuaXNXaW5kb3dDb250YWluc1dhbGxldCh3aW5kb3csIGluamVjdGVkV2FsbGV0S2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdEluamVjdGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlID0gbmV3IEJyaWRnZUNvbm5lY3Rpb25TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICB0aGlzLmluamVjdGVkV2FsbGV0ID0gd2luZG93W2luamVjdGVkV2FsbGV0S2V5XS50b25jb25uZWN0O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0b3JhZ2Uoc3RvcmFnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UgPSBuZXcgQnJpZGdlQ29ubmVjdGlvblN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgYnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UuZ2V0SW5qZWN0ZWRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEluamVjdGVkUHJvdmlkZXIoc3RvcmFnZSwgY29ubmVjdGlvbi5qc0JyaWRnZUtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgaXNXYWxsZXRJbmplY3RlZChpbmplY3RlZFdhbGxldEtleSkge1xuICAgICAgICByZXR1cm4gSW5qZWN0ZWRQcm92aWRlci5pc1dpbmRvd0NvbnRhaW5zV2FsbGV0KHRoaXMud2luZG93LCBpbmplY3RlZFdhbGxldEtleSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0luc2lkZVdhbGxldEJyb3dzZXIoaW5qZWN0ZWRXYWxsZXRLZXkpIHtcbiAgICAgICAgaWYgKEluamVjdGVkUHJvdmlkZXIuaXNXaW5kb3dDb250YWluc1dhbGxldCh0aGlzLndpbmRvdywgaW5qZWN0ZWRXYWxsZXRLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aW5kb3dbaW5qZWN0ZWRXYWxsZXRLZXldLnRvbmNvbm5lY3QuaXNXYWxsZXRCcm93c2VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGljIGdldEN1cnJlbnRseUluamVjdGVkV2FsbGV0cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLndpbmRvdykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdpbmRvd0tleXMgPSB0cnlHZXRXaW5kb3dLZXlzKCk7XG4gICAgICAgIGNvbnN0IHdhbGxldHMgPSB3aW5kb3dLZXlzLmZpbHRlcigoW18sIHZhbHVlXSkgPT4gaXNKU0JyaWRnZVdpdGhNZXRhZGF0YSh2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gd2FsbGV0cy5tYXAoKFtqc0JyaWRnZUtleSwgd2FsbGV0XSkgPT4gKHtcbiAgICAgICAgICAgIG5hbWU6IHdhbGxldC50b25jb25uZWN0LndhbGxldEluZm8ubmFtZSxcbiAgICAgICAgICAgIGFwcE5hbWU6IHdhbGxldC50b25jb25uZWN0LndhbGxldEluZm8uYXBwX25hbWUsXG4gICAgICAgICAgICBhYm91dFVybDogd2FsbGV0LnRvbmNvbm5lY3Qud2FsbGV0SW5mby5hYm91dF91cmwsXG4gICAgICAgICAgICBpbWFnZVVybDogd2FsbGV0LnRvbmNvbm5lY3Qud2FsbGV0SW5mby5pbWFnZSxcbiAgICAgICAgICAgIHRvbmRuczogd2FsbGV0LnRvbmNvbm5lY3Qud2FsbGV0SW5mby50b25kbnMsXG4gICAgICAgICAgICBqc0JyaWRnZUtleSxcbiAgICAgICAgICAgIGluamVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgZW1iZWRkZWQ6IHdhbGxldC50b25jb25uZWN0LmlzV2FsbGV0QnJvd3NlcixcbiAgICAgICAgICAgIHBsYXRmb3Jtczogd2FsbGV0LnRvbmNvbm5lY3Qud2FsbGV0SW5mby5wbGF0Zm9ybXMsXG4gICAgICAgICAgICBmZWF0dXJlczogd2FsbGV0LnRvbmNvbm5lY3Qud2FsbGV0SW5mby5mZWF0dXJlc1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1dpbmRvd0NvbnRhaW5zV2FsbGV0KHdpbmRvdywgaW5qZWN0ZWRXYWxsZXRLZXkpIHtcbiAgICAgICAgcmV0dXJuICghIXdpbmRvdyAmJlxuICAgICAgICAgICAgaW5qZWN0ZWRXYWxsZXRLZXkgaW4gd2luZG93ICYmXG4gICAgICAgICAgICB0eXBlb2Ygd2luZG93W2luamVjdGVkV2FsbGV0S2V5XSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICd0b25jb25uZWN0JyBpbiB3aW5kb3dbaW5qZWN0ZWRXYWxsZXRLZXldKTtcbiAgICB9XG4gICAgY29ubmVjdChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3QoUFJPVE9DT0xfVkVSU0lPTiwgbWVzc2FnZSk7XG4gICAgfVxuICAgIHJlc3RvcmVDb25uZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhgSW5qZWN0ZWQgUHJvdmlkZXIgcmVzdG9yaW5nIGNvbm5lY3Rpb24uLi5gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0RXZlbnQgPSB5aWVsZCB0aGlzLmluamVjdGVkV2FsbGV0LnJlc3RvcmVDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0luamVjdGVkIFByb3ZpZGVyIHJlc3RvcmluZyBjb25uZWN0aW9uIHJlc3BvbnNlJywgY29ubmVjdEV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdEV2ZW50LmV2ZW50ID09PSAnY29ubmVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWtlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKGNvbm5lY3RFdmVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5yZW1vdmVDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLnJlbW92ZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvc2VDb25uZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5TdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmluamVjdGVkV2FsbGV0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25SZXF1ZXN0U2VudCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLnJlbW92ZUNvbm5lY3Rpb24oKS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmplY3RlZFdhbGxldC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIG9uUmVxdWVzdFNlbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZGlzY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0sIG9uUmVxdWVzdFNlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvc2VBbGxMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5saXN0ZW5TdWJzY3JpcHRpb25zID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIChfYSA9IHRoaXMudW5zdWJzY3JpYmVDYWxsYmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGxpc3RlbihldmVudHNDYWxsYmFjaykge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGV2ZW50c0NhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+ICh0aGlzLmxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzLmZpbHRlcihsaXN0ZW5lciA9PiBsaXN0ZW5lciAhPT0gZXZlbnRzQ2FsbGJhY2spKTtcbiAgICB9XG4gICAgc2VuZFJlcXVlc3QocmVxdWVzdCwgb3B0aW9uc09yT25SZXF1ZXN0U2VudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgZGVwcmVjYXRlZCBtZXRob2RcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZXF1ZXN0U2VudCA9IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVxdWVzdFNlbnQgPSBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSBudWxsIHx8IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQub25SZXF1ZXN0U2VudDtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbCA9IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IG51bGwgfHwgb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uc09yT25SZXF1ZXN0U2VudC5zaWduYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZCA9ICh5aWVsZCB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLmdldE5leHRScGNSZXF1ZXN0SWQoKSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdGlvblN0b3JhZ2UuaW5jcmVhc2VOZXh0UnBjUmVxdWVzdElkKCk7XG4gICAgICAgICAgICBsb2dEZWJ1ZygnU2VuZCBpbmplY3RlZC1icmlkZ2UgcmVxdWVzdDonLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpLCB7IGlkIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaW5qZWN0ZWRXYWxsZXQuc2VuZChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpLCB7IGlkIH0pKTtcbiAgICAgICAgICAgIHJlc3VsdC50aGVuKHJlc3BvbnNlID0+IGxvZ0RlYnVnKCdXYWxsZXQgbWVzc2FnZSByZWNlaXZlZDonLCByZXNwb25zZSkpO1xuICAgICAgICAgICAgKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uUmVxdWVzdFNlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9jb25uZWN0KHByb3RvY29sVmVyc2lvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhgSW5qZWN0ZWQgUHJvdmlkZXIgY29ubmVjdCByZXF1ZXN0OiBwcm90b2NvbFZlcnNpb246ICR7cHJvdG9jb2xWZXJzaW9ufSwgbWVzc2FnZTpgLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0RXZlbnQgPSB5aWVsZCB0aGlzLmluamVjdGVkV2FsbGV0LmNvbm5lY3QocHJvdG9jb2xWZXJzaW9uLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnSW5qZWN0ZWQgUHJvdmlkZXIgY29ubmVjdCByZXNwb25zZTonLCBjb25uZWN0RXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0RXZlbnQuZXZlbnQgPT09ICdjb25uZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnVwZGF0ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWtlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKGNvbm5lY3RFdmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnSW5qZWN0ZWQgUHJvdmlkZXIgY29ubmVjdCBlcnJvcjonLCBlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0RXZlbnRFcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6ICdjb25uZWN0X2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoY29ubmVjdEV2ZW50RXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1ha2VTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICB0aGlzLmxpc3RlblN1YnNjcmlwdGlvbnMgPSB0cnVlO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQ2FsbGJhY2sgPSB0aGlzLmluamVjdGVkV2FsbGV0Lmxpc3RlbihlID0+IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdXYWxsZXQgbWVzc2FnZSByZWNlaXZlZDonLCBlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlblN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlLmV2ZW50ID09PSAnZGlzY29ubmVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZVNlc3Npb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLnN0b3JlQ29ubmVjdGlvbih7XG4gICAgICAgICAgICB0eXBlOiAnaW5qZWN0ZWQnLFxuICAgICAgICAgICAganNCcmlkZ2VLZXk6IHRoaXMuaW5qZWN0ZWRXYWxsZXRLZXksXG4gICAgICAgICAgICBuZXh0UnBjUmVxdWVzdElkOiAwXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbkluamVjdGVkUHJvdmlkZXIud2luZG93ID0gZ2V0V2luZG93KCk7XG5cbi8qKlxuICogRGVmYXVsdCBzdG9yYWdlIHRvIHNhdmUgcHJvdG9jb2wgZGF0YSwgdXNlcyBgbG9jYWxTdG9yYWdlYCBpZiBpdCBpcyBhdmFpbGFibGUuIEluIFNhZmFyaSdzIHByaXZhdGUgbW9kZSwgaXQgdXNlcyBgSW5NZW1vcnlTdG9yYWdlYC4gSW4gTm9kZS5qcywgaXQgdGhyb3dzIGFuIGVycm9yLlxuICovXG5jbGFzcyBEZWZhdWx0U3RvcmFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdG9yYWdlID0gdHJ5R2V0TG9jYWxTdG9yYWdlKCk7XG4gICAgfVxuICAgIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlSXRlbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgV2FsbGV0SW5mb2AgaXMgYFdhbGxldEluZm9JbmplY3RhYmxlYCBhbmQgYFdhbGxldEluZm9gIGlzIGluamVjdGVkIHRvIHRoZSBjdXJyZW50IHdlYnBhZ2UgKGB3YWxsZXRJbmZvLmluamVjdGVkID09PSB0cnVlYCkuXG4gKiBAcGFyYW0gdmFsdWUgV2FsbGV0SW5mbyB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gaXNXYWxsZXRJbmZvQ3VycmVudGx5SW5qZWN0ZWQodmFsdWUpIHtcbiAgICByZXR1cm4gaXNXYWxsZXRJbmZvSW5qZWN0YWJsZSh2YWx1ZSkgJiYgdmFsdWUuaW5qZWN0ZWQ7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgV2FsbGV0SW5mb2AgaXMgYFdhbGxldEluZm9JbmplY3RhYmxlYCBhbmQgZEFwcCBpcyBvcGVuZWQgaW5zaWRlIHRoaXMgd2FsbGV0J3MgYnJvd3Nlci5cbiAqIEBwYXJhbSB2YWx1ZSBXYWxsZXRJbmZvIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBpc1dhbGxldEluZm9DdXJyZW50bHlFbWJlZGRlZCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1dhbGxldEluZm9DdXJyZW50bHlJbmplY3RlZCh2YWx1ZSkgJiYgdmFsdWUuZW1iZWRkZWQ7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgV2FsbGV0SW5mb2AgaXMgYFdhbGxldEluZm9JbmplY3RlZGAsIGJ1dCBkb2Vzbid0IGNoZWNrIGlmIGl0IGlzIGluamVjdGVkIHRvIHRoZSBwYWdlIG9yIG5vdC5cbiAqIEBwYXJhbSB2YWx1ZSBXYWxsZXRJbmZvIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBpc1dhbGxldEluZm9JbmplY3RhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICdqc0JyaWRnZUtleScgaW4gdmFsdWU7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgV2FsbGV0SW5mb2AgaXMgYFdhbGxldEluZm9SZW1vdGVgLlxuICogQHBhcmFtIHZhbHVlIFdhbGxldEluZm8gdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGlzV2FsbGV0SW5mb1JlbW90ZSh2YWx1ZSkge1xuICAgIHJldHVybiAnYnJpZGdlVXJsJyBpbiB2YWx1ZTtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIGBpc1dhbGxldEluZm9JbmplY3RhYmxlYCBvciBgaXNXYWxsZXRJbmZvQ3VycmVudGx5SW5qZWN0ZWRgIGluc3RlYWQuXG4gKiBAcGFyYW0gdmFsdWUgV2FsbGV0SW5mbyB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gaXNXYWxsZXRJbmZvSW5qZWN0ZWQodmFsdWUpIHtcbiAgICByZXR1cm4gJ2pzQnJpZGdlS2V5JyBpbiB2YWx1ZTtcbn1cblxuY29uc3QgRkFMTEJBQ0tfV0FMTEVUU19MSVNUID0gW1xuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICd0ZWxlZ3JhbS13YWxsZXQnLFxuICAgICAgICBuYW1lOiAnV2FsbGV0JyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3dhbGxldC50Zy9pbWFnZXMvbG9nby0yODgucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly93YWxsZXQudGcvJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vdC5tZS93YWxsZXQ/YXR0YWNoPXdhbGxldCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vd2FsbGV0Ym90Lm1lL3RvbmNvbm5lY3QtYnJpZGdlL2JyaWRnZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ21hY29zJywgJ3dpbmRvd3MnLCAnbGludXgnXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ3RvbmtlZXBlcicsXG4gICAgICAgIG5hbWU6ICdUb25rZWVwZXInLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vdG9ua2VlcGVyLmNvbS9hc3NldHMvdG9uY29ubmVjdC1pY29uLnBuZycsXG4gICAgICAgIHRvbmRuczogJ3RvbmtlZXBlci50b24nLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL3RvbmtlZXBlci5jb20nLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly9hcHAudG9ua2VlcGVyLmNvbS90b24tY29ubmVjdCcsXG4gICAgICAgIGRlZXBMaW5rOiAndG9ua2VlcGVyLXRjOi8vJyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9icmlkZ2UudG9uYXBpLmlvL2JyaWRnZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICd0b25rZWVwZXInXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCcsICdjaHJvbWUnLCAnZmlyZWZveCcsICdtYWNvcyddXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnbXl0b253YWxsZXQnLFxuICAgICAgICBuYW1lOiAnTXlUb25XYWxsZXQnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vc3RhdGljLm15dG9ud2FsbGV0LmlvL2ljb24tMjU2LnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vbXl0b253YWxsZXQuaW8nLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly9jb25uZWN0Lm15dG9ud2FsbGV0Lm9yZycsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdqcycsXG4gICAgICAgICAgICAgICAga2V5OiAnbXl0b253YWxsZXQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vdG9uY29ubmVjdGJyaWRnZS5teXRvbndhbGxldC5vcmcvYnJpZGdlLydcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2Nocm9tZScsICd3aW5kb3dzJywgJ21hY29zJywgJ2xpbnV4JywgJ2lvcycsICdhbmRyb2lkJywgJ2ZpcmVmb3gnXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ3Rvbmh1YicsXG4gICAgICAgIG5hbWU6ICdUb25odWInLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vdG9uaHViLmNvbS90b25jb25uZWN0X2xvZ28ucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly90b25odWIuY29tJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vdG9uaHViLmNvbS90b24tY29ubmVjdCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdqcycsXG4gICAgICAgICAgICAgICAga2V5OiAndG9uaHViJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2Nvbm5lY3QudG9uaHViYXBpLmNvbS90b25jb25uZWN0J1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ2JpdGdldFRvbldhbGxldCcsXG4gICAgICAgIG5hbWU6ICdCaXRnZXQgV2FsbGV0JyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYml0Z2V0d2FsbGV0L2Rvd25sb2FkL3JlZnMvaGVhZHMvbWFpbi9sb2dvL3BuZy9iaXRnZXRfd2FsbGV0X2xvZ29fMjg4X21pbmkucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly93ZWIzLmJpdGdldC5jb20nLFxuICAgICAgICBkZWVwTGluazogJ2JpdGtlZXA6Ly8nLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ2JpdGdldFRvbldhbGxldCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly90b24tY29ubmVjdC1icmlkZ2UuYmd3YXBpLmlvL2JyaWRnZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ2Nocm9tZSddLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly9ia2NvZGUudmlwL3Rvbi1jb25uZWN0J1xuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ29reE1pbmlXYWxsZXQnLFxuICAgICAgICBuYW1lOiAnT0tYIE1pbmkgV2FsbGV0JyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3N0YXRpYy5va3guY29tL2Nkbi9hc3NldHMvaW1ncy8yNDExLzhCRTFBNEE0MzREOEY1OEEucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly93d3cub2t4LmNvbS93ZWIzJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vdC5tZS9PS1hfV0FMTEVUX0JPVD9hdHRhY2g9d2FsbGV0JyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly93d3cub2t4LmNvbS90b25icmlkZ2UvZGlzY292ZXIvcnBjL2JyaWRnZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ21hY29zJywgJ3dpbmRvd3MnLCAnbGludXgnXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ2JpbmFuY2VXZWIzVG9uV2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ0JpbmFuY2UgV2ViMyBXYWxsZXQnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vcHVibGljLmJuYnN0YXRpYy5jb20vc3RhdGljL2JpbmFuY2UtdzN3L3Rvbi1wcm92aWRlci9iaW5hbmNldzN3LnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vd3d3LmJpbmFuY2UuY29tL2VuL3dlYjN3YWxsZXQnLFxuICAgICAgICBkZWVwTGluazogJ2JuYzovL2FwcC5iaW5hbmNlLmNvbS9jZWRlZmkvdG9uLWNvbm5lY3QnLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ2JpbmFuY2V3M3cnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vd2FsbGV0LmJpbmFuY2UuY29tL3RvbmJyaWRnZS9icmlkZ2UnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCcsICdtYWNvcycsICd3aW5kb3dzJywgJ2xpbnV4J10sXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL2FwcC5iaW5hbmNlLmNvbS9jZWRlZmkvdG9uLWNvbm5lY3QnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnZmludG9waW8tdGcnLFxuICAgICAgICBuYW1lOiAnRmludG9waW8nLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vZmludG9waW8uY29tL3RvbmNvbm5lY3QtaWNvbi5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL2ZpbnRvcGlvLmNvbScsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3QubWUvZmludG9waW8/YXR0YWNoPXdhbGxldCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vd2FsbGV0LWJyaWRnZS5maW50b3Bpby5jb20vYnJpZGdlJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnLCAnbWFjb3MnLCAnd2luZG93cycsICdsaW51eCddXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnb2t4VG9uV2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ09LWCBXYWxsZXQnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vc3RhdGljLm9reC5jb20vY2RuL2Fzc2V0cy9pbWdzLzI0Ny81OEU2M0ZFQTQ3QTJCN0Q3LnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vd3d3Lm9reC5jb20vd2ViMycsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3d3dy5va3guY29tL2Rvd25sb2FkP2FwcGVuZFF1ZXJ5PXRydWUmZGVlcGxpbms9b2t4Oi8vd2ViMy93YWxsZXQvdG9uY29ubmVjdCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdqcycsXG4gICAgICAgICAgICAgICAga2V5OiAnb2t4VG9uV2FsbGV0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL3d3dy5va3guY29tL3RvbmJyaWRnZS9kaXNjb3Zlci9ycGMvYnJpZGdlJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnY2hyb21lJywgJ3NhZmFyaScsICdmaXJlZm94JywgJ2lvcycsICdhbmRyb2lkJ11cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdob3QnLFxuICAgICAgICBuYW1lOiAnSE9UJyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vaG90LWRhby9tZWRpYS9tYWluL2xvZ28ucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly9ob3QtbGFicy5vcmcvJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vdC5tZS9oZXJld2FsbGV0Ym90P2F0dGFjaD13YWxsZXQnLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL3NzZS1icmlkZ2UuaG90LWxhYnMub3JnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ2hvdFdhbGxldCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ21hY29zJywgJ3dpbmRvd3MnLCAnbGludXgnXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ2J5Yml0VG9uV2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ0J5Yml0IFdhbGxldCcsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2J5Yml0LXdlYjMvYnliaXQtd2ViMy5naXRodWIuaW8vbWFpbi9kb2NzL2ltYWdlcy9ieWJpdC1sb2dvLnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vd3d3LmJ5Yml0LmNvbS93ZWIzJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vYXBwLmJ5Yml0LmNvbS90b24tY29ubmVjdCcsXG4gICAgICAgIGRlZXBMaW5rOiAnYnliaXRhcHA6Ly8nLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ2J5Yml0VG9uV2FsbGV0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2FwaS1ub2RlLmJ5Yml0LmNvbS9zcG90L2FwaS93ZWIzL2JyaWRnZS90b24vYnJpZGdlJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnLCAnY2hyb21lJ11cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdkZXdhbGxldCcsXG4gICAgICAgIG5hbWU6ICdEZVdhbGxldCcsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2RlbGFiLXRlYW0vbWFuaWZlc3RzLWltYWdlcy9tYWluL1dhbGxldEF2YXRhci5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL2RlbGFid2FsbGV0LmNvbScsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3QubWUvZGV3YWxsZXQ/YXR0YWNoPXdhbGxldCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vYnJpZGdlLmRld2FsbGV0LnByby9icmlkZ2UnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCcsICdtYWNvcycsICd3aW5kb3dzJywgJ2xpbnV4J11cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdzYWZlcGFsd2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ1NhZmVQYWwnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vcy5wdmNsaXBpbmcuY29tL3dlYi9wdWJsaWNfaW1hZ2UvU2FmZVBhbF94Mjg4LnBuZycsXG4gICAgICAgIHRvbmRuczogJycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vd3d3LnNhZmVwYWwuY29tJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vbGluay5zYWZlcGFsLmlvL3Rvbi1jb25uZWN0JyxcbiAgICAgICAgZGVlcExpbms6ICdzYWZlcGFsLXRjOi8vJyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly90b24tYnJpZGdlLnNhZmVwYWwuY29tL3RvbmJyaWRnZS92MS9icmlkZ2UnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdqcycsXG4gICAgICAgICAgICAgICAga2V5OiAnc2FmZXBhbHdhbGxldCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ2Nocm9tZScsICdmaXJlZm94J11cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdHYXRlV2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ0dhdGVXYWxsZXQnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vaW1nLmdhdGVkYXRhaW1nLmNvbS9wcmQtb3JkaW5hbC1pbWdzLzAzNmYwN2JiODczMDcxNmUvZ2F0ZWlvLTA5MjUucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly93d3cuZ2F0ZS5pby8nLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ2dhdGV0b253YWxsZXQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vZGFwcC5nYXRlaW8uc2VydmljZXMvdG9uYnJpZGdlX2FwaS9icmlkZ2UvdjEnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCddLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly9nYXRlaW8uZ28ubGluay9nYXRlaW8vd2ViMz9hZGpfdD0xZmY4a2hkd18xZnU0Y2NjNydcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdvcGVubWFzaycsXG4gICAgICAgIG5hbWU6ICdPcGVuTWFzaycsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL09wZW5Qcm9kdWN0L29wZW5tYXNrLWV4dGVuc2lvbi9tYWluL3B1YmxpYy9vcGVubWFzay1sb2dvLTI4OC5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL3d3dy5vcGVubWFzay5hcHAvJyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdvcGVubWFzaydcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2Nocm9tZSddXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnQml0Z2V0V2ViMycsXG4gICAgICAgIG5hbWU6ICdCaXRnZXRXZWIzJyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL2ltZy5iaXRnZXRpbWcuY29tL2ltYWdlL3RoaXJkLzE3MzE2MzgwNTk3OTUucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAn4oCLaHR0cHM6Ly93d3cuYml0Z2V0LmNvbScsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL3QubWUvQml0Z2V0T2ZmaWNpYWxCb3Q/YXR0YWNoPXdhbGxldCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzc2UnLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vdG9uLWNvbm5lY3QtYnJpZGdlLmJnd2FwaS5pby9icmlkZ2UnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydpb3MnLCAnYW5kcm9pZCcsICd3aW5kb3dzJywgJ21hY29zJywgJ2xpbnV4J11cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICd0b2JpJyxcbiAgICAgICAgbmFtZTogJ1RvYmknLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vYXBwLnRvYml3YWxsZXQuYXBwL2ljb25zL2xvZ28tMjg4LnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vdG9iaS5mdW4nLFxuICAgICAgICB1bml2ZXJzYWxfdXJsOiAnaHR0cHM6Ly90Lm1lL1RvYmlDb3BpbG90Qm90P2F0dGFjaD13YWxsZXQnLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL3Rvbi1icmlkZ2UudG9iaXdhbGxldC5hcHAvYnJpZGdlJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnLCAnbWFjb3MnLCAnd2luZG93cycsICdsaW51eCddXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAneHRvbndhbGxldCcsXG4gICAgICAgIG5hbWU6ICdYVE9OV2FsbGV0JyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3h0b253YWxsZXQuY29tL2Fzc2V0cy9pbWcvaWNvbi0yNTYtYmFjay5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL3h0b253YWxsZXQuY29tJyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICd4dG9ud2FsbGV0J1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnY2hyb21lJywgJ2ZpcmVmb3gnXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ3RvbndhbGxldCcsXG4gICAgICAgIG5hbWU6ICdUT04gV2FsbGV0JyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3dhbGxldC50b24ub3JnL2Fzc2V0cy91aS9xci1sb2dvLnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8vY2hyb21lLmdvb2dsZS5jb20vd2Vic3RvcmUvZGV0YWlsL3Rvbi13YWxsZXQvbnBocGxwZ29ha2hoamNoa2tobWlnZ2FraWpua2hmbmQnLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ3RvbndhbGxldCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2Nocm9tZSddXG4gICAgfVxuXTtcblxuY2xhc3MgV2FsbGV0c0xpc3RNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy53YWxsZXRzTGlzdENhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy53YWxsZXRzTGlzdENhY2hlQ3JlYXRpb25UaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB0aGlzLndhbGxldHNMaXN0U291cmNlID1cbiAgICAgICAgICAgIChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53YWxsZXRzTGlzdFNvdXJjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS90b24tYmxvY2tjaGFpbi93YWxsZXRzLWxpc3QvbWFpbi93YWxsZXRzLXYyLmpzb24nO1xuICAgICAgICB0aGlzLmNhY2hlVFRMTXMgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FjaGVUVExNcztcbiAgICB9XG4gICAgZ2V0V2FsbGV0cygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhY2hlVFRMTXMgJiZcbiAgICAgICAgICAgICAgICB0aGlzLndhbGxldHNMaXN0Q2FjaGVDcmVhdGlvblRpbWVzdGFtcCAmJlxuICAgICAgICAgICAgICAgIERhdGUubm93KCkgPiB0aGlzLndhbGxldHNMaXN0Q2FjaGVDcmVhdGlvblRpbWVzdGFtcCArIHRoaXMuY2FjaGVUVExNcykge1xuICAgICAgICAgICAgICAgIHRoaXMud2FsbGV0c0xpc3RDYWNoZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMud2FsbGV0c0xpc3RDYWNoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMud2FsbGV0c0xpc3RDYWNoZSA9IHRoaXMuZmV0Y2hXYWxsZXRzTGlzdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMud2FsbGV0c0xpc3RDYWNoZVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2FsbGV0c0xpc3RDYWNoZUNyZWF0aW9uVGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndhbGxldHNMaXN0Q2FjaGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndhbGxldHNMaXN0Q2FjaGVDcmVhdGlvblRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YWxsZXRzTGlzdENhY2hlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RW1iZWRkZWRXYWxsZXQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXRzTGlzdCA9IHlpZWxkIHRoaXMuZ2V0V2FsbGV0cygpO1xuICAgICAgICAgICAgY29uc3QgZW1iZWRkZWRXYWxsZXRzID0gd2FsbGV0c0xpc3QuZmlsdGVyKGlzV2FsbGV0SW5mb0N1cnJlbnRseUVtYmVkZGVkKTtcbiAgICAgICAgICAgIHJldHVybiBlbWJlZGRlZFdhbGxldHMubGVuZ3RoID09PSAxID8gZW1iZWRkZWRXYWxsZXRzWzBdIDogbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoV2FsbGV0c0xpc3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgd2FsbGV0c0xpc3QgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FsbGV0c1Jlc3BvbnNlID0geWllbGQgZmV0Y2godGhpcy53YWxsZXRzTGlzdFNvdXJjZSk7XG4gICAgICAgICAgICAgICAgd2FsbGV0c0xpc3QgPSB5aWVsZCB3YWxsZXRzUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh3YWxsZXRzTGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZldGNoV2FsbGV0c0Vycm9yKCdXcm9uZyB3YWxsZXRzIGxpc3QgZm9ybWF0LCB3YWxsZXRzIGxpc3QgbXVzdCBiZSBhbiBhcnJheS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JvbmdGb3JtYXRXYWxsZXRzID0gd2FsbGV0c0xpc3QuZmlsdGVyKHdhbGxldCA9PiAhdGhpcy5pc0NvcnJlY3RXYWxsZXRDb25maWdEVE8od2FsbGV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHdyb25nRm9ybWF0V2FsbGV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRXJyb3IoYFdhbGxldChzKSAke3dyb25nRm9ybWF0V2FsbGV0c1xuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCh3YWxsZXQgPT4gKHdhbGxldCA9PT0gbnVsbCB8fCB3YWxsZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdhbGxldC5uYW1lKSB8fCAndW5rbm93bicpXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKX0gY29uZmlnIGZvcm1hdCBpcyB3cm9uZy4gVGhleSB3ZXJlIHJlbW92ZWQgZnJvbSB0aGUgd2FsbGV0cyBsaXN0LmApO1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXRzTGlzdCA9IHdhbGxldHNMaXN0LmZpbHRlcih3YWxsZXQgPT4gdGhpcy5pc0NvcnJlY3RXYWxsZXRDb25maWdEVE8od2FsbGV0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dFcnJvcihlKTtcbiAgICAgICAgICAgICAgICB3YWxsZXRzTGlzdCA9IEZBTExCQUNLX1dBTExFVFNfTElTVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjdXJyZW50bHlJbmplY3RlZFdhbGxldHMgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5SW5qZWN0ZWRXYWxsZXRzID0gSW5qZWN0ZWRQcm92aWRlci5nZXRDdXJyZW50bHlJbmplY3RlZFdhbGxldHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXJnZVdhbGxldHNMaXN0cyh0aGlzLndhbGxldENvbmZpZ0RUT0xpc3RUb1dhbGxldENvbmZpZ0xpc3Qod2FsbGV0c0xpc3QpLCBjdXJyZW50bHlJbmplY3RlZFdhbGxldHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgd2FsbGV0Q29uZmlnRFRPTGlzdFRvV2FsbGV0Q29uZmlnTGlzdCh3YWxsZXRDb25maWdEVE8pIHtcbiAgICAgICAgcmV0dXJuIHdhbGxldENvbmZpZ0RUTy5tYXAod2FsbGV0Q29uZmlnRFRPID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiB3YWxsZXRDb25maWdEVE8ubmFtZSxcbiAgICAgICAgICAgICAgICBhcHBOYW1lOiB3YWxsZXRDb25maWdEVE8uYXBwX25hbWUsXG4gICAgICAgICAgICAgICAgaW1hZ2VVcmw6IHdhbGxldENvbmZpZ0RUTy5pbWFnZSxcbiAgICAgICAgICAgICAgICBhYm91dFVybDogd2FsbGV0Q29uZmlnRFRPLmFib3V0X3VybCxcbiAgICAgICAgICAgICAgICB0b25kbnM6IHdhbGxldENvbmZpZ0RUTy50b25kbnMsXG4gICAgICAgICAgICAgICAgcGxhdGZvcm1zOiB3YWxsZXRDb25maWdEVE8ucGxhdGZvcm1zLFxuICAgICAgICAgICAgICAgIGZlYXR1cmVzOiB3YWxsZXRDb25maWdEVE8uZmVhdHVyZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3YWxsZXRDb25maWdEVE8uYnJpZGdlLmZvckVhY2goYnJpZGdlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYnJpZGdlLnR5cGUgPT09ICdzc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhbGxldENvbmZpZy5icmlkZ2VVcmwgPSBicmlkZ2UudXJsO1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXRDb25maWcudW5pdmVyc2FsTGluayA9XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXRDb25maWdEVE8udW5pdmVyc2FsX3VybDtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0Q29uZmlnLmRlZXBMaW5rID0gd2FsbGV0Q29uZmlnRFRPLmRlZXBMaW5rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYnJpZGdlLnR5cGUgPT09ICdqcycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QganNCcmlkZ2VLZXkgPSBicmlkZ2Uua2V5O1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXRDb25maWcuanNCcmlkZ2VLZXkgPSBqc0JyaWRnZUtleTtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0Q29uZmlnLmluamVjdGVkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIEluamVjdGVkUHJvdmlkZXIuaXNXYWxsZXRJbmplY3RlZChqc0JyaWRnZUtleSk7XG4gICAgICAgICAgICAgICAgICAgIHdhbGxldENvbmZpZy5lbWJlZGRlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmplY3RlZFByb3ZpZGVyLmlzSW5zaWRlV2FsbGV0QnJvd3Nlcihqc0JyaWRnZUtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gd2FsbGV0Q29uZmlnO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWVyZ2VXYWxsZXRzTGlzdHMobGlzdDEsIGxpc3QyKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gbmV3IFNldChsaXN0MS5jb25jYXQobGlzdDIpLm1hcChpdGVtID0+IGl0ZW0ubmFtZSkpO1xuICAgICAgICByZXR1cm4gWy4uLm5hbWVzLnZhbHVlcygpXS5tYXAobmFtZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaXN0MUl0ZW0gPSBsaXN0MS5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09PSBuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGxpc3QySXRlbSA9IGxpc3QyLmZpbmQoaXRlbSA9PiBpdGVtLm5hbWUgPT09IG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKGxpc3QxSXRlbSAmJiBPYmplY3QuYXNzaWduKHt9LCBsaXN0MUl0ZW0pKSksIChsaXN0Mkl0ZW0gJiYgT2JqZWN0LmFzc2lnbih7fSwgbGlzdDJJdGVtKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICBpc0NvcnJlY3RXYWxsZXRDb25maWdEVE8odmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCAhKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbnNOYW1lID0gJ25hbWUnIGluIHZhbHVlO1xuICAgICAgICBjb25zdCBjb250YWluc0FwcE5hbWUgPSAnYXBwX25hbWUnIGluIHZhbHVlO1xuICAgICAgICBjb25zdCBjb250YWluc0ltYWdlID0gJ2ltYWdlJyBpbiB2YWx1ZTtcbiAgICAgICAgY29uc3QgY29udGFpbnNBYm91dCA9ICdhYm91dF91cmwnIGluIHZhbHVlO1xuICAgICAgICBjb25zdCBjb250YWluc1BsYXRmb3JtcyA9ICdwbGF0Zm9ybXMnIGluIHZhbHVlO1xuICAgICAgICBpZiAoIWNvbnRhaW5zTmFtZSB8fFxuICAgICAgICAgICAgIWNvbnRhaW5zSW1hZ2UgfHxcbiAgICAgICAgICAgICFjb250YWluc0Fib3V0IHx8XG4gICAgICAgICAgICAhY29udGFpbnNQbGF0Zm9ybXMgfHxcbiAgICAgICAgICAgICFjb250YWluc0FwcE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbHVlLnBsYXRmb3JtcyB8fFxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUucGxhdGZvcm1zKSB8fFxuICAgICAgICAgICAgIXZhbHVlLnBsYXRmb3Jtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgnYnJpZGdlJyBpbiB2YWx1ZSkgfHxcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlLmJyaWRnZSkgfHxcbiAgICAgICAgICAgICF2YWx1ZS5icmlkZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnJpZGdlID0gdmFsdWUuYnJpZGdlO1xuICAgICAgICBpZiAoYnJpZGdlLnNvbWUoaXRlbSA9PiAhaXRlbSB8fCB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcgfHwgISgndHlwZScgaW4gaXRlbSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3NlQnJpZGdlID0gYnJpZGdlLmZpbmQoaXRlbSA9PiBpdGVtLnR5cGUgPT09ICdzc2UnKTtcbiAgICAgICAgaWYgKHNzZUJyaWRnZSkge1xuICAgICAgICAgICAgaWYgKCEodHlwZW9mIHNzZUJyaWRnZSA9PT0gJ29iamVjdCcgJiYgJ3VybCcgaW4gc3NlQnJpZGdlKSB8fFxuICAgICAgICAgICAgICAgICFzc2VCcmlkZ2UudXJsIHx8XG4gICAgICAgICAgICAgICAgIXZhbHVlLnVuaXZlcnNhbF91cmwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QganNCcmlkZ2UgPSBicmlkZ2UuZmluZChpdGVtID0+IGl0ZW0udHlwZSA9PT0gJ2pzJyk7XG4gICAgICAgIGlmIChqc0JyaWRnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc0JyaWRnZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICAhKCdrZXknIGluIGpzQnJpZGdlKSB8fFxuICAgICAgICAgICAgICAgICFqc0JyaWRnZS5rZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1NlbmRUcmFuc2FjdGlvblN1cHBvcnQoZmVhdHVyZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdXBwb3J0c0RlcHJlY2F0ZWRTZW5kVHJhbnNhY3Rpb25GZWF0dXJlID0gZmVhdHVyZXMuaW5jbHVkZXMoJ1NlbmRUcmFuc2FjdGlvbicpO1xuICAgIGNvbnN0IHNlbmRUcmFuc2FjdGlvbkZlYXR1cmUgPSBmaW5kRmVhdHVyZShmZWF0dXJlcywgJ1NlbmRUcmFuc2FjdGlvbicpO1xuICAgIGNvbnN0IHJlcXVpcmVkRmVhdHVyZSA9IHtcbiAgICAgICAgbWluTWVzc2FnZXM6IG9wdGlvbnMucmVxdWlyZWRNZXNzYWdlc051bWJlcixcbiAgICAgICAgZXh0cmFDdXJyZW5jeVJlcXVpcmVkOiBvcHRpb25zLnJlcXVpcmVFeHRyYUN1cnJlbmNpZXNcbiAgICB9O1xuICAgIGlmICghc3VwcG9ydHNEZXByZWNhdGVkU2VuZFRyYW5zYWN0aW9uRmVhdHVyZSAmJiAhc2VuZFRyYW5zYWN0aW9uRmVhdHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90U3VwcG9ydEZlYXR1cmVFcnJvcihcIldhbGxldCBkb2Vzbid0IHN1cHBvcnQgU2VuZFRyYW5zYWN0aW9uIGZlYXR1cmUuXCIsIHtcbiAgICAgICAgICAgIGNhdXNlOiB7IHJlcXVpcmVkRmVhdHVyZTogeyBmZWF0dXJlTmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsIHZhbHVlOiByZXF1aXJlZEZlYXR1cmUgfSB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXF1aXJlRXh0cmFDdXJyZW5jaWVzKSB7XG4gICAgICAgIGlmICghc2VuZFRyYW5zYWN0aW9uRmVhdHVyZSB8fCAhc2VuZFRyYW5zYWN0aW9uRmVhdHVyZS5leHRyYUN1cnJlbmN5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90U3VwcG9ydEZlYXR1cmVFcnJvcihgV2FsbGV0IGlzIG5vdCBhYmxlIHRvIGhhbmRsZSBzdWNoIFNlbmRUcmFuc2FjdGlvbiByZXF1ZXN0LiBFeHRyYSBjdXJyZW5jaWVzIHN1cHBvcnQgaXMgcmVxdWlyZWQuYCwge1xuICAgICAgICAgICAgICAgIGNhdXNlOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkRmVhdHVyZTogeyBmZWF0dXJlTmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsIHZhbHVlOiByZXF1aXJlZEZlYXR1cmUgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzZW5kVHJhbnNhY3Rpb25GZWF0dXJlICYmIHNlbmRUcmFuc2FjdGlvbkZlYXR1cmUubWF4TWVzc2FnZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc2VuZFRyYW5zYWN0aW9uRmVhdHVyZS5tYXhNZXNzYWdlcyA8IG9wdGlvbnMucmVxdWlyZWRNZXNzYWdlc051bWJlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFN1cHBvcnRGZWF0dXJlRXJyb3IoYFdhbGxldCBpcyBub3QgYWJsZSB0byBoYW5kbGUgc3VjaCBTZW5kVHJhbnNhY3Rpb24gcmVxdWVzdC4gTWF4IHN1cHBvcnQgbWVzc2FnZXMgbnVtYmVyIGlzICR7c2VuZFRyYW5zYWN0aW9uRmVhdHVyZS5tYXhNZXNzYWdlc30sIGJ1dCAke29wdGlvbnMucmVxdWlyZWRNZXNzYWdlc051bWJlcn0gaXMgcmVxdWlyZWQuYCwge1xuICAgICAgICAgICAgICAgIGNhdXNlOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkRmVhdHVyZTogeyBmZWF0dXJlTmFtZTogJ1NlbmRUcmFuc2FjdGlvbicsIHZhbHVlOiByZXF1aXJlZEZlYXR1cmUgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nV2FybmluZyhcIkNvbm5lY3RlZCB3YWxsZXQgZGlkbid0IHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgbWF4IGFsbG93ZWQgbWVzc2FnZXMgaW4gdGhlIFNlbmRUcmFuc2FjdGlvbiByZXF1ZXN0LiBSZXF1ZXN0IG1heSBiZSByZWplY3RlZCBieSB0aGUgd2FsbGV0LlwiKTtcbn1cbmZ1bmN0aW9uIGNoZWNrU2lnbkRhdGFTdXBwb3J0KGZlYXR1cmVzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc2lnbkRhdGFGZWF0dXJlID0gZmVhdHVyZXMuZmluZChmZWF0dXJlID0+IGZlYXR1cmUgJiYgdHlwZW9mIGZlYXR1cmUgPT09ICdvYmplY3QnICYmIGZlYXR1cmUubmFtZSA9PT0gJ1NpZ25EYXRhJyk7XG4gICAgaWYgKCFzaWduRGF0YUZlYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFN1cHBvcnRGZWF0dXJlRXJyb3IoXCJXYWxsZXQgZG9lc24ndCBzdXBwb3J0IFNpZ25EYXRhIGZlYXR1cmUuXCIsIHtcbiAgICAgICAgICAgIGNhdXNlOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWRGZWF0dXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVOYW1lOiAnU2lnbkRhdGEnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeyB0eXBlczogb3B0aW9ucy5yZXF1aXJlZFR5cGVzIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB1bnN1cHBvcnRlZFR5cGVzID0gb3B0aW9ucy5yZXF1aXJlZFR5cGVzLmZpbHRlcihyZXF1aXJlZFR5cGUgPT4gIXNpZ25EYXRhRmVhdHVyZS50eXBlcy5pbmNsdWRlcyhyZXF1aXJlZFR5cGUpKTtcbiAgICBpZiAodW5zdXBwb3J0ZWRUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFN1cHBvcnRGZWF0dXJlRXJyb3IoYFdhbGxldCBkb2Vzbid0IHN1cHBvcnQgcmVxdWlyZWQgU2lnbkRhdGEgdHlwZXM6ICR7dW5zdXBwb3J0ZWRUeXBlcy5qb2luKCcsICcpfS5gLCB7XG4gICAgICAgICAgICBjYXVzZToge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkRmVhdHVyZTogeyBmZWF0dXJlTmFtZTogJ1NpZ25EYXRhJywgdmFsdWU6IHsgdHlwZXM6IHVuc3VwcG9ydGVkVHlwZXMgfSB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRXYWxsZXRGZWF0dXJlcyhmZWF0dXJlcywgd2FsbGV0c1JlcXVpcmVkRmVhdHVyZXMpIHtcbiAgICBpZiAodHlwZW9mIHdhbGxldHNSZXF1aXJlZEZlYXR1cmVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgeyBzZW5kVHJhbnNhY3Rpb24sIHNpZ25EYXRhIH0gPSB3YWxsZXRzUmVxdWlyZWRGZWF0dXJlcztcbiAgICBpZiAoc2VuZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGZlYXR1cmUgPSBmaW5kRmVhdHVyZShmZWF0dXJlcywgJ1NlbmRUcmFuc2FjdGlvbicpO1xuICAgICAgICBpZiAoIWZlYXR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoZWNrU2VuZFRyYW5zYWN0aW9uKGZlYXR1cmUsIHNlbmRUcmFuc2FjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2lnbkRhdGEpIHtcbiAgICAgICAgY29uc3QgZmVhdHVyZSA9IGZpbmRGZWF0dXJlKGZlYXR1cmVzLCAnU2lnbkRhdGEnKTtcbiAgICAgICAgaWYgKCFmZWF0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVja1NpZ25EYXRhKGZlYXR1cmUsIHNpZ25EYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZmluZEZlYXR1cmUoZmVhdHVyZXMsIHJlcXVpcmVkRmVhdHVyZU5hbWUpIHtcbiAgICByZXR1cm4gZmVhdHVyZXMuZmluZChmID0+IGYgJiYgdHlwZW9mIGYgPT09ICdvYmplY3QnICYmIGYubmFtZSA9PT0gcmVxdWlyZWRGZWF0dXJlTmFtZSk7XG59XG5mdW5jdGlvbiBjaGVja1NlbmRUcmFuc2FjdGlvbihmZWF0dXJlLCByZXF1aXJlZEZlYXR1cmUpIHtcbiAgICBjb25zdCBjb3JyZWN0TWVzc2FnZXNOdW1iZXIgPSByZXF1aXJlZEZlYXR1cmUubWluTWVzc2FnZXMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICByZXF1aXJlZEZlYXR1cmUubWluTWVzc2FnZXMgPD0gZmVhdHVyZS5tYXhNZXNzYWdlcztcbiAgICBjb25zdCBjb3JyZWN0RXh0cmFDdXJyZW5jeSA9ICFyZXF1aXJlZEZlYXR1cmUuZXh0cmFDdXJyZW5jeVJlcXVpcmVkIHx8IGZlYXR1cmUuZXh0cmFDdXJyZW5jeVN1cHBvcnRlZDtcbiAgICByZXR1cm4gISEoY29ycmVjdE1lc3NhZ2VzTnVtYmVyICYmIGNvcnJlY3RFeHRyYUN1cnJlbmN5KTtcbn1cbmZ1bmN0aW9uIGNoZWNrU2lnbkRhdGEoZmVhdHVyZSwgcmVxdWlyZWRGZWF0dXJlKSB7XG4gICAgcmV0dXJuIHJlcXVpcmVkRmVhdHVyZS50eXBlcy5ldmVyeShyZXF1aXJlZFR5cGUgPT4gZmVhdHVyZS50eXBlcy5pbmNsdWRlcyhyZXF1aXJlZFR5cGUpKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByZXF1ZXN0IHZlcnNpb24gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RWZXJzaW9uRXZlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3JlcXVlc3QtdmVyc2lvbidcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSByZXNwb25zZSB2ZXJzaW9uIGV2ZW50LlxuICogQHBhcmFtIHZlcnNpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VWZXJzaW9uRXZlbnQodmVyc2lvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdyZXNwb25zZS12ZXJzaW9uJyxcbiAgICAgICAgdmVyc2lvbjogdmVyc2lvblxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIHZlcnNpb24gaW5mby5cbiAqIEBwYXJhbSB2ZXJzaW9uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVZlcnNpb25JbmZvKHZlcnNpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b25fY29ubmVjdF9zZGtfbGliOiB2ZXJzaW9uLnRvbl9jb25uZWN0X3Nka19saWIsXG4gICAgICAgIHRvbl9jb25uZWN0X3VpX2xpYjogdmVyc2lvbi50b25fY29ubmVjdF91aV9saWJcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvbkluZm8odmVyc2lvbiwgd2FsbGV0KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICBjb25zdCBpc1RvblByb29mID0gKChfYSA9IHdhbGxldCA9PT0gbnVsbCB8fCB3YWxsZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdhbGxldC5jb25uZWN0SXRlbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b25Qcm9vZikgJiYgJ3Byb29mJyBpbiB3YWxsZXQuY29ubmVjdEl0ZW1zLnRvblByb29mO1xuICAgIGNvbnN0IGF1dGhUeXBlID0gaXNUb25Qcm9vZiA/ICd0b25fcHJvb2YnIDogJ3Rvbl9hZGRyJztcbiAgICByZXR1cm4ge1xuICAgICAgICB3YWxsZXRfYWRkcmVzczogKF9jID0gKF9iID0gd2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0LmFjY291bnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hZGRyZXNzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsLFxuICAgICAgICB3YWxsZXRfdHlwZTogKF9kID0gd2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0LmRldmljZS5hcHBOYW1lKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBudWxsLFxuICAgICAgICB3YWxsZXRfdmVyc2lvbjogKF9lID0gd2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0LmRldmljZS5hcHBWZXJzaW9uKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBudWxsLFxuICAgICAgICBhdXRoX3R5cGU6IGF1dGhUeXBlLFxuICAgICAgICBjdXN0b21fZGF0YTogT2JqZWN0LmFzc2lnbih7IGNoYWluX2lkOiAoX2cgPSAoX2YgPSB3YWxsZXQgPT09IG51bGwgfHwgd2FsbGV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3YWxsZXQuYWNjb3VudCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNoYWluKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBudWxsLCBwcm92aWRlcjogKF9oID0gd2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0LnByb3ZpZGVyKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBudWxsIH0sIGNyZWF0ZVZlcnNpb25JbmZvKHZlcnNpb24pKVxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIGNvbm5lY3Rpb24gaW5pdCBldmVudC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvblN0YXJ0ZWRFdmVudCh2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2Nvbm5lY3Rpb24tc3RhcnRlZCcsXG4gICAgICAgIGN1c3RvbV9kYXRhOiBjcmVhdGVWZXJzaW9uSW5mbyh2ZXJzaW9uKVxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIGNvbm5lY3Rpb24gY29tcGxldGVkIGV2ZW50LlxuICogQHBhcmFtIHZlcnNpb25cbiAqIEBwYXJhbSB3YWxsZXRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvbkNvbXBsZXRlZEV2ZW50KHZlcnNpb24sIHdhbGxldCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgdHlwZTogJ2Nvbm5lY3Rpb24tY29tcGxldGVkJywgaXNfc3VjY2VzczogdHJ1ZSB9LCBjcmVhdGVDb25uZWN0aW9uSW5mbyh2ZXJzaW9uLCB3YWxsZXQpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgY29ubmVjdGlvbiBlcnJvciBldmVudC5cbiAqIEBwYXJhbSB2ZXJzaW9uXG4gKiBAcGFyYW0gZXJyb3JfbWVzc2FnZVxuICogQHBhcmFtIGVycm9yQ29kZVxuICovXG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uRXJyb3JFdmVudCh2ZXJzaW9uLCBlcnJvcl9tZXNzYWdlLCBlcnJvckNvZGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnY29ubmVjdGlvbi1lcnJvcicsXG4gICAgICAgIGlzX3N1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcl9tZXNzYWdlOiBlcnJvcl9tZXNzYWdlLFxuICAgICAgICBlcnJvcl9jb2RlOiBlcnJvckNvZGUgIT09IG51bGwgJiYgZXJyb3JDb2RlICE9PSB2b2lkIDAgPyBlcnJvckNvZGUgOiBudWxsLFxuICAgICAgICBjdXN0b21fZGF0YTogY3JlYXRlVmVyc2lvbkluZm8odmVyc2lvbilcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBjb25uZWN0aW9uIHJlc3RvcmluZyBzdGFydGVkIGV2ZW50LlxuICovXG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uUmVzdG9yaW5nU3RhcnRlZEV2ZW50KHZlcnNpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnY29ubmVjdGlvbi1yZXN0b3Jpbmctc3RhcnRlZCcsXG4gICAgICAgIGN1c3RvbV9kYXRhOiBjcmVhdGVWZXJzaW9uSW5mbyh2ZXJzaW9uKVxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIGNvbm5lY3Rpb24gcmVzdG9yaW5nIGNvbXBsZXRlZCBldmVudC5cbiAqIEBwYXJhbSB2ZXJzaW9uXG4gKiBAcGFyYW0gd2FsbGV0XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb25SZXN0b3JpbmdDb21wbGV0ZWRFdmVudCh2ZXJzaW9uLCB3YWxsZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdjb25uZWN0aW9uLXJlc3RvcmluZy1jb21wbGV0ZWQnLCBpc19zdWNjZXNzOiB0cnVlIH0sIGNyZWF0ZUNvbm5lY3Rpb25JbmZvKHZlcnNpb24sIHdhbGxldCkpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBjb25uZWN0aW9uIHJlc3RvcmluZyBlcnJvciBldmVudC5cbiAqIEBwYXJhbSB2ZXJzaW9uXG4gKiBAcGFyYW0gZXJyb3JNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb25SZXN0b3JpbmdFcnJvckV2ZW50KHZlcnNpb24sIGVycm9yTWVzc2FnZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdjb25uZWN0aW9uLXJlc3RvcmluZy1lcnJvcicsXG4gICAgICAgIGlzX3N1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcl9tZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgIGN1c3RvbV9kYXRhOiBjcmVhdGVWZXJzaW9uSW5mbyh2ZXJzaW9uKVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVUcmFuc2FjdGlvbkluZm8od2FsbGV0LCB0cmFuc2FjdGlvbikge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZF91bnRpbDogKF9hID0gU3RyaW5nKHRyYW5zYWN0aW9uLnZhbGlkVW50aWwpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLFxuICAgICAgICBmcm9tOiAoX2QgPSAoX2IgPSB0cmFuc2FjdGlvbi5mcm9tKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoX2MgPSB3YWxsZXQgPT09IG51bGwgfHwgd2FsbGV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3YWxsZXQuYWNjb3VudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFkZHJlc3MpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG51bGwsXG4gICAgICAgIG1lc3NhZ2VzOiB0cmFuc2FjdGlvbi5tZXNzYWdlcy5tYXAobWVzc2FnZSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogKF9hID0gbWVzc2FnZS5hZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLFxuICAgICAgICAgICAgICAgIGFtb3VudDogKF9iID0gbWVzc2FnZS5hbW91bnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIHRyYW5zYWN0aW9uIGluaXQgZXZlbnQuXG4gKiBAcGFyYW0gdmVyc2lvblxuICogQHBhcmFtIHdhbGxldFxuICogQHBhcmFtIHRyYW5zYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zYWN0aW9uU2VudEZvclNpZ25hdHVyZUV2ZW50KHZlcnNpb24sIHdhbGxldCwgdHJhbnNhY3Rpb24pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdHlwZTogJ3RyYW5zYWN0aW9uLXNlbnQtZm9yLXNpZ25hdHVyZScgfSwgY3JlYXRlQ29ubmVjdGlvbkluZm8odmVyc2lvbiwgd2FsbGV0KSksIGNyZWF0ZVRyYW5zYWN0aW9uSW5mbyh3YWxsZXQsIHRyYW5zYWN0aW9uKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHRyYW5zYWN0aW9uIHNpZ25lZCBldmVudC5cbiAqIEBwYXJhbSB2ZXJzaW9uXG4gKiBAcGFyYW0gd2FsbGV0XG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSBzaWduZWRUcmFuc2FjdGlvblxuICovXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2FjdGlvblNpZ25lZEV2ZW50KHZlcnNpb24sIHdhbGxldCwgdHJhbnNhY3Rpb24sIHNpZ25lZFRyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHR5cGU6ICd0cmFuc2FjdGlvbi1zaWduZWQnLCBpc19zdWNjZXNzOiB0cnVlLCBzaWduZWRfdHJhbnNhY3Rpb246IHNpZ25lZFRyYW5zYWN0aW9uLmJvYyB9LCBjcmVhdGVDb25uZWN0aW9uSW5mbyh2ZXJzaW9uLCB3YWxsZXQpKSwgY3JlYXRlVHJhbnNhY3Rpb25JbmZvKHdhbGxldCwgdHJhbnNhY3Rpb24pKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgdHJhbnNhY3Rpb24gZXJyb3IgZXZlbnQuXG4gKiBAcGFyYW0gdmVyc2lvblxuICogQHBhcmFtIHdhbGxldFxuICogQHBhcmFtIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0gZXJyb3JNZXNzYWdlXG4gKiBAcGFyYW0gZXJyb3JDb2RlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zYWN0aW9uU2lnbmluZ0ZhaWxlZEV2ZW50KHZlcnNpb24sIHdhbGxldCwgdHJhbnNhY3Rpb24sIGVycm9yTWVzc2FnZSwgZXJyb3JDb2RlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHR5cGU6ICd0cmFuc2FjdGlvbi1zaWduaW5nLWZhaWxlZCcsIGlzX3N1Y2Nlc3M6IGZhbHNlLCBlcnJvcl9tZXNzYWdlOiBlcnJvck1lc3NhZ2UsIGVycm9yX2NvZGU6IGVycm9yQ29kZSAhPT0gbnVsbCAmJiBlcnJvckNvZGUgIT09IHZvaWQgMCA/IGVycm9yQ29kZSA6IG51bGwgfSwgY3JlYXRlQ29ubmVjdGlvbkluZm8odmVyc2lvbiwgd2FsbGV0KSksIGNyZWF0ZVRyYW5zYWN0aW9uSW5mbyh3YWxsZXQsIHRyYW5zYWN0aW9uKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhU2VudEZvclNpZ25hdHVyZUV2ZW50KHZlcnNpb24sIHdhbGxldCwgZGF0YSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgdHlwZTogJ3NpZ24tZGF0YS1yZXF1ZXN0LWluaXRpYXRlZCcsIGRhdGEgfSwgY3JlYXRlQ29ubmVjdGlvbkluZm8odmVyc2lvbiwgd2FsbGV0KSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhU2lnbmVkRXZlbnQodmVyc2lvbiwgd2FsbGV0LCBkYXRhLCBzaWduZWREYXRhKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB0eXBlOiAnc2lnbi1kYXRhLXJlcXVlc3QtY29tcGxldGVkJywgaXNfc3VjY2VzczogdHJ1ZSwgZGF0YSwgc2lnbmVkX2RhdGE6IHNpZ25lZERhdGEgfSwgY3JlYXRlQ29ubmVjdGlvbkluZm8odmVyc2lvbiwgd2FsbGV0KSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhU2lnbmluZ0ZhaWxlZEV2ZW50KHZlcnNpb24sIHdhbGxldCwgZGF0YSwgZXJyb3JNZXNzYWdlLCBlcnJvckNvZGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdzaWduLWRhdGEtcmVxdWVzdC1mYWlsZWQnLCBpc19zdWNjZXNzOiBmYWxzZSwgZGF0YSwgZXJyb3JfbWVzc2FnZTogZXJyb3JNZXNzYWdlLCBlcnJvcl9jb2RlOiBlcnJvckNvZGUgIT09IG51bGwgJiYgZXJyb3JDb2RlICE9PSB2b2lkIDAgPyBlcnJvckNvZGUgOiBudWxsIH0sIGNyZWF0ZUNvbm5lY3Rpb25JbmZvKHZlcnNpb24sIHdhbGxldCkpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBkaXNjb25uZWN0IGV2ZW50LlxuICogQHBhcmFtIHZlcnNpb25cbiAqIEBwYXJhbSB3YWxsZXRcbiAqIEBwYXJhbSBzY29wZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzY29ubmVjdGlvbkV2ZW50KHZlcnNpb24sIHdhbGxldCwgc2NvcGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdkaXNjb25uZWN0aW9uJywgc2NvcGU6IHNjb3BlIH0sIGNyZWF0ZUNvbm5lY3Rpb25JbmZvKHZlcnNpb24sIHdhbGxldCkpO1xufVxuXG4vKipcbiAqIEEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgRXZlbnREaXNwYXRjaGVyIHRoYXQgZGlzcGF0Y2hlcyBldmVudHMgdG8gdGhlIGJyb3dzZXIgd2luZG93LlxuICovXG5jbGFzcyBCcm93c2VyRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB3aW5kb3cgb2JqZWN0LCBwb3NzaWJseSB1bmRlZmluZWQgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaGVzIGFuIGV2ZW50IHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIGRldGFpbHMgdG8gdGhlIGJyb3dzZXIgd2luZG93LlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZGlzcGF0Y2guXG4gICAgICogQHBhcmFtIGV2ZW50RGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBldmVudCB0byBkaXNwYXRjaC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBldmVudCBoYXMgYmVlbiBkaXNwYXRjaGVkLlxuICAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnROYW1lLCBldmVudERldGFpbHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7IGRldGFpbDogZXZlbnREZXRhaWxzIH0pO1xuICAgICAgICAgICAgKF9hID0gdGhpcy53aW5kb3cpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGJyb3dzZXIgd2luZG93LlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvci5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgdG8gYWRkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgbGlzdGVuZXIuXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMud2luZG93KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiAoX2EgPSB0aGlzLndpbmRvdykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogVHJhY2tlciBmb3IgVG9uQ29ubmVjdCB1c2VyIGFjdGlvbnMsIHN1Y2ggYXMgdHJhbnNhY3Rpb24gc2lnbmluZywgY29ubmVjdGlvbiwgZXRjLlxuICpcbiAqIExpc3Qgb2YgZXZlbnRzOlxuICogICogYGNvbm5lY3Rpb24tc3RhcnRlZGA6IHdoZW4gYSB1c2VyIHN0YXJ0cyBjb25uZWN0aW5nIGEgd2FsbGV0LlxuICogICogYGNvbm5lY3Rpb24tY29tcGxldGVkYDogd2hlbiBhIHVzZXIgc3VjY2Vzc2Z1bGx5IGNvbm5lY3RlZCBhIHdhbGxldC5cbiAqICAqIGBjb25uZWN0aW9uLWVycm9yYDogd2hlbiBhIHVzZXIgY2FuY2VscyBhIGNvbm5lY3Rpb24gb3IgdGhlcmUgaXMgYW4gZXJyb3IgZHVyaW5nIHRoZSBjb25uZWN0aW9uIHByb2Nlc3MuXG4gKiAgKiBgY29ubmVjdGlvbi1yZXN0b3Jpbmctc3RhcnRlZGA6IHdoZW4gdGhlIGRBcHAgc3RhcnRzIHJlc3RvcmluZyBhIGNvbm5lY3Rpb24uXG4gKiAgKiBgY29ubmVjdGlvbi1yZXN0b3JpbmctY29tcGxldGVkYDogd2hlbiB0aGUgZEFwcCBzdWNjZXNzZnVsbHkgcmVzdG9yZXMgYSBjb25uZWN0aW9uLlxuICogICogYGNvbm5lY3Rpb24tcmVzdG9yaW5nLWVycm9yYDogd2hlbiB0aGUgZEFwcCBmYWlscyB0byByZXN0b3JlIGEgY29ubmVjdGlvbi5cbiAqICAqIGBkaXNjb25uZWN0aW9uYDogd2hlbiBhIHVzZXIgc3RhcnRzIGRpc2Nvbm5lY3RpbmcgYSB3YWxsZXQuXG4gKiAgKiBgdHJhbnNhY3Rpb24tc2VudC1mb3Itc2lnbmF0dXJlYDogd2hlbiBhIHVzZXIgc2VuZHMgYSB0cmFuc2FjdGlvbiBmb3Igc2lnbmF0dXJlLlxuICogICogYHRyYW5zYWN0aW9uLXNpZ25lZGA6IHdoZW4gYSB1c2VyIHN1Y2Nlc3NmdWxseSBzaWducyBhIHRyYW5zYWN0aW9uLlxuICogICogYHRyYW5zYWN0aW9uLXNpZ25pbmctZmFpbGVkYDogd2hlbiBhIHVzZXIgY2FuY2VscyB0cmFuc2FjdGlvbiBzaWduaW5nIG9yIHRoZXJlIGlzIGFuIGVycm9yIGR1cmluZyB0aGUgc2lnbmluZyBwcm9jZXNzLlxuICogICogYHNpZ24tZGF0YS1yZXF1ZXN0LWluaXRpYXRlZGA6IHdoZW4gYSB1c2VyIHNlbmRzIGRhdGEgZm9yIHNpZ25hdHVyZS5cbiAqICAqIGBzaWduLWRhdGEtcmVxdWVzdC1jb21wbGV0ZWRgOiB3aGVuIGEgdXNlciBzdWNjZXNzZnVsbHkgc2lnbnMgZGF0YS5cbiAqICAqIGBzaWduLWRhdGEtcmVxdWVzdC1mYWlsZWRgOiB3aGVuIGEgdXNlciBjYW5jZWxzIGRhdGEgc2lnbmluZyBvciB0aGVyZSBpcyBhbiBlcnJvciBkdXJpbmcgdGhlIHNpZ25pbmcgcHJvY2Vzcy5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byB0cmFjayB1c2VyIGFjdGlvbnMsIHlvdSBjYW4gc3Vic2NyaWJlIHRvIHRoZSB3aW5kb3cgZXZlbnRzIHdpdGggcHJlZml4IGB0b24tY29ubmVjdC1gOlxuICpcbiAqIEBleGFtcGxlXG4gKiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG9uLWNvbm5lY3QtdHJhbnNhY3Rpb24tc2VudC1mb3Itc2lnbmF0dXJlJywgKGV2ZW50KSA9PiB7XG4gKiAgICBjb25zb2xlLmxvZygnVHJhbnNhY3Rpb24gaW5pdCcsIGV2ZW50LmRldGFpbCk7XG4gKiB9KTtcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgVG9uQ29ubmVjdFRyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgcHJlZml4IGZvciB1c2VyIGFjdGlvbnMuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2ZW50UHJlZml4ID0gJ3Rvbi1jb25uZWN0LSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb25Db25uZWN0IFVJIHZlcnNpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvbkNvbm5lY3RVaVZlcnNpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlciA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ldmVudERpc3BhdGNoZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBCcm93c2VyRXZlbnREaXNwYXRjaGVyKCk7XG4gICAgICAgIHRoaXMudG9uQ29ubmVjdFNka1ZlcnNpb24gPSBvcHRpb25zLnRvbkNvbm5lY3RTZGtWZXJzaW9uO1xuICAgICAgICB0aGlzLmluaXQoKS5jYXRjaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJzaW9uIG9mIHRoZSBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlVmVyc2lvbkluZm8oe1xuICAgICAgICAgICAgdG9uX2Nvbm5lY3Rfc2RrX2xpYjogdGhpcy50b25Db25uZWN0U2RrVmVyc2lvbixcbiAgICAgICAgICAgIHRvbl9jb25uZWN0X3VpX2xpYjogdGhpcy50b25Db25uZWN0VWlWZXJzaW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb25jZSB3aGVuIHRoZSB0cmFja2VyIGlzIGNyZWF0ZWQgYW5kIHJlcXVlc3QgdmVyc2lvbiBvdGhlciBsaWJyYXJpZXMuXG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5zZXRSZXF1ZXN0VmVyc2lvbkhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvbkNvbm5lY3RVaVZlcnNpb24gPSB5aWVsZCB0aGlzLnJlcXVlc3RUb25Db25uZWN0VWlWZXJzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgcmVxdWVzdCB2ZXJzaW9uIGhhbmRsZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZXRSZXF1ZXN0VmVyc2lvbkhhbmRsZXIoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmV2ZW50RGlzcGF0Y2hlci5hZGRFdmVudExpc3RlbmVyKCd0b24tY29ubmVjdC1yZXF1ZXN0LXZlcnNpb24nLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5ldmVudERpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudCgndG9uLWNvbm5lY3QtcmVzcG9uc2UtdmVyc2lvbicsIGNyZWF0ZVJlc3BvbnNlVmVyc2lvbkV2ZW50KHRoaXMudG9uQ29ubmVjdFNka1ZlcnNpb24pKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgVG9uQ29ubmVjdCBVSSB2ZXJzaW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVxdWVzdFRvbkNvbm5lY3RVaVZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZXZlbnREaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Rvbi1jb25uZWN0LXVpLXJlc3BvbnNlLXZlcnNpb24nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQuZGV0YWlsLnZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICB9LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZXZlbnREaXNwYXRjaGVyLmRpc3BhdGNoRXZlbnQoJ3Rvbi1jb25uZWN0LXVpLXJlcXVlc3QtdmVyc2lvbicsIGNyZWF0ZVJlcXVlc3RWZXJzaW9uRXZlbnQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0IHVzZXIgYWN0aW9uIGV2ZW50IHRvIHRoZSB3aW5kb3cuXG4gICAgICogQHBhcmFtIGV2ZW50RGV0YWlsc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnREZXRhaWxzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlclxuICAgICAgICAgICAgICAgIC5kaXNwYXRjaEV2ZW50KGAke3RoaXMuZXZlbnRQcmVmaXh9JHtldmVudERldGFpbHMudHlwZX1gLCBldmVudERldGFpbHMpXG4gICAgICAgICAgICAgICAgLmNhdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFjayBjb25uZWN0aW9uIGluaXQgZXZlbnQuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB0cmFja0Nvbm5lY3Rpb25TdGFydGVkKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlQ29ubmVjdGlvblN0YXJ0ZWRFdmVudCh0aGlzLnZlcnNpb24sIC4uLmFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFVzZXJBY3Rpb25FdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFjayBjb25uZWN0aW9uIHN1Y2Nlc3MgZXZlbnQuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB0cmFja0Nvbm5lY3Rpb25Db21wbGV0ZWQoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVDb25uZWN0aW9uQ29tcGxldGVkRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2sgY29ubmVjdGlvbiBlcnJvciBldmVudC5cbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIHRyYWNrQ29ubmVjdGlvbkVycm9yKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlQ29ubmVjdGlvbkVycm9yRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2sgY29ubmVjdGlvbiByZXN0b3JpbmcgaW5pdCBldmVudC5cbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIHRyYWNrQ29ubmVjdGlvblJlc3RvcmluZ1N0YXJ0ZWQoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVDb25uZWN0aW9uUmVzdG9yaW5nU3RhcnRlZEV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYWNrIGNvbm5lY3Rpb24gcmVzdG9yaW5nIHN1Y2Nlc3MgZXZlbnQuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB0cmFja0Nvbm5lY3Rpb25SZXN0b3JpbmdDb21wbGV0ZWQoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVDb25uZWN0aW9uUmVzdG9yaW5nQ29tcGxldGVkRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2sgY29ubmVjdGlvbiByZXN0b3JpbmcgZXJyb3IgZXZlbnQuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB0cmFja0Nvbm5lY3Rpb25SZXN0b3JpbmdFcnJvciguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGNyZWF0ZUNvbm5lY3Rpb25SZXN0b3JpbmdFcnJvckV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYWNrIGRpc2Nvbm5lY3QgZXZlbnQuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB0cmFja0Rpc2Nvbm5lY3Rpb24oLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVEaXNjb25uZWN0aW9uRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2sgdHJhbnNhY3Rpb24gaW5pdCBldmVudC5cbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIHRyYWNrVHJhbnNhY3Rpb25TZW50Rm9yU2lnbmF0dXJlKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlVHJhbnNhY3Rpb25TZW50Rm9yU2lnbmF0dXJlRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2sgdHJhbnNhY3Rpb24gc2lnbmVkIGV2ZW50LlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgdHJhY2tUcmFuc2FjdGlvblNpZ25lZCguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGNyZWF0ZVRyYW5zYWN0aW9uU2lnbmVkRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2sgdHJhbnNhY3Rpb24gZXJyb3IgZXZlbnQuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB0cmFja1RyYW5zYWN0aW9uU2lnbmluZ0ZhaWxlZCguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGNyZWF0ZVRyYW5zYWN0aW9uU2lnbmluZ0ZhaWxlZEV2ZW50KHRoaXMudmVyc2lvbiwgLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXNlckFjdGlvbkV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYWNrIHNpZ24gZGF0YSBpbml0IGV2ZW50LlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgdHJhY2tEYXRhU2VudEZvclNpZ25hdHVyZSguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGNyZWF0ZURhdGFTZW50Rm9yU2lnbmF0dXJlRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2sgc2lnbiBkYXRhIHN1Y2Nlc3MgZXZlbnQuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB0cmFja0RhdGFTaWduZWQoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVEYXRhU2lnbmVkRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2sgc2lnbiBkYXRhIGVycm9yIGV2ZW50LlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgdHJhY2tEYXRhU2lnbmluZ0ZhaWxlZCguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGNyZWF0ZURhdGFTaWduaW5nRmFpbGVkRXZlbnQodGhpcy52ZXJzaW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVc2VyQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG59XG5cbmNvbnN0IHRvbkNvbm5lY3RTZGtWZXJzaW9uID0gXCIzLjIuMFwiO1xuXG5jbGFzcyBUb25Db25uZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMud2FsbGV0c0xpc3QgPSBuZXcgV2FsbGV0c0xpc3RNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuX3dhbGxldCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXR1c0NoYW5nZVN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2VFcnJvclN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5kYXBwU2V0dGluZ3MgPSB7XG4gICAgICAgICAgICBtYW5pZmVzdFVybDogKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYW5pZmVzdFVybCkgfHwgZ2V0V2ViUGFnZU1hbmlmZXN0KCksXG4gICAgICAgICAgICBzdG9yYWdlOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnN0b3JhZ2UpIHx8IG5ldyBEZWZhdWx0U3RvcmFnZSgpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2FsbGV0c1JlcXVpcmVkRmVhdHVyZXMgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud2FsbGV0c1JlcXVpcmVkRmVhdHVyZXM7XG4gICAgICAgIHRoaXMud2FsbGV0c0xpc3QgPSBuZXcgV2FsbGV0c0xpc3RNYW5hZ2VyKHtcbiAgICAgICAgICAgIHdhbGxldHNMaXN0U291cmNlOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud2FsbGV0c0xpc3RTb3VyY2UsXG4gICAgICAgICAgICBjYWNoZVRUTE1zOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud2FsbGV0c0xpc3RDYWNoZVRUTE1zXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYWNrZXIgPSBuZXcgVG9uQ29ubmVjdFRyYWNrZXIoe1xuICAgICAgICAgICAgZXZlbnREaXNwYXRjaGVyOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZXZlbnREaXNwYXRjaGVyLFxuICAgICAgICAgICAgdG9uQ29ubmVjdFNka1ZlcnNpb246IHRvbkNvbm5lY3RTZGtWZXJzaW9uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMuZGFwcFNldHRpbmdzLm1hbmlmZXN0VXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRGFwcE1ldGFkYXRhRXJyb3IoJ0RhcHAgdG9uY29ubmVjdC1tYW5pZmVzdC5qc29uIG11c3QgYmUgc3BlY2lmaWVkIGlmIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gaXMgdW5kZWZpbmVkLiBTZWUgbW9yZSBodHRwczovL2dpdGh1Yi5jb20vdG9uLWNvbm5lY3QvZG9jcy9ibG9iL21haW4vcmVxdWVzdHMtcmVzcG9uc2VzLm1kI2FwcC1tYW5pZmVzdCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UgPSBuZXcgQnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UodGhpcy5kYXBwU2V0dGluZ3Muc3RvcmFnZSk7XG4gICAgICAgIGlmICghKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kaXNhYmxlQXV0b1BhdXNlQ29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkV2luZG93Rm9jdXNBbmRCbHVyU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYXZhaWxhYmxlIHdhbGxldHMgbGlzdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0V2FsbGV0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2FsbGV0c0xpc3QuZ2V0V2FsbGV0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyBpZiB0aGUgd2FsbGV0IGlzIGNvbm5lY3RlZCByaWdodCBub3cuXG4gICAgICovXG4gICAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dhbGxldCAhPT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3VycmVudCBjb25uZWN0ZWQgYWNjb3VudCBvciBudWxsIGlmIG5vIGFjY291bnQgaXMgY29ubmVjdGVkLlxuICAgICAqL1xuICAgIGdldCBhY2NvdW50KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5fd2FsbGV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjb3VudCkgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3VycmVudCBjb25uZWN0ZWQgd2FsbGV0IG9yIG51bGwgaWYgbm8gYWNjb3VudCBpcyBjb25uZWN0ZWQuXG4gICAgICovXG4gICAgZ2V0IHdhbGxldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dhbGxldDtcbiAgICB9XG4gICAgc2V0IHdhbGxldCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl93YWxsZXQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2VTdWJzY3JpcHRpb25zLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2sodGhpcy5fd2FsbGV0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYXZhaWxhYmxlIHdhbGxldHMgbGlzdC5cbiAgICAgKi9cbiAgICBnZXRXYWxsZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53YWxsZXRzTGlzdC5nZXRXYWxsZXRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0byBzdWJzY3JpYmUgdG8gY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlcyBhbmQgaGFuZGxlIGNvbm5lY3Rpb24gZXJyb3JzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciBjb25uZWN0aW9ucyBzdGF0dXMgY2hhbmdlcyB3aXRoIGFjdHVhbCB3YWxsZXQgb3IgbnVsbC5cbiAgICAgKiBAcGFyYW0gZXJyb3JzSGFuZGxlciAob3B0aW9uYWwpIHdpbGwgYmUgY2FsbGVkIHdpdGggc29tZSBpbnN0YW5jZSBvZiBUb25Db25uZWN0RXJyb3Igd2hlbiBjb25uZWN0IGVycm9yIGlzIHJlY2VpdmVkLlxuICAgICAqIEByZXR1cm5zIHVuc3Vic2NyaWJlIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIG9uU3RhdHVzQ2hhbmdlKGNhbGxiYWNrLCBlcnJvcnNIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlU3Vic2NyaXB0aW9ucy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGVycm9yc0hhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlRXJyb3JTdWJzY3JpcHRpb25zLnB1c2goZXJyb3JzSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlU3Vic2NyaXB0aW9ucyA9IHRoaXMuc3RhdHVzQ2hhbmdlU3Vic2NyaXB0aW9ucy5maWx0ZXIoaXRlbSA9PiBpdGVtICE9PSBjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoZXJyb3JzSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlRXJyb3JTdWJzY3JpcHRpb25zID0gdGhpcy5zdGF0dXNDaGFuZ2VFcnJvclN1YnNjcmlwdGlvbnMuZmlsdGVyKGl0ZW0gPT4gaXRlbSAhPT0gZXJyb3JzSGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbm5lY3Qod2FsbGV0LCByZXF1ZXN0T3JPcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSBkZXByZWNhdGVkIG1ldGhvZFxuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdE9yT3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgJ3RvblByb29mJyBpbiByZXF1ZXN0T3JPcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zLnJlcXVlc3QgPSByZXF1ZXN0T3JPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdE9yT3B0aW9ucyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICgnb3BlbmluZ0RlYWRsaW5lTVMnIGluIHJlcXVlc3RPck9wdGlvbnMgfHxcbiAgICAgICAgICAgICAgICAnc2lnbmFsJyBpbiByZXF1ZXN0T3JPcHRpb25zIHx8XG4gICAgICAgICAgICAgICAgJ3JlcXVlc3QnIGluIHJlcXVlc3RPck9wdGlvbnMpKSB7XG4gICAgICAgICAgICBvcHRpb25zLnJlcXVlc3QgPSByZXF1ZXN0T3JPcHRpb25zID09PSBudWxsIHx8IHJlcXVlc3RPck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcXVlc3RPck9wdGlvbnMucmVxdWVzdDtcbiAgICAgICAgICAgIG9wdGlvbnMub3BlbmluZ0RlYWRsaW5lTVMgPSByZXF1ZXN0T3JPcHRpb25zID09PSBudWxsIHx8IHJlcXVlc3RPck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcXVlc3RPck9wdGlvbnMub3BlbmluZ0RlYWRsaW5lTVM7XG4gICAgICAgICAgICBvcHRpb25zLnNpZ25hbCA9IHJlcXVlc3RPck9wdGlvbnMgPT09IG51bGwgfHwgcmVxdWVzdE9yT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVxdWVzdE9yT3B0aW9ucy5zaWduYWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0QWxyZWFkeUNvbm5lY3RlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWwpO1xuICAgICAgICAoX2EgPSB0aGlzLmFib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFib3J0KCk7XG4gICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gYWJvcnRDb250cm9sbGVyO1xuICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdDb25uZWN0aW9uIHdhcyBhYm9ydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgKF9iID0gdGhpcy5wcm92aWRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNsb3NlQ29ubmVjdGlvbigpO1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gdGhpcy5jcmVhdGVQcm92aWRlcih3YWxsZXQpO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5wcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlciA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uU3RhcnRlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5jb25uZWN0KHRoaXMuY3JlYXRlQ29ubmVjdFJlcXVlc3Qob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlcXVlc3QpLCB7XG4gICAgICAgICAgICBvcGVuaW5nRGVhZGxpbmVNUzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wZW5pbmdEZWFkbGluZU1TLFxuICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnkgdG8gcmVzdG9yZSBleGlzdGluZyBzZXNzaW9uIGFuZCByZWNvbm5lY3QgdG8gdGhlIGNvcnJlc3BvbmRpbmcgd2FsbGV0LiBDYWxsIGl0IGltbWVkaWF0ZWx5IHdoZW4geW91ciBhcHAgaXMgbG9hZGVkLlxuICAgICAqL1xuICAgIHJlc3RvcmVDb25uZWN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25SZXN0b3JpbmdTdGFydGVkKCk7XG4gICAgICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmFib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFib3J0KCk7XG4gICAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IGFib3J0Q29udHJvbGxlcjtcbiAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uUmVzdG9yaW5nRXJyb3IoJ0Nvbm5lY3Rpb24gcmVzdG9yaW5nIHdhcyBhYm9ydGVkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogcG90ZW50aWFsbHkgcmFjZSBjb25kaXRpb24gaGVyZVxuICAgICAgICAgICAgY29uc3QgW2JyaWRnZUNvbm5lY3Rpb25UeXBlLCBlbWJlZGRlZFdhbGxldF0gPSB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5icmlkZ2VDb25uZWN0aW9uU3RvcmFnZS5zdG9yZWRDb25uZWN0aW9uVHlwZSgpLFxuICAgICAgICAgICAgICAgIHRoaXMud2FsbGV0c0xpc3QuZ2V0RW1iZWRkZWRXYWxsZXQoKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrQ29ubmVjdGlvblJlc3RvcmluZ0Vycm9yKCdDb25uZWN0aW9uIHJlc3RvcmluZyB3YXMgYWJvcnRlZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwcm92aWRlciA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYnJpZGdlQ29ubmVjdGlvblR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaHR0cCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlciA9IHlpZWxkIEJyaWRnZVByb3ZpZGVyLmZyb21TdG9yYWdlKHRoaXMuZGFwcFNldHRpbmdzLnN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2luamVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0geWllbGQgSW5qZWN0ZWRQcm92aWRlci5mcm9tU3RvcmFnZSh0aGlzLmRhcHBTZXR0aW5ncy5zdG9yYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVtYmVkZGVkV2FsbGV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSB0aGlzLmNyZWF0ZVByb3ZpZGVyKGVtYmVkZGVkV2FsbGV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uUmVzdG9yaW5nRXJyb3IoJ1Byb3ZpZGVyIGlzIG5vdCByZXN0b3JlZCcpO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuYnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UucmVtb3ZlQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyID09PSBudWxsIHx8IHByb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm92aWRlci5jbG9zZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBwcm92aWRlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyID09PSBudWxsIHx8IHByb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm92aWRlci5jbG9zZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uUmVzdG9yaW5nRXJyb3IoJ0Nvbm5lY3Rpb24gcmVzdG9yaW5nIHdhcyBhYm9ydGVkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdQcm92aWRlciBpcyBub3QgcmVzdG9yZWQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uUmVzdG9yaW5nRXJyb3IoJ1Byb3ZpZGVyIGlzIG5vdCByZXN0b3JlZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IHRoaXMucHJvdmlkZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jbG9zZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgICAgIHByb3ZpZGVyLmxpc3Rlbih0aGlzLndhbGxldEV2ZW50c0xpc3RlbmVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgY29uc3Qgb25BYm9ydFJlc3RvcmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrQ29ubmVjdGlvblJlc3RvcmluZ0Vycm9yKCdDb25uZWN0aW9uIHJlc3RvcmluZyB3YXMgYWJvcnRlZCcpO1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyID09PSBudWxsIHx8IHByb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm92aWRlci5jbG9zZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBwcm92aWRlciA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQWJvcnRSZXN0b3JlKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3RvcmVDb25uZWN0aW9uVGFzayA9IGNhbGxGb3JTdWNjZXNzKChfb3B0aW9ucykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIChwcm92aWRlciA9PT0gbnVsbCB8fCBwcm92aWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvdmlkZXIucmVzdG9yZUNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICBvcGVuaW5nRGVhZGxpbmVNUzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wZW5pbmdEZWFkbGluZU1TLFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IF9vcHRpb25zLnNpZ25hbFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25BYm9ydFJlc3RvcmUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tDb25uZWN0aW9uUmVzdG9yaW5nQ29tcGxldGVkKHRoaXMud2FsbGV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25SZXN0b3JpbmdFcnJvcignQ29ubmVjdGlvbiByZXN0b3JpbmcgZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksIHtcbiAgICAgICAgICAgICAgICBhdHRlbXB0czogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICAgICAgZGVsYXlNczogMjAwMCxcbiAgICAgICAgICAgICAgICBzaWduYWw6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdG9yZUNvbm5lY3Rpb25UaW1lb3V0ID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoKSwgMTIwMDApIC8vIGNvbm5lY3Rpb24gZGVhZGxpbmVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtyZXN0b3JlQ29ubmVjdGlvblRhc2ssIHJlc3RvcmVDb25uZWN0aW9uVGltZW91dF0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBvcHRpb25zT3JPblJlcXVlc3RTZW50KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgZGVwcmVjYXRlZCBtZXRob2RcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZXF1ZXN0U2VudCA9IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVxdWVzdFNlbnQgPSBvcHRpb25zT3JPblJlcXVlc3RTZW50ID09PSBudWxsIHx8IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQub25SZXF1ZXN0U2VudDtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbCA9IG9wdGlvbnNPck9uUmVxdWVzdFNlbnQgPT09IG51bGwgfHwgb3B0aW9uc09yT25SZXF1ZXN0U2VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uc09yT25SZXF1ZXN0U2VudC5zaWduYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCk7XG4gICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignVHJhbnNhY3Rpb24gc2VuZGluZyB3YXMgYWJvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkTWVzc2FnZXNOdW1iZXIgPSB0cmFuc2FjdGlvbi5tZXNzYWdlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCByZXF1aXJlRXh0cmFDdXJyZW5jaWVzID0gdHJhbnNhY3Rpb24ubWVzc2FnZXMuc29tZShtID0+IG0uZXh0cmFDdXJyZW5jeSAmJiBPYmplY3Qua2V5cyhtLmV4dHJhQ3VycmVuY3kpLmxlbmd0aCA+IDApO1xuICAgICAgICAgICAgY2hlY2tTZW5kVHJhbnNhY3Rpb25TdXBwb3J0KHRoaXMud2FsbGV0LmRldmljZS5mZWF0dXJlcywge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkTWVzc2FnZXNOdW1iZXIsXG4gICAgICAgICAgICAgICAgcmVxdWlyZUV4dHJhQ3VycmVuY2llc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tUcmFuc2FjdGlvblNlbnRGb3JTaWduYXR1cmUodGhpcy53YWxsZXQsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsaWRVbnRpbCwgbWVzc2FnZXMgfSA9IHRyYW5zYWN0aW9uLCB0eCA9IF9fcmVzdCh0cmFuc2FjdGlvbiwgW1widmFsaWRVbnRpbFwiLCBcIm1lc3NhZ2VzXCJdKTtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSB0cmFuc2FjdGlvbi5mcm9tIHx8IHRoaXMuYWNjb3VudC5hZGRyZXNzO1xuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IHRyYW5zYWN0aW9uLm5ldHdvcmsgfHwgdGhpcy5hY2NvdW50LmNoYWluO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLnNlbmRSZXF1ZXN0KHNlbmRUcmFuc2FjdGlvblBhcnNlci5jb252ZXJ0VG9ScGNSZXF1ZXN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHgpLCB7IGZyb20sXG4gICAgICAgICAgICAgICAgbmV0d29yaywgdmFsaWRfdW50aWw6IHZhbGlkVW50aWwsIG1lc3NhZ2VzOiBtZXNzYWdlcy5tYXAoKF9hKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB7IGV4dHJhQ3VycmVuY3kgfSA9IF9hLCBtc2cgPSBfX3Jlc3QoX2EsIFtcImV4dHJhQ3VycmVuY3lcIl0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbXNnKSwgeyBleHRyYV9jdXJyZW5jeTogZXh0cmFDdXJyZW5jeSB9KSk7XG4gICAgICAgICAgICAgICAgfSkgfSkpLCB7IG9uUmVxdWVzdFNlbnQ6IG9wdGlvbnMub25SZXF1ZXN0U2VudCwgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsIH0pO1xuICAgICAgICAgICAgaWYgKHNlbmRUcmFuc2FjdGlvblBhcnNlci5pc0Vycm9yKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja1RyYW5zYWN0aW9uU2lnbmluZ0ZhaWxlZCh0aGlzLndhbGxldCwgdHJhbnNhY3Rpb24sIHJlc3BvbnNlLmVycm9yLm1lc3NhZ2UsIHJlc3BvbnNlLmVycm9yLmNvZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZW5kVHJhbnNhY3Rpb25QYXJzZXIucGFyc2VBbmRUaHJvd0Vycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNlbmRUcmFuc2FjdGlvblBhcnNlci5jb252ZXJ0RnJvbVJwY1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja1RyYW5zYWN0aW9uU2lnbmVkKHRoaXMud2FsbGV0LCB0cmFuc2FjdGlvbiwgcmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduRGF0YShkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCk7XG4gICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignZGF0YSBzZW5kaW5nIHdhcyBhYm9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgY2hlY2tTaWduRGF0YVN1cHBvcnQodGhpcy53YWxsZXQuZGV2aWNlLmZlYXR1cmVzLCB7IHJlcXVpcmVkVHlwZXM6IFtkYXRhLnR5cGVdIH0pO1xuICAgICAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrRGF0YVNlbnRGb3JTaWduYXR1cmUodGhpcy53YWxsZXQsIGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IGRhdGEuZnJvbSB8fCB0aGlzLmFjY291bnQuYWRkcmVzcztcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBkYXRhLm5ldHdvcmsgfHwgdGhpcy5hY2NvdW50LmNoYWluO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLnNlbmRSZXF1ZXN0KHNpZ25EYXRhUGFyc2VyLmNvbnZlcnRUb1JwY1JlcXVlc3QoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgeyBmcm9tLFxuICAgICAgICAgICAgICAgIG5ldHdvcmsgfSkpLCB7IG9uUmVxdWVzdFNlbnQ6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vblJlcXVlc3RTZW50LCBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwgfSk7XG4gICAgICAgICAgICBpZiAoc2lnbkRhdGFQYXJzZXIuaXNFcnJvcihyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrZXIudHJhY2tEYXRhU2lnbmluZ0ZhaWxlZCh0aGlzLndhbGxldCwgZGF0YSwgcmVzcG9uc2UuZXJyb3IubWVzc2FnZSwgcmVzcG9uc2UuZXJyb3IuY29kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25EYXRhUGFyc2VyLnBhcnNlQW5kVGhyb3dFcnJvcihyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzaWduRGF0YVBhcnNlci5jb252ZXJ0RnJvbVJwY1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja0RhdGFTaWduZWQodGhpcy53YWxsZXQsIGRhdGEsIHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCBmb3JtIHRodyBjb25uZWN0ZWQgd2FsbGV0IGFuZCBkcm9wIGN1cnJlbnQgc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWwpO1xuICAgICAgICAgICAgY29uc3QgcHJldkFib3J0Q29udHJvbGxlciA9IHRoaXMuYWJvcnRDb250cm9sbGVyO1xuICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignRGlzY29ubmVjdCB3YXMgYWJvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vbldhbGxldERpc2Nvbm5lY3RlZCgnZGFwcCcpO1xuICAgICAgICAgICAgeWllbGQgKChfYSA9IHRoaXMucHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KHtcbiAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHByZXZBYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgcHJldkFib3J0Q29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldkFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2UgYnJpZGdlIEhUVFAgY29ubmVjdGlvbi4gTWlnaHQgYmUgaGVscGZ1bCwgaWYgeW91IHdhbnQgdG8gcGF1c2UgY29ubmVjdGlvbnMgd2hpbGUgYnJvd3NlciB0YWIgaXMgdW5mb2N1c2VkLFxuICAgICAqIG9yIGlmIHlvdSB1c2UgU0RLIHdpdGggTm9kZUpTIGFuZCB3YW50IHRvIHNhdmUgc2VydmVyIHJlc291cmNlcy5cbiAgICAgKi9cbiAgICBwYXVzZUNvbm5lY3Rpb24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgIT09ICdodHRwJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvdmlkZXIucGF1c2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5wYXVzZSBicmlkZ2UgSFRUUCBjb25uZWN0aW9uIGlmIGl0IGlzIHBhdXNlZC5cbiAgICAgKi9cbiAgICB1blBhdXNlQ29ubmVjdGlvbigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMucHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSAhPT0gJ2h0dHAnKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIudW5QYXVzZSgpO1xuICAgIH1cbiAgICBhZGRXaW5kb3dGb2N1c0FuZEJsdXJTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF1c2VDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuUGF1c2VDb25uZWN0aW9uKCkuY2F0Y2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nRXJyb3IoJ0Nhbm5vdCBzdWJzY3JpYmUgdG8gdGhlIGRvY3VtZW50LnZpc2liaWxpdHljaGFuZ2U6ICcsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVByb3ZpZGVyKHdhbGxldCkge1xuICAgICAgICBsZXQgcHJvdmlkZXI7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh3YWxsZXQpICYmIGlzV2FsbGV0Q29ubmVjdGlvblNvdXJjZUpTKHdhbGxldCkpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyID0gbmV3IEluamVjdGVkUHJvdmlkZXIodGhpcy5kYXBwU2V0dGluZ3Muc3RvcmFnZSwgd2FsbGV0LmpzQnJpZGdlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb3ZpZGVyID0gbmV3IEJyaWRnZVByb3ZpZGVyKHRoaXMuZGFwcFNldHRpbmdzLnN0b3JhZ2UsIHdhbGxldCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvdmlkZXIubGlzdGVuKHRoaXMud2FsbGV0RXZlbnRzTGlzdGVuZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybiBwcm92aWRlcjtcbiAgICB9XG4gICAgd2FsbGV0RXZlbnRzTGlzdGVuZXIoZSkge1xuICAgICAgICBzd2l0Y2ggKGUuZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3QnOlxuICAgICAgICAgICAgICAgIHRoaXMub25XYWxsZXRDb25uZWN0ZWQoZS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RfZXJyb3InOlxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tlci50cmFja0Nvbm5lY3Rpb25FcnJvcihlLnBheWxvYWQubWVzc2FnZSwgZS5wYXlsb2FkLmNvZGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhbGxldEVycm9yID0gY29ubmVjdEVycm9yc1BhcnNlci5wYXJzZUVycm9yKGUucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbldhbGxldENvbm5lY3RFcnJvcih3YWxsZXRFcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0JzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uV2FsbGV0RGlzY29ubmVjdGVkKCd3YWxsZXQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbldhbGxldENvbm5lY3RlZChjb25uZWN0RXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB0b25BY2NvdW50SXRlbSA9IGNvbm5lY3RFdmVudC5pdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09PSAndG9uX2FkZHInKTtcbiAgICAgICAgY29uc3QgdG9uUHJvb2ZJdGVtID0gY29ubmVjdEV2ZW50Lml0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLm5hbWUgPT09ICd0b25fcHJvb2YnKTtcbiAgICAgICAgaWYgKCF0b25BY2NvdW50SXRlbSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcigndG9uX2FkZHIgY29ubmVjdGlvbiBpdGVtIHdhcyBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNSZXF1aXJlZEZlYXR1cmVzID0gY2hlY2tSZXF1aXJlZFdhbGxldEZlYXR1cmVzKGNvbm5lY3RFdmVudC5kZXZpY2UuZmVhdHVyZXMsIHRoaXMud2FsbGV0c1JlcXVpcmVkRmVhdHVyZXMpO1xuICAgICAgICBpZiAoIWhhc1JlcXVpcmVkRmVhdHVyZXMpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMucHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLm9uV2FsbGV0Q29ubmVjdEVycm9yKG5ldyBXYWxsZXRNaXNzaW5nUmVxdWlyZWRGZWF0dXJlc0Vycm9yKCdXYWxsZXQgZG9lcyBub3Qgc3VwcG9ydCByZXF1aXJlZCBmZWF0dXJlcycsIHsgY2F1c2U6IHsgY29ubmVjdEV2ZW50IH0gfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IHtcbiAgICAgICAgICAgIGRldmljZTogY29ubmVjdEV2ZW50LmRldmljZSxcbiAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLnR5cGUsXG4gICAgICAgICAgICBhY2NvdW50OiB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdG9uQWNjb3VudEl0ZW0uYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBjaGFpbjogdG9uQWNjb3VudEl0ZW0ubmV0d29yayxcbiAgICAgICAgICAgICAgICB3YWxsZXRTdGF0ZUluaXQ6IHRvbkFjY291bnRJdGVtLndhbGxldFN0YXRlSW5pdCxcbiAgICAgICAgICAgICAgICBwdWJsaWNLZXk6IHRvbkFjY291bnRJdGVtLnB1YmxpY0tleVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodG9uUHJvb2ZJdGVtKSB7XG4gICAgICAgICAgICBsZXQgdG9uUHJvb2YgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICgncHJvb2YnIGluIHRvblByb29mSXRlbSkgeyAvLyBzdWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIHRvblByb29mID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Rvbl9wcm9vZicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9vZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdG9uUHJvb2ZJdGVtLnByb29mLnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoQnl0ZXM6IHRvblByb29mSXRlbS5wcm9vZi5kb21haW4ubGVuZ3RoQnl0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0b25Qcm9vZkl0ZW0ucHJvb2YuZG9tYWluLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogdG9uUHJvb2ZJdGVtLnByb29mLnBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiB0b25Qcm9vZkl0ZW0ucHJvb2Yuc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgnZXJyb3InIGluIHRvblByb29mSXRlbSkgeyAvLyBlcnJvclxuICAgICAgICAgICAgICAgICAgICB0b25Qcm9vZiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0b25fcHJvb2YnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiB0b25Qcm9vZkl0ZW0uZXJyb3IuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB0b25Qcm9vZkl0ZW0uZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ0ludmFsaWQgZGF0YSBmb3JtYXQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRvblByb29mID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAndG9uX3Byb29mJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IENPTk5FQ1RfSVRFTV9FUlJPUl9DT0RFUy5VTktOT1dOX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgZGF0YSBmb3JtYXQnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2FsbGV0LmNvbm5lY3RJdGVtcyA9IHsgdG9uUHJvb2YgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhbGxldCA9IHdhbGxldDtcbiAgICAgICAgdGhpcy50cmFja2VyLnRyYWNrQ29ubmVjdGlvbkNvbXBsZXRlZCh3YWxsZXQpO1xuICAgIH1cbiAgICBvbldhbGxldENvbm5lY3RFcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLnN0YXR1c0NoYW5nZUVycm9yU3Vic2NyaXB0aW9ucy5mb3JFYWNoKGVycm9yc0hhbmRsZXIgPT4gZXJyb3JzSGFuZGxlcihlcnJvcikpO1xuICAgICAgICBsb2dEZWJ1ZyhlcnJvcik7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE1hbmlmZXN0Tm90Rm91bmRFcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIE1hbmlmZXN0Q29udGVudEVycm9yRXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uV2FsbGV0RGlzY29ubmVjdGVkKHNjb3BlKSB7XG4gICAgICAgIHRoaXMudHJhY2tlci50cmFja0Rpc2Nvbm5lY3Rpb24odGhpcy53YWxsZXQsIHNjb3BlKTtcbiAgICAgICAgdGhpcy53YWxsZXQgPSBudWxsO1xuICAgIH1cbiAgICBjaGVja0Nvbm5lY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUNvbm5lY3RSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3Rvbl9hZGRyJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgICAgICBpZiAocmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXF1ZXN0LnRvblByb29mKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAndG9uX3Byb29mJyxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiByZXF1ZXN0LnRvblByb29mXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFuaWZlc3RVcmw6IHRoaXMuZGFwcFNldHRpbmdzLm1hbmlmZXN0VXJsLFxuICAgICAgICAgICAgaXRlbXNcbiAgICAgICAgfTtcbiAgICB9XG59XG5Ub25Db25uZWN0LndhbGxldHNMaXN0ID0gbmV3IFdhbGxldHNMaXN0TWFuYWdlcigpO1xuLyoqXG4gKiBDaGVjayBpZiBzcGVjaWZpZWQgd2FsbGV0IGlzIGluamVjdGVkIGFuZCBhdmFpbGFibGUgdG8gdXNlIHdpdGggdGhlIGFwcC5cbiAqIEBwYXJhbSB3YWxsZXRKU0tleSB0YXJnZXQgd2FsbGV0J3MganMgYnJpZGdlIGtleS5cbiAqL1xuVG9uQ29ubmVjdC5pc1dhbGxldEluamVjdGVkID0gKHdhbGxldEpTS2V5KSA9PiBJbmplY3RlZFByb3ZpZGVyLmlzV2FsbGV0SW5qZWN0ZWQod2FsbGV0SlNLZXkpO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgYXBwIGlzIG9wZW5lZCBpbnNpZGUgc3BlY2lmaWVkIHdhbGxldCdzIGJyb3dzZXIuXG4gKiBAcGFyYW0gd2FsbGV0SlNLZXkgdGFyZ2V0IHdhbGxldCdzIGpzIGJyaWRnZSBrZXkuXG4gKi9cblRvbkNvbm5lY3QuaXNJbnNpZGVXYWxsZXRCcm93c2VyID0gKHdhbGxldEpTS2V5KSA9PiBJbmplY3RlZFByb3ZpZGVyLmlzSW5zaWRlV2FsbGV0QnJvd3Nlcih3YWxsZXRKU0tleSk7XG5cbmNvbnN0IG5vQm91bmNlYWJsZVRhZyA9IDB4NTE7XG5jb25zdCB0ZXN0T25seVRhZyA9IDB4ODA7XG4vKipcbiAqIENvbnZlcnRzIHJhdyBUT04gYWRkcmVzcyB0byBuby1ib3VuY2VhYmxlIHVzZXItZnJpZW5kbHkgZm9ybWF0LiBbU2VlIGRldGFpbHNde0BsaW5rIGh0dHBzOi8vdG9uLm9yZy9kb2NzL2xlYXJuL292ZXJ2aWV3cy9hZGRyZXNzZXMjdXNlci1mcmllbmRseS1hZGRyZXNzfVxuICogQHBhcmFtIGhleEFkZHJlc3MgcmF3IFRPTiBhZGRyZXNzIGZvcm1hdHRlZCBhcyBcIjA6PGhleCBzdHJpbmcgd2l0aG91dCAweD5cIi5cbiAqIEBwYXJhbSBbdGVzdE9ubHk9ZmFsc2VdIGNvbnZlcnQgYWRkcmVzcyB0byB0ZXN0LW9ubHkgZm9ybS4gW1NlZSBkZXRhaWxzXXtAbGluayBodHRwczovL3Rvbi5vcmcvZG9jcy9sZWFybi9vdmVydmlld3MvYWRkcmVzc2VzI3VzZXItZnJpZW5kbHktYWRkcmVzc31cbiAqL1xuZnVuY3Rpb24gdG9Vc2VyRnJpZW5kbHlBZGRyZXNzKGhleEFkZHJlc3MsIHRlc3RPbmx5ID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IHdjLCBoZXggfSA9IHBhcnNlSGV4QWRkcmVzcyhoZXhBZGRyZXNzKTtcbiAgICBsZXQgdGFnID0gbm9Cb3VuY2VhYmxlVGFnO1xuICAgIGlmICh0ZXN0T25seSkge1xuICAgICAgICB0YWcgfD0gdGVzdE9ubHlUYWc7XG4gICAgfVxuICAgIGNvbnN0IGFkZHIgPSBuZXcgSW50OEFycmF5KDM0KTtcbiAgICBhZGRyWzBdID0gdGFnO1xuICAgIGFkZHJbMV0gPSB3YztcbiAgICBhZGRyLnNldChoZXgsIDIpO1xuICAgIGNvbnN0IGFkZHJlc3NXaXRoQ2hlY2tzdW0gPSBuZXcgVWludDhBcnJheSgzNik7XG4gICAgYWRkcmVzc1dpdGhDaGVja3N1bS5zZXQoYWRkcik7XG4gICAgYWRkcmVzc1dpdGhDaGVja3N1bS5zZXQoY3JjMTYoYWRkciksIDM0KTtcbiAgICBsZXQgYWRkcmVzc0Jhc2U2NCA9IEJhc2U2NC5lbmNvZGUoYWRkcmVzc1dpdGhDaGVja3N1bSk7XG4gICAgcmV0dXJuIGFkZHJlc3NCYXNlNjQucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJyk7XG59XG5mdW5jdGlvbiBwYXJzZUhleEFkZHJlc3MoaGV4QWRkcmVzcykge1xuICAgIGlmICghaGV4QWRkcmVzcy5pbmNsdWRlcygnOicpKSB7XG4gICAgICAgIHRocm93IG5ldyBXcm9uZ0FkZHJlc3NFcnJvcihgV3JvbmcgYWRkcmVzcyAke2hleEFkZHJlc3N9LiBBZGRyZXNzIG11c3QgaW5jbHVkZSBcIjpcIi5gKTtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBoZXhBZGRyZXNzLnNwbGl0KCc6Jyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgV3JvbmdBZGRyZXNzRXJyb3IoYFdyb25nIGFkZHJlc3MgJHtoZXhBZGRyZXNzfS4gQWRkcmVzcyBtdXN0IGluY2x1ZGUgXCI6XCIgb25seSBvbmNlLmApO1xuICAgIH1cbiAgICBjb25zdCB3YyA9IHBhcnNlSW50KHBhcnRzWzBdKTtcbiAgICBpZiAod2MgIT09IDAgJiYgd2MgIT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBXcm9uZ0FkZHJlc3NFcnJvcihgV3JvbmcgYWRkcmVzcyAke2hleEFkZHJlc3N9LiBXQyBtdXN0IGJlIGVxIDAgb3IgLTEsIGJ1dCAke3djfSByZWNlaXZlZC5gKTtcbiAgICB9XG4gICAgY29uc3QgaGV4ID0gcGFydHNbMV07XG4gICAgaWYgKChoZXggPT09IG51bGwgfHwgaGV4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBoZXgubGVuZ3RoKSAhPT0gNjQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdyb25nQWRkcmVzc0Vycm9yKGBXcm9uZyBhZGRyZXNzICR7aGV4QWRkcmVzc30uIEhleCBwYXJ0IG11c3QgYmUgNjRieXRlcyBsZW5ndGgsIGJ1dCAke2hleCA9PT0gbnVsbCB8fCBoZXggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhleC5sZW5ndGh9IHJlY2VpdmVkLmApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB3YyxcbiAgICAgICAgaGV4OiBoZXhUb0J5dGVzKGhleClcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JjMTYoZGF0YSkge1xuICAgIGNvbnN0IHBvbHkgPSAweDEwMjE7XG4gICAgbGV0IHJlZyA9IDA7XG4gICAgY29uc3QgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgMik7XG4gICAgbWVzc2FnZS5zZXQoZGF0YSk7XG4gICAgZm9yIChsZXQgYnl0ZSBvZiBtZXNzYWdlKSB7XG4gICAgICAgIGxldCBtYXNrID0gMHg4MDtcbiAgICAgICAgd2hpbGUgKG1hc2sgPiAwKSB7XG4gICAgICAgICAgICByZWcgPDw9IDE7XG4gICAgICAgICAgICBpZiAoYnl0ZSAmIG1hc2spIHtcbiAgICAgICAgICAgICAgICByZWcgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hc2sgPj49IDE7XG4gICAgICAgICAgICBpZiAocmVnID4gMHhmZmZmKSB7XG4gICAgICAgICAgICAgICAgcmVnICY9IDB4ZmZmZjtcbiAgICAgICAgICAgICAgICByZWcgXj0gcG9seTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW01hdGguZmxvb3IocmVnIC8gMjU2KSwgcmVnICUgMjU2XSk7XG59XG5jb25zdCB0b0J5dGVNYXAgPSB7fTtcbmZvciAobGV0IG9yZCA9IDA7IG9yZCA8PSAweGZmOyBvcmQrKykge1xuICAgIGxldCBzID0gb3JkLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAocy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHMgPSAnMCcgKyBzO1xuICAgIH1cbiAgICB0b0J5dGVNYXBbc10gPSBvcmQ7XG59XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGhleCA9IGhleC50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGxlbmd0aDIgPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW5ndGgyICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VIZXhFcnJvcignSGV4IHN0cmluZyBtdXN0IGhhdmUgbGVuZ3RoIGEgbXVsdGlwbGUgb2YgMjogJyArIGhleCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGxlbmd0aDIgLyAyO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkb3VibGVkID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleFN1YnN0cmluZyA9IGhleC5zdWJzdHJpbmcoZG91YmxlZCwgZG91YmxlZCArIDIpO1xuICAgICAgICBpZiAoIXRvQnl0ZU1hcC5oYXNPd25Qcm9wZXJ0eShoZXhTdWJzdHJpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VIZXhFcnJvcignSW52YWxpZCBoZXggY2hhcmFjdGVyOiAnICsgaGV4U3Vic3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbaV0gPSB0b0J5dGVNYXBbaGV4U3Vic3RyaW5nXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgQmFkUmVxdWVzdEVycm9yLCBCcm93c2VyRXZlbnREaXNwYXRjaGVyLCBGZXRjaFdhbGxldHNFcnJvciwgTG9jYWxzdG9yYWdlTm90Rm91bmRFcnJvciwgUGFyc2VIZXhFcnJvciwgVG9uQ29ubmVjdCwgVG9uQ29ubmVjdEVycm9yLCBVbmtub3duQXBwRXJyb3IsIFVua25vd25FcnJvciwgVXNlclJlamVjdHNFcnJvciwgV2FsbGV0QWxyZWFkeUNvbm5lY3RlZEVycm9yLCBXYWxsZXRNaXNzaW5nUmVxdWlyZWRGZWF0dXJlc0Vycm9yLCBXYWxsZXROb3RDb25uZWN0ZWRFcnJvciwgV2FsbGV0Tm90SW5qZWN0ZWRFcnJvciwgV2FsbGV0Tm90U3VwcG9ydEZlYXR1cmVFcnJvciwgV2FsbGV0c0xpc3RNYW5hZ2VyLCBXcm9uZ0FkZHJlc3NFcnJvciwgY2hlY2tSZXF1aXJlZFdhbGxldEZlYXR1cmVzLCBjcmVhdGVDb25uZWN0aW9uQ29tcGxldGVkRXZlbnQsIGNyZWF0ZUNvbm5lY3Rpb25FcnJvckV2ZW50LCBjcmVhdGVDb25uZWN0aW9uUmVzdG9yaW5nQ29tcGxldGVkRXZlbnQsIGNyZWF0ZUNvbm5lY3Rpb25SZXN0b3JpbmdFcnJvckV2ZW50LCBjcmVhdGVDb25uZWN0aW9uUmVzdG9yaW5nU3RhcnRlZEV2ZW50LCBjcmVhdGVDb25uZWN0aW9uU3RhcnRlZEV2ZW50LCBjcmVhdGVEYXRhU2VudEZvclNpZ25hdHVyZUV2ZW50LCBjcmVhdGVEYXRhU2lnbmVkRXZlbnQsIGNyZWF0ZURhdGFTaWduaW5nRmFpbGVkRXZlbnQsIGNyZWF0ZURpc2Nvbm5lY3Rpb25FdmVudCwgY3JlYXRlUmVxdWVzdFZlcnNpb25FdmVudCwgY3JlYXRlUmVzcG9uc2VWZXJzaW9uRXZlbnQsIGNyZWF0ZVRyYW5zYWN0aW9uU2VudEZvclNpZ25hdHVyZUV2ZW50LCBjcmVhdGVUcmFuc2FjdGlvblNpZ25lZEV2ZW50LCBjcmVhdGVUcmFuc2FjdGlvblNpZ25pbmdGYWlsZWRFdmVudCwgY3JlYXRlVmVyc2lvbkluZm8sIFRvbkNvbm5lY3QgYXMgZGVmYXVsdCwgZW5jb2RlVGVsZWdyYW1VcmxQYXJhbWV0ZXJzLCBpc1RlbGVncmFtVXJsLCBpc1dhbGxldEluZm9DdXJyZW50bHlFbWJlZGRlZCwgaXNXYWxsZXRJbmZvQ3VycmVudGx5SW5qZWN0ZWQsIGlzV2FsbGV0SW5mb0luamVjdGFibGUsIGlzV2FsbGV0SW5mb0luamVjdGVkLCBpc1dhbGxldEluZm9SZW1vdGUsIHRvVXNlckZyaWVuZGx5QWRkcmVzcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@tonconnect+sdk@3.2.0/node_modules/@tonconnect/sdk/lib/esm/index.mjs\n");

/***/ })

};
;